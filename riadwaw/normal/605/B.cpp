/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author RiaD
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class TaskB {
public:
	void solve(std::istream& in, std::ostream& out) {
		int n, m;
		in >> n >> m;
		int curLast = 0;

		vector<pair<int, int>> bad_edges;
		for (int i = 0; i < n && bad_edges.size() < m - n + 1; ++i) {
			for (int j = 0; j + 1 < i && bad_edges.size() < m - n + 1; ++j) {
				bad_edges.emplace_back(i, j);
			}
		}

		vector<Edge> edges(m);
		for (int i = 0; i < m; ++i) {
			in >> edges[i].len >> edges[i].used;
			edges[i].id = i;
		}

		sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
			return a.len < b.len || a.len == b.len && a.used > b.used;
		});


		int last_bad = 0;
		vector<pair<int, int>> ans(m);

		for (Edge e: edges) {
			if (e.used) {
				ans[e.id] = make_pair(curLast, curLast + 1);
				++curLast;
			} else if (bad_edges[last_bad].first > curLast) {
				//cerr << curLast << ' ' << last_bad << ' ' << bad_edges[last_bad].first << endl;
				out << -1;
				return;
			} else {
				ans[e.id] = bad_edges[last_bad++];
			}
		}

		for (int i = 0; i < m; ++i) {
			out << ans[i].first + 1 << ' ' << ans[i].second + 1 << "\n";
		}
	}

	struct Edge {
		int used;
		int len;
		int id;
	};
};


int main() {
	std::ios_base::sync_with_stdio(false);
	TaskB solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	in.tie(0);
	out << std::fixed;
	out.precision(20);
	solver.solve(in, out);
	return 0;
}