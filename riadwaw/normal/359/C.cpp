/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author RiaD
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <bits/stdc++.h>



#include <type_traits>

//FIXME: remove {} when CPP-1825 fixed.
template<typename T, typename Enable = std::true_type>
struct impl__IdentityHelper {

};

template<typename T>
struct impl__IdentityHelper<T, typename std::is_arithmetic<T>::type> {
	static T identity(const T&) {
		return 1;
	}
};

template<typename T>
T identity(const T& sample) {
	return impl__IdentityHelper<T>::identity(sample);
}


#include <string>
#include <stdexcept>
#ifdef SPCPPL_DEBUG
	#define SPCPPL_ASSERT(condition) \
	if(!(condition)) { \
		throw std::runtime_error(std::string() + #condition + " in line " + std::to_string(__LINE__) + " in " + __PRETTY_FUNCTION__); \
	}
#else
	#define SPCPPL_ASSERT(condition)
#endif



template<typename T>
T binpow(T base, long long power) {
	T result = identity<T>(base);
	SPCPPL_ASSERT(power >= 0);
	while(power > 0) {
		if(power & 1) {
			result *= base;
		}
		power >>= 1;
		base *= base;
	}
	return result;
}


/**
* ax + by = result
*/
template <typename T>
T extended_gcd (T a, T b, T& x, T& y) {
	if (a == 0) {
		x = 0;
		y = 1;
		return b;
	}
	T d = extended_gcd(b % a, a, y, x);
	x -= (b / a) * y;
	return d;
}



//FIXME: remove {} when CPP-1825 fixed.
template <bool normalize>
struct impl__Normalizator {

};

template <>
struct impl__Normalizator<true> {
	static void softUp(long long& value, long long mod) {
		if (value < 0) {
			value += mod;
		}
	}

	static void softDown(long long& value, long long mod) {
		if (value >= mod) {
			value -= mod;
		}
	}

	static void hardDown(long long& value, long long mod) {
		value %= mod;
	}

	static void hard(long long& value, long long mod) {
		value %= mod;
		softUp(value, mod);
	}
};

template <>
struct impl__Normalizator<false> {
	static void softUp(long long& value, long long mod) {
	}

	static void softDown(long long& value, long long mod) {
	}

	static void hardDown(long long& value, long long mod) {
	}

	static void hard(long long& value, long long mod) {
	}
};

template <long long mod, bool autoNormalize = true>
class Zn {
public:
	static_assert(mod > 0, "modulo should be positive");

	/**
	* Instead of ctor, to allow not to notmalize in ctor
	*/
	static Zn valueOf(long long value) {
		impl__Normalizator<true>::hard(value, mod);
		return Zn(value);
	}


	Zn& operator += (const Zn& rhs) {
		value += rhs.value;
		impl__Normalizator<autoNormalize>::softDown(value, mod);
		return *this;
	}

	Zn& operator -= (const Zn& rhs) {
		value -= rhs.value;
		impl__Normalizator<autoNormalize>::softUp(value, mod);
		return *this;
	}

	Zn& operator *= (const Zn& rhs) {
		value *= rhs.value;
		impl__Normalizator<autoNormalize>::hardDown(value, mod);
		return *this;
	}

	/**
	* Changes internal state, but doesn't change logical state
	*/
	void normalize() const {
		long long& value = const_cast<long long&>(this->value);
		impl__Normalizator<!autoNormalize>::hard(value, mod);
	}

	Zn& operator - () const {
		Zn result(mod - value);
		impl__Normalizator<autoNormalize>::softDown(result.value, mod);
		return result;
	}

	Zn& operator /= (const Zn& rhs) {
		return *this *= rhs.inversed();
	}

	bool operator == (const Zn& rhs) const {
		normalize();
		rhs.normalize();
		return value == rhs.value;
	}

	Zn inversed() const {
		SPCPPL_ASSERT(value != 0);
		normalize();

		long long x, y;
		long long gcd = extended_gcd(value, mod, x, y);
		SPCPPL_ASSERT(gcd == 1);

		impl__Normalizator<autoNormalize>::softUp(x, mod);
		return Zn(x);
	}

template <long long modF, bool aF>
	friend std::ostream& operator << (std::ostream&, const Zn<modF, aF>& zn);
	template <long long modF, bool aF>
	friend std::istream& operator >> (std::istream&, Zn<modF, aF>& zn);

private:

	/**
	* No normalization performed
	*/
	explicit Zn(long long value): value(value) {
	}

	long long value;
};

template <long long mod, bool a>
Zn<mod, a> operator + (const Zn<mod, a>& lhs, const Zn<mod, a>& rhs) {
	Zn<mod, a> copy = lhs;
	return copy += rhs;
}

template <long long mod, bool a>
Zn<mod, a> operator - (const Zn<mod, a>& lhs, const Zn<mod, a>& rhs) {
	Zn<mod, a> copy = lhs;
	return copy -= rhs;
}

template <long long mod, bool a>
Zn<mod, a> operator * (const Zn<mod, a>& lhs, const Zn<mod, a>& rhs) {
	Zn<mod, a> copy = lhs;
	return copy *= rhs;
}

template <long long mod, bool a>
Zn<mod, a> operator / (const Zn<mod, a>& lhs, const Zn<mod, a>& rhs) {
	Zn<mod, a> copy = lhs;
	return copy /= rhs;
}

template <long long mod, bool a>
std::ostream& operator <<(std::ostream& stream, const Zn<mod, a>& zn) {
	zn.normalize();
	return stream << zn.value;
}

template <long long mod, bool a>
std::istream& operator >>(std::istream& stream, Zn<mod, a>& zn) {
	stream >> zn.value;
	impl__Normalizator<a>::hard(zn.value, mod);
	return stream;
}

template <long long mod, bool a>
struct impl__IdentityHelper<Zn<mod, a>> {
	static Zn<mod, a> identity(const Zn<mod, a>& sample) {
		return Zn<mod, a>::valueOf(1);
	}
};



using namespace std;

class C {
public:
	void solve(std::istream& in, std::ostream& out) {
		int n, x;
		in >> n >> x;
		vector<int> a(n);

		long long sum = 0;
		for(int i = 0; i < n; ++i) {
			in >> a[i];
			sum += a[i];
		}


		map<int, int> cnt;
		for(auto x: a) {
			++cnt[x];
		}

		while(true) {
			int key = cnt.rbegin()->first;
			if(key > 0 && cnt.rbegin()->second % x == 0) {
				cnt[key - 1] += cnt.rbegin()->second / x;
				cnt.erase(key);
			}
			else {
				auto res = binpow(Zn<1000000007>::valueOf(x), sum - key);
				out << res;
				return;
			}
		}

	}
};


int main() {
	std::cin.sync_with_stdio(false);
	std::cin.tie(0);
	std::cout << std::fixed;
	std::cout.precision(20);
	C solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}