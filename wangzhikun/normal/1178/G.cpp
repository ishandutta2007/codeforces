#include <bits/stdc++.h>
using namespace std;typedef long long ll;typedef pair<int,int> pii;template<typename T> void read(T &x){cin>>x;}const int N = 200020;int n,q,fa,a[N],b[N];ll c[N] = {0},d[N] = {0};vector<int> G[N];int dfn[N],sz[N],tim = 1;void dfs(int num){c[num]+=a[num];d[num]+=b[num];dfn[num] = tim;tim+=1;sz[num] = 1;for(auto ct:G[num]){c[ct] = c[num];d[ct] = d[num];dfs(ct);sz[num]+=sz[ct];}}struct P{int id;ll x,y;P(ll cx=0,ll cy=0,ll nid=0):x(cx),y(cy),id(nid){}P operator - (const P &rhs) const{return P(x-rhs.x,y-rhs.y);}bool operator < (const P &rhs) const{if(x!=rhs.x) return x<rhs.x;return y<rhs.y;}ll operator *(const P &rhs) const{if(abs(1.0*x*rhs.y-1.0*y*rhs.x)>1e5){if(1.0*x*rhs.y-1.0*y*rhs.x>0)return 1;else return -1;}return x*rhs.y-y*rhs.x;}};struct convex{int l = 1e9,r =0,cpo = 0;ll accu = 0,cans = 0;vector<P> cp;vector<P> alp;void rebuild(){alp.clear();for(int i=0;i<cp.size();i++){cp[i].y+=cp[i].x*accu;while(alp.size()>=2 && (alp[alp.size()-1]-alp[alp.size()-2])*(cp[i]-alp[alp.size()-1])>=0)alp.pop_back();alp.push_back(cp[i]);}assert(alp.size()!=0);accu = cpo = 0;while(cpo<(int)alp.size()-1 && alp[cpo+1].y>alp[cpo].y) cpo+=1;cans = alp[cpo].y;}void build(){sort(cp.begin(),cp.end());rebuild();}void add(int cl,int cr,int cx){if(cr<l || cl>r)return;if(cl<=l && r<=cr){accu+=cx;if(cx>0)while(cpo<(int)alp.size()-1 && alp[cpo+1].y+alp[cpo+1].x*accu>=alp[cpo].y+alp[cpo].x*accu) cpo+=1;if(cx<0)while(cpo>0 && alp[cpo-1].y+alp[cpo-1].x*accu>=alp[cpo].y+alp[cpo].x*accu) cpo-=1;cans = alp[cpo].y+alp[cpo].x*accu;return;}for(int i=0;i<cp.size();i++){if(cp[i].id<=cr && cp[i].id>=cl)cp[i].y+=cp[i].x*cx;}rebuild();}ll qans(int cl,int cr){if(cr<l || cl>r)return -1e18;if(cl<=l && r<=cr)return cans;ll ans = -1e18;for(auto ct:cp)if(ct.id<=cr && ct.id>=cl)ans = max(ans,ct.y+ct.x*accu);return ans;}}C[2020],rC[2020];int main() {cin>>n>>q;for(int i=2;i<=n;i++){read(fa);G[fa].push_back(i);}for(int i=1;i<=n;i++) read(a[i]);for(int i=1;i<=n;i++) read(b[i]);dfs(1);int blc = sqrt(n/6)+2,blcn = n/blc;for(int i=1;i<=n;i++){d[i] = abs(d[i]);C[dfn[i]/blc].l = min(C[dfn[i]/blc].l,dfn[i]);C[dfn[i]/blc].r = max(C[dfn[i]/blc].r,dfn[i]);C[dfn[i]/blc].cp.push_back(P(d[i],c[i]*d[i],dfn[i]));rC[dfn[i]/blc].cp.push_back(P(d[i],-c[i]*d[i],dfn[i]));}for(int i=0;i<=blcn;i++){C[i].build();rC[i].l = C[i].l;rC[i].r = C[i].r;rC[i].build();}while(q--){int typ,v,x;read(typ);read(v);int l = dfn[v],r = dfn[v]+sz[v]-1;if(typ == 1){read(x);for(int i=0;i<=blcn;i++){rC[i].add(l,r,-x);C[i].add(l,r,x);}}else{ll ans = -1e18;for(int i=0;i<=blcn;i++){ans = max(ans,C[i].qans(l,r));ans = max(ans,rC[i].qans(l,r));}cout<<ans<<endl;}}return 0;}