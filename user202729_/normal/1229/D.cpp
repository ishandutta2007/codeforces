#include<iostream>
#include<array>
#include<queue>
#include<vector>
#include<bitset>
#include<algorithm>

#define char int

int constexpr NELEM=120;

using Elem=std::array<char,5>;

char toint(Elem x){
	char ans=0;
	for(int i=3,mult=1;
			i>=0;
			mult*=5-i,--i){
		auto const xi=x[i];
		ans+=int(std::count_if(begin(x)+i+1,end(x),[xi](int y){return y<xi;})*mult);
	}
	return ans;
}

std::array<std::array<char,NELEM>,NELEM> mult;

int main(){
	std::ios::sync_with_stdio(0);std::cin.tie(0);




	int n,k;std::cin>>n>>k;

	std::vector<char> el(n);

	for(int i=0;i<n;++i){
		Elem e{{0,1,2,3,4}};
		for(int j=0;j<k;++j){
			std::cin>>e[j];
			--e[j];
		}
		el[i]=toint(e);
	}



	{
		std::array<Elem,NELEM> elems;
		Elem e{{0,1,2,3,4}};
		auto iter=begin(elems);
		do{
			*iter=e;
			++iter;
		}while(std::next_permutation(begin(e),end(e)));

		for(int i=0;i<NELEM;++i){
			auto const& ei=elems[i];
			for(int j=0;j<NELEM;++j){
				auto e=elems[j];
				for(int k=0;k<5;++k)
					e[k]=ei[e[k]];
				mult[i][j]=toint(e);
			}
		}
	}


	struct Group{
		std::bitset<NELEM> d;
		Group(char c):d{}{
			char x=0;
			do{
				x=mult[x][c];
				d[x]=true;
			}while(x!=0);
		} // single generator

		Group(Group a,Group b):d{a.d|b.d}{ // merge
			if(d.count()==NELEM)
				return;

			std::queue<char> q;
			std::vector<char> processed;
			for(char i=0;i<NELEM;++i)
				if(d[i]){
					q.push(i);
				}
			while(!q.empty()){
				char x=q.front();q.pop();
				processed.push_back(x);
				for(char y:processed){
					char z=mult[x][y];
					if(!d[z]){
						d[z]=1;
						q.push(z);
					}
				}
				// now all pairs int processed have product queued or processed
			}
		}

		bool operator==(Group const& x)const{
			return d==x.d;
		}
	};

	std::vector<Group> grs;

	// group generated by elem [x] has id [x]
	for(char i=0;i<NELEM;++i)
		grs.emplace_back(i);

	auto const groupid=[&](Group const& x){
		auto iter=std::find(begin(grs),end(grs),x);
		int ans=int(iter-begin(grs));
		if(iter==end(grs))
			grs.push_back(x);
		return ans;
	};

	std::vector<std::vector<int>> multg;
	for(int i=0;i<grs.size();++i){
		multg.emplace_back(i+1);
		for(int j=0;j<i;++j){
			multg[j].push_back(groupid(Group(grs[i],grs[j])));
			multg[i][j]=multg[j][i];
		}
		multg[i].back()=groupid(Group(grs[i],grs[i]));
	}


	/*
	std::cerr<<"{";
	for(auto x:grs){
		std::cerr<<x.d.count()<<',';
	}
	std::cerr<<"}\n";
	return 0;
	*/

	std::vector<char> grcnt{1,2,2,3,3,2,2,2,3,4,4,3,3,4,2,3,2,4,4,3,3,2,4,2,2,2,2,6,6,2,3,6,4,5,5,4,4,5,3,4,6,5,5,4,4,3,5,6,3,6,4,5,5,4,2,2,3,4,4,3,2,6,4,5,5,6,6,2,5,4,6,5,4,5,3,4,6,5,3,4,2,3,2,4,4,5,2,6,6,5,5,6,6,5,2,4,5,4,4,3,5,6,4,3,3,2,4,2,5,4,6,2,5,6,6,5,5,6,4,2,6,4,6,24,6,8,12,8,6,4,8,4,4,4,4,4,6,12,24,120,24,6,24,12,6,12,12,6,6,60,20,20,8,12,10,8,10,8,10,12,20,8,10,20,6,8,10,20,12,6,20,8,10,4,6,24,6,4,12,4,12,8,12,8,12,6,6,6,8,4,8,4,6,4,4,12,4,6,8,12,6,4,8,4,4,4,4,12,6};

	/*
	for(auto x:multg){
		std::cerr<<"{";
		for(int y:x)
			std::cerr<<y<<',';
		std::cerr<<"},\n";
	}
	return 0;
	*/

	/*
	std::vector<std::vector<char>> sparsetable;
	sparsetable.push_back(el);
	for(unsigned step=1;sparsetable.back().size>step;step<<=1){
		std::vector<char> const& a=sparsetable.back();
		std::vector<char> b(a.size()-step);
		std::transform(begin(a),end(a),begin(a)+step,begin(b),
				[&](int a,int b){return multg[a][b];});
		sparsetable.push_back(std::move(b));
	}
	*/

	struct ResultRange{
		int cnt;
		char group;
	};
	std::vector<ResultRange> ranges; // back: nearest to r
	ranges.push_back({1,el[0]});
	int64_t ans=grcnt[el[0]];
	for(int r=1;r<n;++r){
		char const elr=el[r];
		for(auto& x:ranges)
			x.group=multg[x.group][elr];
		ranges.push_back({1,elr});

		auto outlast=begin(ranges);
		for(auto iter=++begin(ranges);iter!=end(ranges);++iter){
			auto r=*iter;
			if(outlast->group==r.group)
				outlast->cnt+=r.cnt;
			else
				*++outlast=r;
		}
		ranges.erase(++outlast,end(ranges));

		for(auto r:ranges)
			ans+=r.cnt*(int64_t)grcnt[r.group];
	}
	std::cout<<ans<<'\n';
}