/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author marX
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>

using namespace std;

struct castle {
    int a, b, c;
};

class DPortals {
public:
    void solve(std::istream &in, std::ostream &out) {
        int n, m, k;
        in >> n >> m >> k;

        vector<castle> C(n);
        vector<int> rem(n);

        int partial = k;

        for (int i = 0; i < n; ++i) {
            int a, b, c;
            in >> a >> b >> c;
            C[i] = {a, b, c};
            rem[i] = partial - a;
            partial += b;
        }

        rem.push_back(partial);

        if (*min_element(rem.begin(), rem.end()) < 0) {
            out << -1 << endl;
            return;
        }

        for (int i = n - 1; i >= 0; --i) {
            rem[i] = min(rem[i], rem[i + 1]);
        }

        vector<vector<int>> graph(n);

        for (int i = 0; i < m; ++i) {
            int u, v;
            in >> u >> v;
            u--;
            v--;
            graph[u].push_back(v);
        }

        vector<bool> vis(n);
        set<pair<int, int>> active;

        function<void(int)> add = [&](int s) {
            if (!vis[s]) {
                vis[s] = true;
                active.insert(make_pair(C[s].c, s));
            }
        };

        int answer = 0;

        for (int i = n - 1; i >= 0; --i) {
            add(i);
            for (auto u : graph[i]) add(u);

            int d = rem[i + 1] - rem[i];

            while (d > 0 && !active.empty()) {
                auto big = *active.rbegin();
                answer += big.first;
                active.erase(big);
                d--;
            }
        }

        int d = rem[0];

        while (d > 0 && !active.empty()) {
            auto big = *active.rbegin();
            answer += big.first;
            active.erase(big);
            d--;
        }

        out << answer << endl;
    }
};


int main() {
    DPortals solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}