#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e6 + 7;
const int kmod = 998244353;
const int prs[] = {
    73 , 79 , 83 , 89 , 97 , 101, 103, 107, 109, 113,
    127, 131, 137, 139, 149, 151, 157, 163, 167, 173,
    179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
    233, 239, 241, 251, 257, 263, 269, 271, 277, 281,
    283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
    353, 359, 367, 373, 379, 383, 389, 397, 401, 409
};
const int mods[] = {
    998244521,998244523,998244529,998244601,998244617,998244619,998244631,998244649,998244673,998244677,
    998244679,998244707,998244713,998244749,998244761,998244787,998244799,998244803,998244839,998244853,
    998244889,998244893,998244899,998244911,998244943,998244967,998244991,998245037,998245063,998245091,
    998245097,998245099,998245109,998245111,998245141,998245147,998245153,998245159,998245169,998245177,
    998245189,998245207,998245211,998245223,998245247,998245331,998245349,998245373,998245403,998245463,
    998245481,998245483,998245487,998245489,998245531,998245543,998245553,998245571,998245613,998245631,
    998245639,998245687,998245697,998245709,998245711,998245733,998245739,998245757,998245777,998245799,
    998245837,998245867,998245877,998245909,998245943,998245949,998245981,998246021,998246047,998246071,
    998246077,998246101,998246129,998246143,998246177,998246189,998246191,998246237,998246251,998246257,
    998246261,998246267,998246279,998246317,998246363,998246369,998246371,998246387,998246399,998246401
};
char a[maxn], l[maxn], r[maxn];
int ha[maxn], hl[maxn], hr[maxn];
int pw[maxn], dp[maxn], zdp[maxn], sdp[maxn];
bool leq[maxn], geq[maxn];

int main() {
    srand(clock() + time(0));
    int pr = prs[rand() % 60], mod = mods[rand() % 100];
    pw[0] = 1;
    for (int i = 1; i < maxn; ++i) pw[i] = pw[i - 1] * 1ll * pr % mod;
    scanf("%s", a + 1);
    scanf("%s", l + 1);
    scanf("%s", r + 1);
    int n = strlen(a + 1), nl = strlen(l + 1), nr = strlen(r + 1);
    for (int i = 1; i <= n; ++i) ha[i] = (ha[i - 1] * 1ll * pr + a[i]) % mod;
    for (int i = 1; i <= nl; ++i) hl[i] = (hl[i - 1] * 1ll * pr + l[i]) % mod;
    for (int i = 1; i <= nr; ++i) hr[i] = (hr[i - 1] * 1ll * pr + r[i]) % mod;
    for (int i = 1; i <= n; ++i) {
        if (i + nl - 1 <= n) {
            if (a[i] != l[1]) {
                leq[i] = (a[i] > l[1]);
            } else {
                int d = 20, p = i + nl - 1;
                while (d--) if (p - (1 << d) >= i) {
                    int t = p - (1 << d);
                    int x = (ha[t] - pw[t - i + 1] * 1ll * ha[i - 1] % mod + mod) % mod;
                    int y = hl[t - i + 1];
                    if (x != y) p = t;
                }
                if (l[p - i + 1] <= a[p]) leq[i] = true;
            }
        }
        if (i + nr - 1 <= n) {
            if (a[i] != r[1]) {
                geq[i] = (a[i] < r[1]);
            } else {
                int d = 20, p = i + nr - 1;
                while (d--) if (p - (1 << d) >= i) {
                    int t = p - (1 << d);
                    int x = (ha[t] - pw[t - i + 1] * 1ll * ha[i - 1] % mod + mod) % mod;
                    int y = hr[t - i + 1];
                    if (x != y) p = t;
                }
                if (r[p - i + 1] >= a[p]) geq[i] = true;
            }
        } 
    }
    dp[0] = 1;
    sdp[0] = 1;
    for (int i = 1; i <= n; ++i) {
        int rb = i - nl;
        if (rb + 1 >= 0 && !leq[rb + 1]) --rb;
        int lb = max(0, i - nr);
        if (lb + 1 >= 0 && lb == i - nr && !geq[lb + 1]) ++lb;
        if (lb > rb || rb < 0 || rb > n || lb < 0 || lb > n) dp[i] = 0;
        else {
            if (lb == 0) {
                dp[i] = sdp[rb];
                (dp[i] += kmod - zdp[rb]) %= kmod;
            } else {
                dp[i] = (sdp[rb] - sdp[lb - 1] + kmod) % kmod;
                (dp[i] += kmod - zdp[rb]) %= kmod;
                (dp[i] += zdp[lb - 1]) %= kmod;
            }
        }
        if (a[i] == '0') {
            if (nl == 1 && l[1] == '0') (dp[i] += dp[i - 1]) %= kmod;
        }
        sdp[i] = (sdp[i - 1] + dp[i]) % kmod;
        zdp[i] = zdp[i - 1];
        if (i + 1 <= n && a[i + 1] == '0') {
            (zdp[i] += dp[i]) %= kmod;
        }
    }
    printf("%d\n", dp[n]);
    return 0;
}