/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
//#include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

constexpr int MAXK = 31;
constexpr int MAXJUMP = 15;
constexpr int INF = 1e9;

struct Fenwick {
  int n;
  vector<short> a;
  const vector<int>& vals;

  explicit Fenwick(int n, const vector<int>& vals) : vals(vals), n(n), a(n, -1) {
  }

  void reset() {
    a.assign(n, -1);
  }

  void fupd(int at, int val) {
    while (at < n) {
      if (a[at] < 0 || (vals[val] > vals[a[at]])) {
        a[at] = val;
      }
      at |= at + 1;
    }
  }

  int fget(int upto) {
    if (upto >= n) upto = n - 1;
    int res = -1;
    while (upto >= 0) {
      if (res < 0 || (a[upto] >= 0 && vals[a[upto]] > vals[res])) {
        res = a[upto];
      }
      upto = (upto & (upto + 1)) - 1;
    }
    return res;
  }
};

class HPrizhkiPoMassivu {
 public:
  vector<int> vals;

  void upd(short& a, short b) {
    if (a < 0 || (b >= 0 && vals[b] > vals[a])) {
      a = b;
    }
  }

  void solveOne() {
    int n, q;
    cin >> n >> q;
    vector<int> a(n);
    for (auto& x : a) cin >> x;
    a.push_back(INF);
    vector<vector<vector<short>>> jump(MAXJUMP, vector<vector<short>>(MAXK, vector<short>(n + 1, -1)));

    vals = vector<int>(a.size());
    for (int i = 0; i < vals.size(); ++i) {
      vals[i] = i + a[i];
    }
    Fenwick fenwick(n + 1, vals);

    for (int i = n; i >= 0; --i) {
      fenwick.fupd(i, i);
      for (int k = 0; k < MAXK; ++k) {
        jump[0][k][i] = fenwick.fget(i + a[i] + k);
      }
    }

    for (int j = 1; j < MAXJUMP; ++j) {
      for (int k1 = 0; k1 < MAXK; ++k1) {
        for (int i = n; i >= 0; --i) {
          for (int k = k1; k < MAXK; ++k) {
            int k2 = k - k1;
            int mx = jump[j - 1][k2][i];
            upd(jump[j][k][i], jump[j - 1][k1][mx]);
          }
        }
      }
    }

    vector<tuple<int, int, int, int>> queries;

    for (int qi = 0; qi < q; ++qi) {
      int l, r, k;
      cin >> l >> r >> k;
      queries.emplace_back(l, r, k, qi);
    }
    sort(all(queries));
    reverse(all(queries));
    vector<int> answers(q, -1);
    for (auto tpl : queries) {
      int l, r, k, qi;
      std::tie(l, r, k, qi) = tpl;
      --l; --r;
      int res = 0;
      if (l == r) {

      } else if (vals[l] + k >= r) {
        res = 1;
      } else {
        res = 2;
        vector<short> best(k + 1, l);
        for (int j = MAXJUMP - 1; j >= 0; --j) {
          bool need = true;
          for (int old = 0; old <= k; ++old) {
            for (int next = k; next >= old; --next) {
              short most = jump[j][next - old][best[old]];
              if (vals[most] + (k - next) >= r) {
                need = false;
              }
            }
          }
          if (need) {
            res += (1 << j);
            for (int old = k; old >= 0; --old) {
              for (int next = k; next >= old; --next) {
                upd(best[next], jump[j][next - old][best[old]]);
              }
            }
          }
        }
      }
      answers[qi] = res;
    }
    for (int x : answers) {
      cout << x << "\n";
    }
  }

  void solve() {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne();
    }
  }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    HPrizhkiPoMassivu solver;


    solver.solve();
    return 0;
}