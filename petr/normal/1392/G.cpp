/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long int64;
typedef vector<int> vi;
typedef pair<int, int> ii;

class TaskG {
 public:
  void swapRight(vector<int> &perm, int a, int b) {
    int t = perm[a];
    perm[a] = perm[b];
    perm[b] = t;
  }

  vector<int> best;
  vector<int> via;

  void upd(int na, int v, int dist) {
    if (dist >= best[na]) return;
    best[na] = dist;
    via[na] = v;
    for (int i = 0; i < k; ++i) {
      upd(na ^ (1 << i), v, dist + 1);
    }
  }

  int k;

  void solveOne(istream &in, ostream &out) {
    int n, m;
    in >> n >> m >> k;
    string start;
    in >> start;
    string finish;
    in >> finish;
    int startMask = 0;
    int finishMask = 0;
    for (int i = 0; i < k; ++i) {
      if (start[i] == '1') startMask |= 1 << i;
      if (finish[i] == '1') finishMask |= 1 << i;
    }
    best = vector<int>(1 << k, k + 1);
    via = vector<int>(1 << k);
    vector<int> a(n);
    vector<int> b(n);
    for (int i = 0; i < n; ++i) {
      in >> a[i] >> b[i];
      --a[i]; --b[i];
    }
    vector<int> permB(k);
    for (int i = 0; i < k; ++i) {
      permB[i] = i;
    }
    vector<int> permA(k);
    for (int i = 0; i < k; ++i) {
      permA[i] = i;
    }
    int res = k + 1;
    int rl = -1;
    int rr = -1;
    for (int i = 0; i < n; ++i) {
      swapRight(permB, a[i], b[i]);
      if (i + 1 >= m) {
        int na = 0;
        for (int j = 0; j < k; ++j) if (startMask & (1 << j)) {
          na |= 1 << permA[j];
        }
        upd(na, i + 1 - m, 0);
        int nb = 0;
        for (int j = 0; j < k; ++j) if (finishMask & (1 << j)) {
          nb |= 1 << permB[j];
        }
        if (best[nb] < res) {
          res = best[nb];
          rl = via[nb];
          rr = i;
        }
        swapRight(permA, a[i + 1 - m], b[i + 1 - m]);
      }
    }
    out << k - res << "\n";
    out << (rl + 1) << " " << (rr + 1) << "\n";
  }

  void solve(std::istream &in, std::ostream &out) {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne(in, out);
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  TaskG solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}