/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author majk
 */

#ifndef MAJK_LIB
#define MAJK_LIB

#include <vector>
#include <stack>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <iomanip>
#include <set>
#include <functional>
#include <fstream>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <string>
#include <sstream>
#include <queue>
#include <bitset>
using namespace std;

#define x first
#define y second
typedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;

template <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}
template<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}
template <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}
template<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<" \n"[i == t.size()-1];}return o;}
template<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;
template<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;
template <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }
ui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }

namespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }
template<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}
template<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}
template<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}
template<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}
template<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }

template<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};
template<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};
template<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};
template<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};


#endif


constexpr double PI = 3.14159265358979323846;
template <typename T> struct Segment;

template <typename T> struct Point : public pair<T,T> {
    Point(T a=0,T b=0) : pair<T,T>(a,b) {}
    Point(const pair<T,T> &p) : pair<T,T>(p.x,p.y) {}
    Point(const Point<T>&p) = default;
    Point<T>& operator=(const Point<T>&p) = default;

    T squaredDistance(const Point<T>&o) const { return Segment<T>{*this,o}.squaredLength(); }
    double distance(const Point<T>&o) const { return Segment<T>{*this,o}.length(); }
};

template <typename T> ostream& operator<<(ostream&o, const Point<T>&p) { o << p.x << ' ' << p.y; return o; }

template <typename T> T ccw(const Point<T>&a, const Point<T>&b, const Point<T>&c) { return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x); }
template <typename T> T area(const Point<T>&a,const Point<T>&b,const Point<T>&c) { return abs(ccw(a,b,c)); }
template <typename T> double cosangle(const Point<T>&a, const Point<T> &b, const Point<T> &c) {
    return ((b.x-a.x)*(c.x-a.x) + (b.y-a.y)*(c.y-a.y)) / a.distance(b) / a.distance(c);
}

template <typename T> bool acuteAngle(const Point<T> &a, const Point<T> &b, const Point<T> &c) {
    return ((b.x-a.x)*(c.x-a.x) + (b.y-a.y)*(c.y-a.y)) > 0;
}
template <typename T> bool obtuseAngle(const Point<T> &a, const Point<T> &b, const Point<T> &c) {
    return ((b.x-a.x)*(c.x-a.x) + (b.y-a.y)*(c.y-a.y)) < 0;
}
template <typename T> bool rightAngle(const Point<T> &a, const Point<T> &b, const Point<T> &c) {
    return ((b.x-a.x)*(c.x-a.x) + (b.y-a.y)*(c.y-a.y)) == 0;
}
template <typename T> double angle(const Point<T>&a, const Point<T> &b, const Point<T> &c) {
    return acos(cosangle(a,b,c));
}
template <typename T> int orientation(const Point<T>&a, const Point<T>&b, const Point<T>&c) { auto o = ccw(a,b,c); return (o>1e-6)-(o<-1e-6); }
template <typename T> bool collinear(const Point<T>&a, const Point<T>&b, const Point<T>&c) { return orientation(a,b,c) == 0; }

template <typename T> struct Segment : public pair<Point<T>,Point<T>> {
    using pair<Point<T>,Point<T>>::x;
    using pair<Point<T>,Point<T>>::y;
    explicit Segment(Point<T> a={0,0}, Point<T> b={0,0}) : pair<Point<T>,Point<T>>(a,b) {}
    Segment(const Segment<T>&) = default;
    Segment<T>& operator=(const Segment<T>&) = default;
    inline T dx() const { return x.x - y.x; }
    inline T dy() const { return x.y - y.y; }
    T squaredLength() const { return dx()*dx()+dy()*dy(); }
    double length() const { return sqrt(squaredLength()); }

    bool contains(const Point<T> &q) const {
        return collinear(x,q,y) && ((q.x <= max(x.x, y.x) && q.x >= min(x.x, y.x)) && (q.y <= max(x.y, y.y) && q.y >= min(x.y, y.y)));
    }

    double distance(const Point<T>&p) const {
        double u = ((p.x-y.x) * dx() + (p.y-y.y) * dy()) / double(dx()*dx()+dy()*dy());
        if (u > 1) u = 1;
        if (u < 0) u = 0;
        return Point<double>(p.x,p.y).distance({y.x + u * dx(), y.y + u * dy()});
    }

    bool intersect(const Segment<T>&s) const {
        return (orientation(x, y, s.x) != orientation(x, y, s.y) && orientation(s.x, s.y, x) != orientation(s.x, s.y, y))
               || contains(s.x) || contains(s.y) || s.contains(x) || s.contains(y);
    }
};

template <typename T> struct Line : public pair<Point<T>,Point<T>> {
    using pair<Point<T>,Point<T>>::x;
    using pair<Point<T>,Point<T>>::y;
    Line(Point<T> a = {0, 0}, Point<T> b = {0, 0}) : pair<Point<T>, Point<T>>(a, b) {}
    explicit Line(const Segment<T> &s) : pair<Point<T>, Point<T>>(s.x, s.y) {}
    Line(const Line<T> &p) = default;
    Line<T> &operator=(const Line<T> &p) = default;
    inline T dx() const { return x.x - y.x; }
    inline T dy() const { return x.y - y.y; }
    inline T c() const { return x.y * y.x - x.x * y.y; }

    double distance(const Point<T> &p) const {
        ll px = dx(), py = dy(), dL = px * px + py * py;
        return abs(py * p.x - px * p.y + y.x * x.y - y.y * x.x) / sqrt(dL);
    }

    Point<double> project(const Point<T> &p) const {
        double u = ((p.x - y.x) * dx() + (p.y - y.y) * dy()) / double(dx() * dx() + dy() * dy());
        return {y.x + u * dx(), y.y + u * dy()};
    }

    bool parallel(const Line<T> &l) const {
        return abs(l.dx() * dy()-l.dy() * dx()) < 1e-6;
    }

    Point<double> intersection(const Line<T> &l) {
        double det = l.dx() * dy()-l.dy() * dx();
        if (abs(det) < 1e-6) /// det == 0
            return {1e300, 1e300}; /// no intersection
        else {
            double c1 = c(), c2 = l.c();
            double x = -(c2 * dx() - l.dx() * c1) / det;
            double y = -(-l.dy() * c1 + c2 * dy()) / det;
            return {x, y};
        }

    };
};

template <typename T> struct Circle {
    Point<T> center;
    T radius;

    bool intersect(const Circle<T>&o) const {
        return o.center.squaredDistance(center) <= (radius+o.radius)*(radius+o.radius);
    }
    bool contains(const Point<T>&p) const {
        return p.squaredDistance(center) <= radius*radius;
    }
    bool contains(const Circle<T>&o) const {
        return radius>=o.radius && o.center.squaredDistance(center) <= (radius-o.radius)*(radius-o.radius);
    }
    bool touches(const Circle<T>&o) const {
        T dist = center.squaredDistance(o.center);
        return dist == (radius-o.radius)*(radius-o.radius) || dist == (radius+o.radius)*(radius+o.radius);
    }
};

template <typename T> struct Polygon : public vector<Point<T>> {
    using vector<Point<T>>::vector;
    using vector<Point<T>>::at;
    using vector<Point<T>>::front;
    using vector<Point<T>>::back;

    T doubleSignedArea() const {
        if (this->empty()) return T(0);
        T area = back().x*front().y - back().y*front().x;
        for (int i = 0; i < this->size()-1; ++i) area += (at(i).x * at(i+1).y - at(i+1).x * at(i).y);
        return area;
    }

    double circumference() const {
        if (this->empty()) return T(0);
        T res = back().distance(front());
        for (int i = 0; i < this->size()-1; ++i) res += at(i).distance(at(i+1));
        return res;
    }
};

template <typename T> Polygon<T> convexhull(const vector<Point<T>> &v) {
    ui N = (ui)v.size(); vector<Point<T>> w(N+1); int lo = 0;
    for (int i = 0; i<N; ++i) if (v[i].y < v[lo].y) lo = i;
    Point<T> o = v[lo];
    for (int i = 0; i<N; ++i) w[i+1] = {v[i].x-o.x,v[i].y-o.y};
    swap(w[1],w[lo+1]);
    sort(w.begin()+2,w.end(),[](Point<T>&a,Point<T>&b) {
        if (a.y==0&&a.x>0) return true;
        if (b.y==0&&b.x>0) return false;
        if (a.y>0&&b.y<0) return true;
        return !(a.y<0&&b.y>0) && (a.x*b.y-a.y*b.x)>0;
    });
    w[0] = w[N];
    ui M=1;
    for (int i=2;i<=N;++i) {
        while(ccw(w[M-1],w[M],w[i]) <= 0) if (M>1) --M; else if (i == N) break; else ++i;
        ++M; swap(w[M],w[i]);
    }
    Polygon<T> res(M);
    for (int i=0;i<M;++i) res[i] = {w[i+1].x+o.x,w[i+1].y+o.y};
    return res;
}

class Fraction {
    friend ostream& operator<<(ostream& os, const Fraction& f);
public:
    Fraction(ll u = 0, ll v = 1) : u(u), v(v) { norm(); }
    bool operator==(const Fraction & o) const { return u == o.u && v == o.v; }
    bool operator!=(const Fraction & o) const { return u != o.u || v != o.v; }
    bool operator<(const Fraction &o) const { return u*o.v < o.u*v; }
    bool operator<=(const Fraction &o) const { return u*o.v <= o.u*v; }
    bool operator>(const Fraction &o) const { return u*o.v > o.u*v; }
    bool operator>=(const Fraction &o) const { return u*o.v >= o.u*v; }
    Fraction operator-(const Fraction& o) { return Fraction(-u, v); }
    Fraction& operator+=(const Fraction& o) { u = u * o.v + v * o.u; v *= o.v; return norm(); }
    Fraction& operator-=(const Fraction& o) { u = u * o.v - v * o.u; v *= o.v; return norm(); }
    Fraction& operator/=(const Fraction& o) { u = u * o.v; v = o.u * v; return norm(); }
    Fraction& operator*=(const Fraction& o) { u *= o.u; v *= o.v; return norm(); }
    Fraction operator+(const Fraction& o) const { Fraction f(*this); return f += o; }
    Fraction operator-(const Fraction& o) const { Fraction f(*this); return f -= o; }
    Fraction operator*(const Fraction& o) const { Fraction f(*this); return f *= o; }
    Fraction operator/(const Fraction& o) const { Fraction f(*this); return f /= o; }

private:
    Fraction& norm() {
        ll g = gcd(abs(u),abs(v));
        u /= g;
        v /= g;
        return *this;
    }

    ll u,v;
};


ostream& operator<<(ostream& os, const Fraction& f) {
    os << f.u << '/' << f.v;
    return os;
}
#ifndef MAJK_MATRIX
#define MAJK_MATRIX


template <typename T> class Matrix {
public:
	Matrix(size_t R, size_t C, T t=T(0)) : R(R), C(C), A(R,vector<T>(C,t)), def(t) {}
	Matrix(const vector<vector<T>> &a, T t=T(0)) : R(a.size()), C(a[0].size()), A(a), def(t) {}
	Matrix(const initializer_list<vector<T>> &a, T t=T(0)) : R(a.size()), C(a.begin()->size()), A(a), def(t) {}
	size_t rows() const { return R; }
	size_t columns() const { return C; }
	bool isSquare() const { return R*C; }
	bool isIdentity() const {
		for (int i = 0; i < min(R,C); ++i) {
			for (int j = 0; j < min(R,C); ++j) {
				if (i == j && A[i][j] != 1) return false;
				if (i != j && A[i][j] != 0) return false;
			}
		}
		return true;
	}

	void addColumnsRight(size_t add, T t=T()) {
		for (int i = 0; i < R; ++i) {
			A[i].resize(C + add);
			for (size_t j = C; j < C+add; ++j) A[i][j] = t;
		}
		C += add;
	}

	void removeColumnsLeft(size_t rem) {
		for (size_t i = 0; i < R; ++i) A[i].erase(A[i].begin(), rem > A[i].size() ? A[i].end() : A[i].begin()+rem);
	}

	T determinant() const {
		if (!isSquare()) { throw std::runtime_error("Cannot compute determinant of a rectangular matrix"); }
		Matrix<T> tmp(*this);
		T ans = tmp.toReducedRowEchelon();
		if (tmp.isIdentity()) return ans;
		else return 0;
	}

	vector<T> solveFor(const vector<T> &b) {
		if (!isSquare()) { throw std::runtime_error("Cannot solve a rectangular matrix"); }
		if (b.size() != R) throw new std::runtime_error("Unable to solve linear equation, dimensions do not match");
		Matrix<T> tmp(*this);
		for (int i = 0; i < R; ++i) tmp.A[i].push_back(b[i]);
		++tmp.C;
		tmp.toReducedRowEchelon();
		if (!tmp.isIdentity()) throw std::runtime_error("Cannot solve a singular matrix");
		vector<T> Ans(R);
		for (int j = 0; j < R; ++j) Ans[j] = tmp.A[j].back();
		return Ans;
	}

	Matrix<T> power(ull N) {
		if (!isSquare()) { throw std::runtime_error("Cannot compute determinant of a rectangular matrix"); }

		Matrix<T> ans(R, R, 0), pow = *this;
		for (ui r = 0; r < R; ++r) ans[r][r] = 1;
		while (N) {
			if (N&1) ans = ans * pow;
			N >>= 1;
			pow = pow * pow;
		}
		return ans;
	}

	Matrix<T> & operator+=(const Matrix<T>&m) {
		if (R != m.R) throw std::runtime_error("Cannot add matrices of different height");
		if (C != m.C) throw std::runtime_error("Cannot add matrices of different width");
		for (int i = 0; i < R; ++i) {
			for (int j = 0; j < C; ++j) {
				A[i][j] += m.A[i][j];
			}
		}
		return *this;
	}

	Matrix<T> & operator-=(const Matrix<T>&m) {
		if (R != m.R) throw std::runtime_error("Cannot substract matrices of different height");
		if (C != m.C) throw std::runtime_error("Cannot substract matrices of different width");
		for (int i = 0; i < R; ++i) {
			for (int j = 0; j < C; ++j) {
				A[i][j] -= m.A[i][j];
			}
		}
		return *this;
	}

	Matrix<T> operator*(const Matrix<T>&m) const {
		if (C != m.R) throw std::runtime_error("Matrices incompatible for multiplication");
		Matrix<T> Ans(R, m.C, T(0));
		for (int i = 0; i < R; ++i) {
			for (int j = 0; j < m.C; ++j) {
				for (int k = 0; k < C; ++k) {
					Ans[i][j] += A[i][k] * m.A[k][j];
				}
			}
		}
		return Ans;
	}

	vector<T> operator*(const vector<T>&m) const {
		if (C != m.size()) throw std::runtime_error("Matric and vector incompatible for multiplication");
		vector<T> ans(R, def);
		for (ui r = 0; r < R; ++r) {
			for (ui c = 0; c < C; ++c) {
				ans[r] += m[c]* (*this)[r][c];
			}
		}
		return ans;
	}

	class Row {
	public:
		Row(Matrix<T>*M, size_t row) : M(M), row(row) {}
		T &operator[](size_t col) {
			if (col < 0 || col >= M->C) throw std::out_of_range("Invalid column ID");
			return M->A[row][col];
		}
		const T &operator[](size_t col) const {
			if (col < 0 || col >= M->C) throw std::out_of_range("Invalid column ID");
			return M->A[row][col];
		}
	private:
		Matrix<T> *M; size_t row;
	};

	Row operator[](size_t row) {
		if (row < 0 || row >= R) throw std::out_of_range("Invalid row ID");
		return Row(this, row);
	}

	const Row operator[](size_t row) const {
		if (row < 0 || row >= R) throw std::out_of_range("Invalid row ID");
		return Row(const_cast<Matrix<T>*>(this), row);
	}

	Matrix<T> transposed() const {
		Matrix<T> M(*this);
		M.transpose();
		return M;
	}

	Matrix<T> inverted() const {
		if (R != C) throw std::runtime_error("Matrix not square");
		Matrix<T> M(*this);
		M.invert();
		return M;
	}

	Matrix<T> &transpose() {
		A.resize(max(R,C));
		for (size_t i = 0; i < C; ++i) A[i].resize(max(R,C));
		for (size_t i = 0; i < R; ++i) {
			for (size_t j = i+1; j < C; ++j) swap(A[i][j], A[j][i]);
		}
		for (size_t i = 0; i < C; ++i) A[i].resize(R);
		A.resize(C);
		return *this;
	}

	Matrix<T> &invert() {
		addColumnsRight(C, def);
		for (size_t i = 0; i < R; ++i) A[i][R + i] = 1;
		toReducedRowEchelon();
		if (!isIdentity()) throw std::runtime_error("Matrix not invertible");
		removeColumnsLeft(C/2);
		return *this;
	}


private:
	T toReducedRowEchelon() {
		size_t pivot = 0;
		T factor = 1;
		for (size_t i = 0; i < C && pivot < R; ++i) {
			pair<T, size_t> Q = {A[pivot][i], pivot};
			for (size_t j = pivot+1; j < R; ++j) if (A[j][i] != 0) Q = {A[j][i], j};
			if (Q.x == 0) continue;
			if (Q.y != i) swap(A[Q.y], A[pivot]);
			for (size_t j = i+1; j < C; ++j) A[pivot][j] /= A[pivot][i];
			factor /= A[pivot][i];
			A[pivot][i] = 1;

			for (size_t j = 0; j < R; ++j) {
				if (j != pivot) {
					for (size_t k = i + 1; k < C; ++k) A[j][k] -= A[pivot][k] * A[j][i];
					A[j][i] = 0;
				}
			}

			++pivot;
		}
		return factor;
	}

	size_t R, C;
	vector<vector<T>> A;
	T def;
};

template<typename T>std::ostream &operator<<(std::ostream&os,const Matrix<T>&m) {
	for (size_t r = 0; r < m.rows(); ++r) for (size_t c = 0; c < m.columns(); ++c) os << m[r][c] << " \n"[c == m.columns()-1];
	return os;
}

#endif

class signposts {
public:

    struct Line {
        int a,b,c;
    };

    int N, K;
    vector<Line> L;
    vector<int> R;
    vector<Point<Fraction>> S;

    bool intersect(const Line&l, const Line&k) {
        return ll(l.a)*k.b != ll(l.b)*k.a;
    }

    Point<Fraction> getIntersection(const Line&l, const Line&k) {
        Matrix<Fraction> W{2,2};
        W[0][0] = l.a; W[0][1] = l.b;
        W[1][0] = k.a; W[1][1] = k.b;
        auto s = W.solveFor({-l.c,-k.c});
        return {s[0],s[1]};
    }

    bool goesThrough(const Line&l, Point<Fraction>&f) {
        return f.x * l.a + f.y * l.b + l.c == 0;
    }

    bool solve(int i) {
        if (i == N) return true;

        bool pnt = false;
        for (auto&s:S) pnt |= goesThrough(L[i], s);
        if (pnt) return solve(i+1);

        bool add = true;
        for (int j = 0; j < K; ++j) {
            if (R[j] == -1 && add) {
                R[j] = i;
                if (solve(i+1)) return true;
                R[j] = -1;
                add = false;
            } else if (R[j] >= 0 && intersect(L[i], L[R[j]])) {
                int o = R[j];
                S.push_back(getIntersection(L[i], L[R[j]]));
                R[j] = -2;
                if (solve(i+1)) return true;
                R[j] = o;
                S.pop_back();
            }
        }

        return false;
    }


    void solve(istream& cin, ostream& cout) {

        cin >> N >> K;
        if (N == 1) {
            cout << "YES\n1\n1 -1\n"; return;
        }
        L.resize(N);
        R = vector<int>(K, -1);
        for (int i = 0; i < N; ++i) {
            cin >> L[i].a >> L[i].b >> L[i].c;
        }

        if (solve(0)) {
            cout << "YES\n";
            cout << K << "\n";
            for (auto&s:S) {
                vector<int> Z;
                for (int i = 0; i < N; ++i) {
                    if (goesThrough(L[i],s)) Z.push_back(i);
                }
                cout << Z[0]+1 << ' ' << Z[1]+1 << '\n';
            }
            for (int j = 0; j < K; ++j) {
                if (R[j] == -1) {
                    cout << "1 -1\n";
                } else if (R[j] >= 0) {
                    cout << R[j]+1 << ' ' << -1 << '\n';
                }
            }
        } else {
            cout << "NO\n";
        }

    }
};


int main() {
	ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
	signposts solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
    return 0;
}