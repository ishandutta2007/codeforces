/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author RiaD
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <vector>




#include <string>
#include <stdexcept>
#ifdef SPCPPL_DEBUG
	#define SPCPPL_ASSERT(condition) \
	if(!(condition)) { \
		throw std::runtime_error(std::string() + #condition + " in line " + std::to_string(__LINE__) + " in " + __PRETTY_FUNCTION__); \
	}
#else
	#define SPCPPL_ASSERT(condition)
#endif


#include <cstddef>

template <typename T, typename U, typename V>
void impl__matrix_multiplication(const T& lhs, const U& rhs, V& res) {
	const auto& a = lhs;
	auto b = rhs.transposed();
	for(std::size_t i = 0; i < lhs.rows(); ++i) {
		for(std::size_t j = 0; j < rhs.columns(); ++j) {
			for(std::size_t k = 0; k < rhs.rows(); ++k) {
				res[i][j] += a[i][k] * b[j][k];
			}
		}
	}
}



#include <type_traits>

//FIXME: remove {} when CPP-1825 fixed.
template<typename T, typename Enable = std::true_type>
struct impl__IdentityHelper {

};

template<typename T>
struct impl__IdentityHelper<T, typename std::is_arithmetic<T>::type> {
	static T identity(const T&) {
		return 1;
	}
};

template<typename T>
T identity(const T& sample) {
	return impl__IdentityHelper<T>::identity(sample);
}


template <typename T, typename Container>
class Row {
public:

	explicit Row(Container& value): value(value) {

	}

	T& operator [] (size_t index) {
		SPCPPL_ASSERT(index < value.size());
		return value[index];
	}

	const T& operator [] (size_t index) const {
		SPCPPL_ASSERT(index < value.size());
		return value[index];
	}

private:
	Container& value;
};

template <typename T>
class Matrix {
public:
	Matrix(std::size_t n, std::size_t m, const T& value = T()): value(n, std::vector<T>(m, value)) {

	}

	size_t rows() const {
		return value.size();
	}

	size_t columns() const {
		return value[0].size();
	}

	Row<T, std::vector<T>> operator [] (std::size_t index) {
		SPCPPL_ASSERT(index < value.size());
		return Row<T, std::vector<T>>(value[index]);
	}

	Row<const T, const std::vector<T>> operator[] (std::size_t index) const {
		SPCPPL_ASSERT(index < value.size());
		return Row<const T, const std::vector<T>>(value[index]);
	}

	Matrix& operator *= (const Matrix& rhs) {
		SPCPPL_ASSERT(rows() == columns() && rhs.rows() == rhs.columns());
		return *this = *this * rhs;
	}

	Matrix& operator += (const Matrix& rhs) {
		SPCPPL_ASSERT(rows() == rhs.rows() && columns() == rhs.columns());
		for(size_t i = 0; i < rows(); ++i) {
			for(size_t j = 0; j < columns(); ++j) {
				value[i][j] += rhs.value[i][j];
			}
		}
		return *this;
	}

	Matrix operator - () const {
		Matrix copy = *this;
		for(int i = 0; i < rows(); ++i) {
			for(int j  = 0; j < columns(); ++j) {
				copy[i][j] = -copy[i][j];
			}
		}
		return copy;
	}

	Matrix operator -= (const Matrix& rhs) {
		return *this += -rhs;
	}


	Matrix<T> transposed() const {
		Matrix<T> res(columns(), rows());
		for(int i = 0; i < rows(); ++i)
			for(int j = 0; j < columns(); ++j)
				res[j][i] = (*this)[i][j];
		return res;

	}

private:
	std::vector<std::vector<T>> value;
};


template <typename T>
Matrix<T> operator * (const Matrix<T>& lhs, const Matrix<T>& rhs) {
	SPCPPL_ASSERT(lhs.columns() == rhs.rows());
	Matrix<T> res{lhs.rows(), rhs.columns()};
	impl__matrix_multiplication(lhs, rhs, res);
	return res;
}

template <typename T, typename C1, typename C2>
Matrix<T> operator + (Matrix<T> lhs, const Matrix<T>& rhs) {
	Matrix<T> copy = std::move(lhs);
	return copy += rhs;
}

template <typename T, typename C1, typename C2>
Matrix<T> operator - (Matrix<T> lhs, const Matrix<T>& rhs) {
	Matrix<T> copy = std::move(lhs);
	return copy -= rhs;
}

template<typename T>
struct impl__IdentityHelper<Matrix<T>> {
	static Matrix<T> identity(const Matrix<T>& sample) {
		SPCPPL_ASSERT(sample.rows() == sample.columns());
		Matrix<T> res(sample.rows(), sample.rows());
		for (std::size_t i = 0; i < sample.rows(); ++i) {
			res[i][i] = ::identity(sample[0][0]);
		}
		return res;
	}
};





template<typename T>
T binpow(T base, long long power) {
	T result = identity<T>(base);
	SPCPPL_ASSERT(power >= 0);
	while(power > 0) {
		if(power & 1) {
			result *= base;
		}
		power >>= 1;
		base *= base;
	}
	return result;
}


using namespace std;

class TaskG2 {
public:
	void solve(std::istream& in, std::ostream& out) {
		int n, k;
		in >> n >> k;
		vector<int> v(n);


		for(int i = 0; i < n; ++i) {
			in >> v[i];
			--v[i];
		}

		vector<int> obr(n);

		for(int i = 0; i < n; ++i) {
			obr[v[i]] = i;
		}


		Matrix<double> matrix(n * n, n * n);
		for (int wasi = 0; wasi < n; ++wasi)
			for (int wasj = 0; wasj < n; ++wasj) {
				for(int l = 0; l < n; ++l) {
					for(int r = l + 1; r <= n; ++r) {
						int newi = wasi;
						if(newi >= l && newi < r)
							newi = r + l - 1 - newi;
						int newj = wasj;
						if(newj >= l && newj < r)
							newj = r + l - 1 - newj;

						matrix[wasi + n * wasj][newi + n * newj] += 2.0 / n / (n + 1);
					}
				}
			}

		matrix = binpow(matrix, k);

		double ans = 0;
		for(int i = 0; i < n; ++i)
			for(int j = i + 1; j < n; ++j) {

				//vector<vector<double>> x(n, vector<double>(n, 0));
				//br[i]][obr[j]] = 1;



				int wasid = obr[i] + n * obr[j];

				for(int i = 0; i < n; ++i) {
					for(int j = 0; j < i; ++j) {
						ans +=matrix[wasid][i + n * j];
					}
				}

				//out << i << ' ' << j << ' ' << ans << endl;;
			}

		out << ans << endl;

	}
};


int main() {
	std::cin.sync_with_stdio(false);
	std::cin.tie(0);
	std::cout << std::fixed;
	std::cout.precision(20);
	TaskG2 solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}