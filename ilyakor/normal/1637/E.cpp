/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>
#include <unordered_map>
#include <unordered_set>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

constexpr int BUBEN = 100;

class TaskE {
public:
	void solve(std::istream& in, std::ostream& out) {
	    int n, m;
	    in >> n >> m;
//	    n = 300 * 1000;
//	    m = 300 * 1000;
	    vi a(n);
	    unordered_map<int, int> cnt;
	    for (int i = 0; i < n; ++i) {
	        in >> a[i];
//	        a[i] = abs(rand() % 1000);
	        ++cnt[a[i]];
	    }
	    vector<ii> banned;
	    for (int i = 0; i < m; ++i) {
	        int x, y;
	        in >> x >> y;
//	        x = rand() % 1000;
//	        y = rand() % 1000;
	        banned.emplace_back(x, y);
            banned.emplace_back(y, x);
	    }
	    unordered_set<int64> banned_set;
	    for (ii e : banned) banned_set.insert((((int64) e.first) << 30LL) + e.second);
	    sort(all(banned));
	    sort(all(a));
	    a.erase(unique(all(a)), a.end());
        sort(all(a));
	    reverse(all(a));
	    vector<vi> items(n + 1);
	    for (int x : a) {
	        if (!items[cnt[x]].empty()) assert(x < *items[cnt[x]].rbegin());
            items[cnt[x]].push_back(x);
        }

        unordered_map<int, int> pos;
        int prev = 0;
        sort(all(a));
        for (int i = 0; i < sz(banned); ++i) {
            auto e = banned[i];
            int x = e.first;
            while (prev < sz(a) && a[prev] <= x) {
                pos[a[prev]] = i;
                ++prev;
            }
        }
        vi vc(sz(a));
        for (int i = 0; i < sz(a); ++i)
            vc[i] = cnt[a[i]];

        int64 res = 0;
	    for (int i = BUBEN; i < sz(items); ++i) {
	        for (int x : items[i]) {
	            int p = pos[x];
	            for (int j = 0; j < sz(a); ++j) if (a[j] != x) {
	                while (p < sz(banned) && banned[p].first == x && banned[p].second < a[j]) ++p;
	                if (p < sz(banned) && banned[p].first == x && banned[p].second == a[j]) continue;
//	                assert(!banned_set.count((((int64) x) << 30LL) + a[j]));
	                res = max(res, (x + a[j]) * (int64)(i + vc[j]));
	            }
	        }
	    }

	    for (int i = 0; i < BUBEN && i < sz(items); ++i) if sz(items[i]) {
                for (int j = i; j < BUBEN && j < sz(items); ++j)
                    if sz(items[j]) {
                        int ni = sz(items[i]);
                        int nj = sz(items[j]);
                        for (int pi = 0; pi < ni; ++pi) {
                            int pj = 0;
                            int x = items[i][pi];
                            for (; pj < nj; ++pj) {
                                int y = items[j][pj];
                                if (x != y) {
                                    if (!banned_set.count((((int64) x) << 30LL) + y)) {
                                        res = max(res, (x + y) * (int64)(i + j));
                                        break;
                                    }
                                }
                            }
                            nj = pj;
                            if (nj == 0) break;
                        }
//                        for (int s = 0; s < ni + nj; ++s) {
//                            // pj = s - pi
//                            // pi <= min(s, ni)
//                            // s - pi < nj => pi >= max(s - nj + 1, 0)
//                            int l = max(s - nj + 1, 0), r = min(s + 1, ni);
//                            bool was = false;
//                            for (int pi = l; pi < r; ++pi) {
////                                assert(s - pi >= 0);
////                                assert(s - pi < nj);
////                                assert(pi < ni);
//                                int x = items[i][pi];
//                                int y = items[j][s - pi];
//                                if (x != y) {
//                                    if (!banned_set.count((((int64) x) << 30LL) + y)) {
//                                        was = true;
//                                        res = max(res, (x + y) * (int64)(i + j));
//                                    }
//                                }
//                            }
//                            if (was) break;
//                        }
                    }
            }

	    out << res << "\n";
	}
};


int main() {
	TaskE solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	ios_base::sync_with_stdio(false);
    in.tie(nullptr);
    out.tie(nullptr);
	int n;
in >> n;
for(int i = 0; i < n; ++i) {
	solver.solve(in, out);
}

	return 0;
}