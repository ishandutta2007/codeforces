/**
 *    author:  tourist
 *    created: 28.11.2021 17:36:59       
**/
#include <bits/stdc++.h>

using namespace std;

const int inf = (int) 1e9;

const int CNT = 12;

vector<vector<int>> to;
vector<array<int, CNT>> init(3);

template <typename A, typename B>
string to_string(pair<A, B> p);

template <typename A, typename B, typename C>
string to_string(tuple<A, B, C> p);

template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p);

string to_string(const string& s) {
  return '"' + s + '"';
}

string to_string(const char* s) {
  return to_string((string) s);
}

string to_string(bool b) {
  return (b ? "true" : "false");
}

string to_string(vector<bool> v) {
  bool first = true;
  string res = "{";
  for (int i = 0; i < static_cast<int>(v.size()); i++) {
    if (!first) {
      res += ", ";
    }
    first = false;
    res += to_string(v[i]);
  }
  res += "}";
  return res;
}

template <size_t N>
string to_string(bitset<N> v) {
  string res = "";
  for (size_t i = 0; i < N; i++) {
    res += static_cast<char>('0' + v[i]);
  }
  return res;
}

template <typename A>
string to_string(A v) {
  bool first = true;
  string res = "{";
  for (const auto &x : v) {
    if (!first) {
      res += ", ";
    }
    first = false;
    res += to_string(x);
  }
  res += "}";
  return res;
}

template <typename A, typename B>
string to_string(pair<A, B> p) {
  return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}

template <typename A, typename B, typename C>
string to_string(tuple<A, B, C> p) {
  return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";
}

template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) {
  return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";
}

void debug_out() { cerr << endl; }

template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
  cerr << " " << to_string(H);
  debug_out(T...);
}

#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 42
#endif

class segtree {
 public:
  struct node {
    array<int, CNT> a;

    void apply(int l, int r, char c) {
      int id = (int) (c - 'a');
      a = init[id];
    }
  };

  node unite(const node &a, const node &b) const {
    node res;
    fill(res.a.begin(), res.a.end(), inf);
    for (int i = 0; i < CNT; i++) {
      for (int j = 0; j < CNT; j++) {
        if (to[i][j] != -1) {
          res.a[to[i][j]] = min(res.a[to[i][j]], a.a[i] + b.a[j]);
        }
      }
    }
    return res;
  }

  inline void push(int x, int l, int r) {
  }

  inline void pull(int x, int z) {
    tree[x] = unite(tree[x + 1], tree[z]);
  }

  int n;
  vector<node> tree;

  void build(int x, int l, int r) {
    if (l == r) {
      return;
    }
    int y = (l + r) >> 1;
    int z = x + ((y - l + 1) << 1);
    build(x + 1, l, y);
    build(z, y + 1, r);
    pull(x, z);
  }

  template <typename M>
  void build(int x, int l, int r, const vector<M> &v) {
    if (l == r) {
      tree[x].apply(l, r, v[l]);
      return;
    }
    int y = (l + r) >> 1;
    int z = x + ((y - l + 1) << 1);
    build(x + 1, l, y, v);
    build(z, y + 1, r, v);
    pull(x, z);
  }

  node get(int x, int l, int r, int ll, int rr) {
    if (ll <= l && r <= rr) {
      return tree[x];
    }
    int y = (l + r) >> 1;
    int z = x + ((y - l + 1) << 1);
    push(x, l, r);
    node res{};
    if (rr <= y) {
      res = get(x + 1, l, y, ll, rr);
    } else {
      if (ll > y) {
        res = get(z, y + 1, r, ll, rr);
      } else {
        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));
      }
    }
    pull(x, z);
    return res;
  }

  template <typename... M>
  void modify(int x, int l, int r, int ll, int rr, const M&... v) {
    if (ll <= l && r <= rr) {
      tree[x].apply(l, r, v...);
      return;
    }
    int y = (l + r) >> 1;
    int z = x + ((y - l + 1) << 1);
    push(x, l, r);
    if (ll <= y) {
      modify(x + 1, l, y, ll, rr, v...);
    }
    if (rr > y) {
      modify(z, y + 1, r, ll, rr, v...);
    }
    pull(x, z);
  }

  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {
    if (l == r) {
      return l;
    }
    push(x, l, r);
    int y = (l + r) >> 1;
    int z = x + ((y - l + 1) << 1);
    int res;
    if (f(tree[x + 1])) {
      res = find_first_knowingly(x + 1, l, y, f);
    } else {
      res = find_first_knowingly(z, y + 1, r, f);
    }
    pull(x, z);
    return res;
  }

  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {
    if (ll <= l && r <= rr) {
      if (!f(tree[x])) {
        return -1;
      }
      return find_first_knowingly(x, l, r, f);
    }
    push(x, l, r);
    int y = (l + r) >> 1;
    int z = x + ((y - l + 1) << 1);
    int res = -1;
    if (ll <= y) {
      res = find_first(x + 1, l, y, ll, rr, f);
    }
    if (rr > y && res == -1) {
      res = find_first(z, y + 1, r, ll, rr, f);
    }
    pull(x, z);
    return res;
  }

  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {
    if (l == r) {
      return l;
    }
    push(x, l, r);
    int y = (l + r) >> 1;
    int z = x + ((y - l + 1) << 1);
    int res;
    if (f(tree[z])) {
      res = find_last_knowingly(z, y + 1, r, f);
    } else {
      res = find_last_knowingly(x + 1, l, y, f);
    }
    pull(x, z);
    return res;
  }

  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {
    if (ll <= l && r <= rr) {
      if (!f(tree[x])) {
        return -1;
      }
      return find_last_knowingly(x, l, r, f);
    }
    push(x, l, r);
    int y = (l + r) >> 1;
    int z = x + ((y - l + 1) << 1);
    int res = -1;
    if (rr > y) {
      res = find_last(z, y + 1, r, ll, rr, f);
    }
    if (ll <= y && res == -1) {
      res = find_last(x + 1, l, y, ll, rr, f);
    }
    pull(x, z);
    return res;
  }

  segtree(int _n) : n(_n) {
    assert(n > 0);
    tree.resize(2 * n - 1);
    build(0, 0, n - 1);
  }

  template <typename M>
  segtree(const vector<M> &v) {
    n = v.size();
    assert(n > 0);
    tree.resize(2 * n - 1);
    build(0, 0, n - 1, v);
  }

  node get(int ll, int rr) {
    assert(0 <= ll && ll <= rr && rr <= n - 1);
    return get(0, 0, n - 1, ll, rr);
  }

  node get(int p) {
    assert(0 <= p && p <= n - 1);
    return get(0, 0, n - 1, p, p);
  }

  template <typename... M>
  void modify(int ll, int rr, const M&... v) {
    assert(0 <= ll && ll <= rr && rr <= n - 1);
    modify(0, 0, n - 1, ll, rr, v...);
  }

  // find_first and find_last call all FALSE elements
  // to the left (right) of the sought position exactly once

  int find_first(int ll, int rr, const function<bool(const node&)> &f) {
    assert(0 <= ll && ll <= rr && rr <= n - 1);
    return find_first(0, 0, n - 1, ll, rr, f);
  }

  int find_last(int ll, int rr, const function<bool(const node&)> &f) {
    assert(0 <= ll && ll <= rr && rr <= n - 1);
    return find_last(0, 0, n - 1, ll, rr, f);
  }
};

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  int n, q;
  cin >> n >> q;
  vector<string> fun = {"a", "b", "c", "ab", "bc", "abc"};
  auto Build = [&](string s) {
    vector<string> found;
    for (string z : fun) {
      int ptr = 0;
      for (int i = 0; i < (int) s.size(); i++) {
        if (ptr < (int) z.size() && z[ptr] == s[i]) {
          ++ptr;
        }
      }
      if (ptr == (int) z.size()) {
        found.push_back(z);
      }
    }
    return found;
  };
  map<vector<string>, string> mp;
  for (int len = 1; len <= 9; len++) {
    int p3 = 1;
    for (int i = 0; i < len; i++) {
      p3 *= 3;
    }
    for (int t = 0; t < p3; t++) {
      string s = "";
      int tmp = t;
      for (int i = 0; i < len; i++) {
        s += (char) (tmp % 3 + 'a');
        tmp /= 3;
      }
      vector<string> found = Build(s);
      if (find(found.begin(), found.end(), (string) "abc") != found.end()) {
        continue;
      }
      mp[found] = s;
    }
  }
  vector<pair<vector<string>, string>> all(mp.begin(), mp.end());
  int cnt = (int) all.size();
  assert(cnt == 12);
  auto GetId = [&](vector<string> found) {
    auto it = lower_bound(all.begin(), all.end(), make_pair(found, (string) ""));
    if (it != all.end() && it->first == found) {
      return (int) (it - all.begin());
    }
    return -1;
  };
  to.assign(cnt, vector<int>(cnt, -1));
  for (int i = 0; i < cnt; i++) {
    for (int j = 0; j < cnt; j++) {
      string s = all[i].second + all[j].second;
      auto found = Build(s);
      to[i][j] = GetId(found);
    }
  }
  vector<int> w(3);
  w[0] = GetId(Build((string) "a"));
  w[1] = GetId(Build((string) "b"));
  w[2] = GetId(Build((string) "c"));
  for (int it = 0; it < 3; it++) {
    fill(init[it].begin(), init[it].end(), inf);
    init[it][w[it]] = 0;
    init[it][w[(it + 1) % 3]] = 1;
    init[it][w[(it + 2) % 3]] = 1;
  }
  string s;
  cin >> s;
  vector<char> ss(n);
  for (int i = 0; i < n; i++) {
    ss[i] = s[i];
  }
  segtree st(ss);
  while (q--) {
    int pos;
    char c;
    cin >> pos >> c;
    --pos;
    st.modify(pos, pos, c);
    auto nd = st.get(0, n - 1);
    cout << *min_element(nd.a.begin(), nd.a.end()) << '\n';
  }
  return 0;
}