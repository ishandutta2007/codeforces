#include "bits/stdc++.h"
using namespace std;

typedef string::const_iterator State;
#define eps 1e-8L
#define MAX_MOD 1000000007LL
#define GYAKU 500000004LL
#define MOD 998244353LL
#define pb push_back
#define mp make_pair
typedef long long ll;
typedef long double ld;
#define REP(a, b) for (long long(a) = 0; (a) < (b); ++(a))
#define ALL(x) (x).begin(), (x).end()

#define int long long

void output(vector<vector<int>> ans)
{
  REP(i, ans.size())
  {
    REP(q, ans[i].size())
    {
      cout << ans[i][q];
    }
  }
  cout << endl;
}

bool isPlacementValid(pair<int, int> L, int R)
{
  return L.first <= R * L.second;
}

void solve()
{
  int n, m;
  cin >> n >> m;
  vector<int> teacher;
  REP(i, n)
  {
    int a;
    cin >> a;
    teacher.push_back(a);
  }
  sort(ALL(teacher));
  reverse(ALL(teacher));
  while (teacher.size() != m)
  {
    teacher.pop_back();
  }
  n = m;
  vector<vector<int>> students(m);
  vector<vector<int>> ans(m);
  vector<pair<int, int>> score_lists;
  REP(i, m)
  {
    int k;
    cin >> k;
    int sums = 0;
    REP(q, k)
    {
      int x;
      cin >> x;
      sums += x;
      students[i].push_back(x);
      ans[i].push_back(0);
    }
    score_lists.push_back({sums, k});
  }

  vector<pair<int, int>> sorted_lists = score_lists;
  sort(ALL(sorted_lists), [](auto l, auto r)
       { return l.first * r.second > r.first * l.second; });
  int invalid_course = -1;
  for (int i = 0; i < n; ++i)
  {
    if (!isPlacementValid(sorted_lists[i], teacher[i]))
    {
      invalid_course = i;
      break;
    }
  }
  if (invalid_course != -1)
  {
    // invalid found.
    int require_move = invalid_course;
    for (int q = invalid_course + 1; q < n; ++q)
    {
      if (!isPlacementValid(sorted_lists[q], teacher[q]))
      {
        require_move = q;
        if (!isPlacementValid(sorted_lists[q], teacher[q - 1]))
        {
          output(ans);
          return;
        }
      }
    }
    bool ok = false;
    if (invalid_course != 0 and isPlacementValid(sorted_lists[invalid_course], teacher[invalid_course - 1]))
      ok = true;
    REP(i, n)
    {
      auto x = lower_bound(ALL(sorted_lists), score_lists[i],
                           [](auto l, auto r)
                           {
                             return l.first * r.second > r.first * l.second;
                           }) -
               sorted_lists.begin();
      if (x == invalid_course or (x < invalid_course and ok))
      {
        // this is it.
        int k = students[i].size();
        REP(q, k)
        {
          pair<int, int> target = score_lists[i];
          target.first -= students[i][q];
          target.second--;
          auto x = lower_bound(ALL(sorted_lists), target,
                               [](auto l, auto r)
                               {
                                 return l.first * r.second >= r.first * l.second;
                               });
          int dist = x - sorted_lists.begin();
          dist--;
          if (dist >= require_move)
          {
            if (isPlacementValid(target, teacher[dist]))
            {
              ans[i][q] = 1;
            }
          }
        }
      }
    }
    output(ans);
    return;
  }

  vector<int> required_move(n, 0);
  REP(i, n)
  {
    if (i != 0)
    {
      required_move[i] = required_move[i - 1];
      if (!isPlacementValid(sorted_lists[i - 1], teacher[i]))
      {
        required_move[i] = i;
      }
    }
  }

  REP(i, n)
  {
    auto x = lower_bound(ALL(sorted_lists), score_lists[i],
                         [](auto l, auto r)
                         {
                           return l.first * r.second > r.first * l.second;
                         }) -
             sorted_lists.begin();
    int req_move = required_move[x];
    int k = students[i].size();
    for (int q = 0; q < k; ++q)
    {
      pair<int, int> target = score_lists[i];
      target.first -= students[i][q];
      target.second--;
      auto x = lower_bound(ALL(sorted_lists), target,
                           [](auto l, auto r)
                           {
                             return l.first * r.second >= r.first * l.second;
                           });
      int dist = x - sorted_lists.begin();
      if (dist >= req_move)
      {
        if (dist > req_move or isPlacementValid(target, teacher[dist]))
        {
          ans[i][q] = 1;
        }
      }
    }
  }
  output(ans);
}
#undef int

// generated by oj-template v4.7.2
// (https://github.com/online-judge-tools/template-generator)
int main()
{
  // Fasterize input/output script
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << fixed << setprecision(100);
  // scanf/printf user should delete this fasterize input/output script

  int t = 1;
  cin >> t; // comment out if solving multi testcase
  for (int testCase = 1; testCase <= t; ++testCase)
  {
    solve();
  }
  return 0;
}