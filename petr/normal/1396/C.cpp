/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long int64;
typedef vector<int> vi;
typedef pair<int, int> ii;

class TaskC {
 public:
  void solveOne(istream &in, ostream &out) {
    int n;
    in >> n;
    int64 r1, r2, r3, d;
    in >> r1 >> r2 >> r3 >> d;
    vector<int64> a(n);
    for (auto& x : a) in >> x;
    vector<int64> best(n + 1);
    for (int i = 0; i < n; ++i) {
      best[i + 1] = best[i] + r1 * a[i] + r3;
      if (i >= 1) {
        best[i + 1] = min(best[i + 1], best[i - 1] + min(r1 * a[i] + r3, min(r2, r1 * (a[i] + 1)) + r1) + min(r1 * a[i - 1] + r3, min(r2, r1 * (a[i - 1] + 1)) + r1) + 2 * d);
      }
    }
    int64 res = best[n];
    int64 suffix = min(r1 * a[n - 1] + r3, min(r2, r1 * (a[n - 1] + 1)) + r1 + 2 * d);
    for (int i = n - 1; i >= 0; --i) {
      res = min(res, best[i] + suffix);
      if (i > 0) {
        suffix += d + min(r1 * a[i - 1] + r3, min(r2, r1 * (a[i - 1] + 1)) + r1);
      }
    }
    res += d * (n - 1);
    out << res << "\n";
  }

  void solve(std::istream &in, std::ostream &out) {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne(in, out);
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  TaskC solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}