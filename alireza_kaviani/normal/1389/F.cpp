/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-07-29 19:05:01
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<int, int> pii;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())
#define lc                          id << 1
#define rc                          lc | 1

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 5e5 + 10;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

int n , seg[2][MAXN << 2] , lz[2][MAXN << 2] , L[MAXN] , R[MAXN] , col[MAXN];
vector<int> compress;
vector<pii> vec[MAXN];

void shift(int ind , int id){
    lz[ind][lc] += lz[ind][id];
    lz[ind][rc] += lz[ind][id];
    seg[ind][lc] += lz[ind][id];
    seg[ind][rc] += lz[ind][id];
    lz[ind][id] = 0;
}

void update(int ind , int ql , int qr , int x , int id = 1 , int l = 0 , int r = MAXN){
    if(qr <= l || r <= ql)  return;
    if(ql <= l && r <= qr){
        lz[ind][id] += x;
        seg[ind][id] += x;
        return;
    }
    shift(ind , id);
    int mid = l + r >> 1;
    update(ind , ql , qr , x , lc , l , mid);
    update(ind , ql , qr , x , rc , mid , r);
    seg[ind][id] = max(seg[ind][lc] , seg[ind][rc]);
}

int main() {
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    cin >> n;
    for(int i = 0 ; i < n ; i++){
        cin >> L[i] >> R[i] >> col[i]; col[i]--;
        compress.push_back(L[i]);
        compress.push_back(R[i]);
    }
    sort(all(compress));
    compress.resize(unique(all(compress)) - compress.begin());
    for(int i = 0 ; i < n ; i++){
        L[i] = lower_bound(all(compress) , L[i]) - compress.begin() + 1;
        R[i] = lower_bound(all(compress) , R[i]) - compress.begin() + 1;
        vec[R[i]].push_back({L[i] , col[i]});
    }

    for(int i = 1 ; i < MAXN ; i++){
        for(pii j : vec[i]){
            int L = j.X , col = j.Y;
            update(col , 0 , L , 1);
        }
        int mx = max(seg[0][1] , seg[1][1]);
        update(0 , i , i + 1 , mx);
        update(1 , i , i + 1 , mx);
    }
    cout << max(seg[0][1] , seg[1][1]);

    return 0;
}
/*

*/