#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;

const int nax = 1e6 + 10;
char s[nax];
int dp[nax];
int nxt[nax];
int f[nax];

void add (int &a, int b) {
    if ((a += b) >= mod) a -= mod;
}

int main () {
    scanf("%s", s + 1);
    int n = strlen(s + 1);

    /**
        greedy: if want to add more zero->find next position which have sufficient block
        if want to add one, just find next one.
        The strings generated by this method are always unique.
        at each block
        the possibility is has 1, ...., ct[i] numbers of zeroes
        enumerate over them.
    */

    if (*max_element(s + 1, s + 1 + n) == '0') {
        return !printf("%d\n", n);
    }

    int l = 1;
    int first_n = n;
    while (s[l] == '0') ++ l;
    while (s[n] == '0') -- n;

    for (int i = l ; i <= n ; ++ i) {
        if (s[i] == '1') f[i] = 0;
        else f[i] = f[i - 1] + 1;
    }

    for (int i = n ; i >= l; -- i) {
        if (s[i] == '1') add(dp[i], 1);
        add(dp[i], dp[nxt[f[i] + 1]]);
        add(dp[i], dp[nxt[0]]);
        nxt[f[i]] = i;
    }

    printf("%lld\n", 1LL * dp[l] * l  % mod * (first_n - n + 1) % mod);
}
/*
    Good Luck
        -Lucina
*/