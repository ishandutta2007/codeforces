/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author majk
 */

#ifndef MAJK_LIB
#define MAJK_LIB

#include <vector>
#include <stack>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <iomanip>
#include <set>
#include <functional>
#include <fstream>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <string>
#include <sstream>
#include <queue>
#include <array>
#include <bitset>
using namespace std;

#define x first
#define y second
typedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;

template <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}
template<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}
template <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}
template<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<" \n"[i == t.size()-1];}return o;}
template<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;
template<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;
template <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }
ui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }

namespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }
template<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}
template<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}
template<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}
template<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}
template<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }


template<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};
template<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};
template<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};
template<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};


#endif
// #include "../l/mod.h"

class CGame {
public:
    void solve(istream& cin, ostream& cout) {
        int N, M, K; cin >> N >> M >> K;
        map<int, vector<pii>> Vert, Hor;
        for (int i = 0; i < K; ++i) {
            int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
            if (x1 == x2) {
                if (y1 > y2) swap(y1, y2);
                Hor[x1].emplace_back(y1,y2);
            } else {
                if (x1 > x2) swap(x1, x2);
                Vert[y1].emplace_back(x1,x2);
            }
        }

        int g = 0;
        vector<pair<pii, vector<pii>>> C;
        int bestLen = 0;
        pii from, to;
        if (N % 2 == 0) g ^= M;
        if (M % 2 == 0) g ^= N;
        for (int i = 1; i < N; ++i) if (Hor.find(i) == Hor.end()) {
            C.push_back({{-M,i},{{0,M}}});
            break;
        }
        for (int i = 1; i < M; ++i) if (Vert.find(i) == Vert.end()) {
            C.push_back({{N,i},{{0,N}}});
            break;
        }

        for (auto&h : Hor) {
            g ^= M;
            vector<pii> Ev;
            for (pii hh: h.y) { Ev.emplace_back(hh.x, 1); Ev.emplace_back(hh.y, -1); }
            Ev.emplace_back(M, 0);
            sort(Ev.begin(),Ev.end());
            int cnt = 0, last = 0, tot = 0;
            vector<pii> Z;
            for (pii ev: Ev) {
                if (!cnt && ev.x != last) {
                    Z.emplace_back(last,ev.x);
                    tot += ev.x - last;
                }

                cnt += ev.y;
                last = ev.x;
            }
            if (!Z.empty()) C.push_back({{-tot, h.x}, Z});

            g ^= tot;
        }

        for (auto&v : Vert) {
            g ^= N;
            vector<pii> Ev;
            for (pii vv: v.y) { Ev.emplace_back(vv.x, 1); Ev.emplace_back(vv.y, -1); }
            Ev.emplace_back(N, 0);
            sort(Ev.begin(),Ev.end());
            int cnt = 0, last = 0, tot = 0;
            vector<pii> Z;
            for (pii ev: Ev) {
                if (!cnt && ev.x != last) {
                    Z.emplace_back(last,ev.x);
                    tot += ev.x - last;
                }

                cnt += ev.y;
                last = ev.x;
            }

            if (!Z.empty()) C.push_back({{tot, v.x}, Z});
            g ^= tot;
        }

        if (g) {
            cout << "FIRST\n";
            for (auto&c : C) {
                int l = abs(c.x.x);
                if ((l^g) <= l) {
                    l = l - (l^g);
                    for (pii cc: c.y) {
                        if (l <= cc.y - cc.x) {
                            if (c.x.x < 0) {
                                cout << c.x.y << " 0 " << c.x.y << ' ' << cc.x + l << endl;
                            } else {
                                cout << "0 " << c.x.y << ' ' << cc.x + l << ' ' << c.x.y << endl;
                            }
                            break;
                        }
                        l -= cc.y - cc.x;
                    }
                    break;
                }
            }
        } else {
            cout << "SECOND\n";
        }

    }
};


int main() {
	ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
	CGame solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
    return 0;
}