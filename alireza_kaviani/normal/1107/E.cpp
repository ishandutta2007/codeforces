/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author alireza_kaviani
 */

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template<class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 100 + 10;
const ll LOG = 22;
const ll INF = 1e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll n, A[MAXN], v[MAXN], mx[MAXN][MAXN], dp[2][MAXN][MAXN][MAXN];
string s;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    for (ll i = 0; i < 2; i++) {
        for (ll j = 0; j < MAXN; j++) {
            for (ll k = 0; k < MAXN; k++) {
                for (ll l = 0; l < MAXN; l++) {
                    dp[i][j][k][l] = -INF;
                }
                mx[j][k] = -INF;
            }
        }
    }

    cin >> n >> s;
    s = "." + s;
    for (ll i = 1; i <= n; i++) cin >> A[i];
    for (ll i = 1; i <= n; i++) {
        v[i] = s[i] - 48;
        dp[v[i]][i][i][1] = 0;
        dp[0][i][i][0] = dp[1][i][i][0] = A[1];
        mx[i][i] = A[1];
    }

    for (ll l = n; l > 0; l--) {
        for (ll r = l + 1; r <= n; r++) {
            for (ll i = 1; i < MAXN; i++) {
                dp[v[l]][l][r][i] = dp[v[l]][l + 1][r][i - 1];
                for (ll j = l; j < r; j++) {
                    dp[0][l][r][i] = max(dp[0][l][r][i], dp[0][l][j][i] + mx[j + 1][r]);
                    dp[0][l][r][i] = max(dp[0][l][r][i], mx[l][j] + dp[0][j + 1][r][i]);
                    dp[1][l][r][i] = max(dp[1][l][r][i], dp[1][l][j][i] + mx[j + 1][r]);
                    dp[1][l][r][i] = max(dp[1][l][r][i], mx[l][j] + dp[1][j + 1][r][i]);
                }
                if (i != 1 && v[l] == 0 && v[r] == 0) dp[0][l][r][i] = max(dp[0][l][r][i], dp[0][l + 1][r - 1][i - 2]);
                if (i != 1 && v[l] == 1 && v[r] == 1) dp[1][l][r][i] = max(dp[1][l][r][i], dp[1][l + 1][r - 1][i - 2]);
                mx[l][r] = max(mx[l][r], dp[0][l][r][i] + A[i]);
                mx[l][r] = max(mx[l][r], dp[1][l][r][i] + A[i]);
            }
            dp[0][l][r][0] = dp[1][l][r][0] = mx[l][r];
        }
    }
    cout << mx[1][n] << endl;

    return 0;
}
/*

*/