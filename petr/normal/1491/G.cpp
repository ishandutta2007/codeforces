/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

class GSwitchAndFlip {
 public:
  void solveOne() {
    int n;
    cin >> n;
    vector<int> c(n);
    for (int i = 0; i < n; ++i) {
      cin >> c[i];
      --c[i];
    }
    vector<pair<int, int>> res = innerSolve(n, c);
    cout << res.size() << "\n";
    for (auto p : res) {
      cout << (p.first + 1) << " " << (p.second + 1) << "\n";
    }
  }

  vector<pair<int, int>> innerSolve(int n, vector<int> c) const {
    vector<int> invc(n);
    for (int i = 0; i < n; ++i) {
      invc[c[i]] = i;
    }
    vector<bool> inv(n);
    vector<bool> mark(n);
    vector<int> cycleLeaders;
    for (int i = 0; i < n; ++i) if (c[i] != i && !mark[i]) {
      int j = i;
      do {
        mark[j] = true;
        j = c[j];
      } while (j != i);
      cycleLeaders.push_back(i);
    }
    set<int> available;
    auto untake = [&](int a) {
      if (c[a] != a && inv[c[a]] && (c[c[a]] == a && inv[a]) || (c[c[a]] != a && !inv[c[c[a]]])) {
        available.erase(a);
      }
    };
    auto take = [&](int a) {
      if (c[a] != a && inv[c[a]] && (c[c[a]] == a && inv[a]) || (c[c[a]] != a && !inv[c[c[a]]])) {
        available.insert(a);
      }
    };
    vector<pair<int, int>> res;
    auto makeSwap = [&](int a, int b) {
      assert(a != b);
      res.emplace_back(a, b);
      untake(a);
      untake(b);
      int ia = invc[a];
      int ib = invc[b];
      if (ia != a && ia != b) {
        untake(ia);
      }
      if (ib != a && ib != b) {
        untake(ib);
      }
      swap(c[a], c[b]);
      invc[c[a]] = a;
      invc[c[b]] = b;
      inv[c[a]] = !inv[c[a]];
      inv[c[b]] = !inv[c[b]];
      take(a);
      take(b);
      if (ia != a && ia != b) {
        take(ia);
      }
      if (ib != a && ib != b) {
        take(ib);
      }
    };
    for (int step = 0; step < cycleLeaders.size(); step += 2) {
      int a = cycleLeaders[step];
      if (step + 1 < cycleLeaders.size()) {
        int b = cycleLeaders[step + 1];
        makeSwap(a, b);
        assert(!available.empty());
        while (!available.empty()) {
          int x = *available.begin();
          makeSwap(x, c[x]);
        }
      } else {
        if (a == c[a]) {
          // do nothing
        } else {
          bool found = false;
          for (int b = 0; b < n; ++b) if (c[b] == b) {
            makeSwap(a, b);
            found = true;
            break;
          }
          if (!found) {
            int b = c[a];
            int d = c[b];
            assert(d != a);
            makeSwap(a, b);
            makeSwap(b, d);
          }
          if (available.empty()) {
            assert(false);
          }
          while (!available.empty()) {
            int x = *available.begin();
            makeSwap(x, c[x]);
          }
        }
      }
    }
    for (int i = 0; i < n; ++i) {
      assert(c[i] == i);
      assert(!inv[i]);
    }
    return res;
  }

  void solve() {
    /*while (true) {
      int n = rand() % 3 + 7;
      vector<int> c(n);
      for (int i = 0; i < n; ++i) {
        c[i] = i;
        int j = rand() % (i + 1);
        swap(c[i], c[j]);
      }
      innerSolve(n, c);
    }*/
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne();
    }
  }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    GSwitchAndFlip solver;


    solver.solve();
    return 0;
}