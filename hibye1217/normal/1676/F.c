#define Problem int
#define A arr

Problem A

#define Title [
#define is 200020
#define Lucky ]
#define with ,
#define question tmp
#define mark [
#define at 200020
#define the ]
#define end ;

Title is Lucky with question mark at the end

#define Time void
#define Limit mrg
#define per (
#define Test int
#define is st
#define one ,
#define second int

Time Limit per Test is one second

#define Memory ed
#define Limit )
#define per {
#define Test if
#define is (
#define two st
#define hundred ==
#define fifty ed
#define six )
#define megabytes {

Memory Limit per Test is two hundred fifty six megabytes

#define Input return
#define is ;
#define provided }
#define via int
#define standard mid
#define input =

Input is provided via standard input

#define and st
#define Output +
#define is ed
#define provided >>
#define via 1
#define standard ;
#define output mrg

and Output is provided via standard output

#define Problem (
#define B st

Problem B

#define Title ,
#define is mid
#define Equal )
#define Candies ;

Title is Equal Candies

#define Time mrg
#define Limit (
#define per mid
#define Test +
#define is 1
#define one ,
#define second ed

Time Limit per Test is one second

#define Memory )
#define Limit ;
#define per int
#define Test p1
#define is =
#define two st
#define hundred ,
#define fifty p2
#define six =
#define megabytes mid

Memory Limit per Test is two hundred fifty six megabytes

#define Input +
#define is 1
#define provided ;
#define via int
#define standard pos
#define input =

Input is provided via standard input

#define and st
#define Output ;
#define is while
#define provided (
#define via p1
#define standard <=
#define output mid

and Output is provided via standard output

#define Problem ||
#define C p2

Problem C

#define Title <=
#define is ed
#define Most )
#define Similar {
#define Words if

Title is Most Similar Words

#define Time (
#define Limit p1
#define per >
#define Test mid
#define is )
#define one {
#define second tmp

Time Limit per Test is one second

#define Memory [
#define Limit pos
#define per ]
#define Test =
#define is arr
#define two [
#define hundred p2
#define fifty ]
#define six ;
#define megabytes pos

Memory Limit per Test is two hundred fifty six megabytes

#define Input +=
#define is 1
#define provided ;
#define via p2
#define standard +=
#define input 1

Input is provided via standard input

#define and ;
#define Output }
#define is else
#define provided if
#define via (
#define standard p2
#define output >

and Output is provided via standard output

#define I ed
#define was )
#define supposed {
#define to tmp[pos]
#define do =
#define all arr[p1]
#define things ;
#define until pos += 1;
#define problem p1 += 1;
#define H2 }

I was supposed to do all things until problem H2

#define but else
#define Im {
#define too if
#define lazy (
#define to arr[p1]
#define do <=
#define all arr[p2]
#define these )
#define stuff {

but Im too lazy to do all these stuff

#define so tmp[pos] = arr[p1];
#define Im pos += 1;
#define just p1 += 1;
#define going }
#define to else
#define do {
#define some tmp[pos] = arr[p2];
#define useless pos += 1;
#define stuff p2 += 1;
#define instead }

so Im just going to do some useless stuff instead

#define speaking }}
#define of for
#define me (int i =
#define being st; i
#define lazy <= ed;

speaking of me being lazy

#define did i++){
#define you arr[i
#define know ] = tmp
#define about [i]; }}
#define the int main(){
#define algorithm int t; scanf
#define called ("%d", &t)
#define Segment ; while (t--
#define Tree ){
#define with int n,
#define Lazy k; scanf(
#define Propagation "%d %d"

did you know about the algorithm called Segment Tree with Lazy Propagation

#define Oh , &n
#define yeah , &k
#define I ); for (int i
#define forgot = 1; i <= n; i++)

Oh yeah I forgot

#define I {
#define cant scanf("%d"
#define use , &arr[i]
#define any );}
#define punctuation mrg(1, n);
#define using int st = 1;
#define only int ans = 0;
#define define int l = 0, r = 0;
#define macros while (st <= n)

I cant use any punctuation using only define macros

#define so {
#define sadly int
#define I ed = st+1
#define cannot , cnt = 1
#define show ; while
#define my (ed <=
#define expressions n){
#define about if (arr[ed-1]
#define this == arr[ed]
#define text ){ cnt +=

so sadly I cannot show my expressions about this text

#define Also 1;
#define Sorry ed += 1;
#define For } else {
#define My if
#define Bad (cnt < k)
#define English { int

Also Sorry For My Bad English

#define Oh res = arr
#define wait [ed-1]-1 -
#define let arr[st] + 1;
#define me if
#define call (res > ans)
#define this { ans = res; l = arr[st]; r = arr[ed-1]-1; }
#define one break;
#define more }
#define loudly else if

Oh wait let me call this one more loudly

#define SORRY (arr[ed-1] + 1
#define FOR != arr[ed]
#define MY ){
#define BAD int res
#define ENGLISH = arr[ed-1]

SORRY FOR MY BAD ENGLISH

#define okay - arr[st] + 1;
#define I if (res > ans){
#define think ans =
#define its res;
#define better l = arr[st];
#define now r = arr[ed-1]; }

okay I think its better now

#define although break; }
#define I ed += 1; cnt = 1; }
#define already } if (ed > n) {
#define got if (cnt >= k){
#define like int res = arr[ed-1] - arr[st] + 1;
#define hundred if (res > ans){
#define compile ans = res; l = arr[st];
#define warnings r = arr[ed-1]; }

although I already got like hundred compile warnings

#define oh } else {
#define its int res
#define two = arr[ed-1]-1 - arr[st] + 1;
#define hundred if (res > ans)
#define already { ans = res; l = arr[st];

oh its two hundred already

#define its r = arr[ed-1]-1; }}}
#define okay st = ed;

its okay

#define it }
#define will if
#define be (
#define accepted ans
#define anyway ==

it will be accepted anyway

#define also 0
#define my )
#define friend {
#define wanted printf
#define to (
#define end "-1\n"
#define the )
#define poem ;
#define with }
#define blobaww else
#define so {
#define lets printf
#define do (
#define that "%d %d\n"

also my friend wanted to end the poem with blobaww so lets do that

#define BLOBAWW , l, r); }}}

BLOBAWW