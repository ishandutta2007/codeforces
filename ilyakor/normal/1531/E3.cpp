/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

struct Node {
    int l, r;
    int sl, sr;

    Node() {}

    Node(int l, int r, int sl, int sr) : l(l), r(r), sl(sl), sr(sr) {}
};

class TaskE {
public:
    string s;
    vector<Node> a;
    int cnt;
    vi res;
    vi tmp;

    void solve(std::istream& in, std::ostream& out) {
	    in >> s;
//	    int n = 1;
//	    while (true) {
//            a = vector<Node>(2 * n + 1);
//            cnt = 0;
//	        if (parse(n, 0) == sz(s)) {
//	            break;
//	        }
//	        ++n;
//	    }
        int L = 1, R = 110 * 1000;
        while (R - L > 1) {
            int n = (L + R) / 2;
            a = vector<Node>(2 * n + 1);
            cnt = 0;
            if (parse(n, 0) > sz(s))
                R = n;
            else
                L = n;
        }
        int n = L;
        a = vector<Node>(2 * n + 1);
        cnt = 0;
        assert(parse(n, 0) == sz(s));
	    res = vi(n);
	    for (int i = 0; i < n; ++i) {
	        res[i] = i + 1;
	    }
	    tmp = vi(n);
	    restore(cnt - 1, 0, n);
	    out << n << "\n";
	    for (int x : res)
	        out << x << " ";
	    out << "\n";
	}

    void restore(int root, int l, int r) {
        if (r - l <= 1) return;
        int k = 0;
        int m = (l + r) / 2;
        int i = l, j = m;
        while (i < m && j < r) {
            if (s[a[root].sl + k] == '0') {
                tmp[i++] = res[l + k];
            } else {
                tmp[j++] = res[l + k];
            }
            ++k;
        }
        while (i < m) {
            tmp[i++] = res[l + k];
            ++k;
        }
        while (j < r) {
            tmp[j++] = res[l + k];
            ++k;
        }
        for (int i = l; i < r; ++i)
            res[i] = tmp[i];
        restore(a[root].r, m, r);
        restore(a[root].l, l, m);
    }

	int parse(int n, int l) {
	    if (n == 1) {
	        a[cnt].l = -1;
	        a[cnt].r = -1;
	        ++cnt;
	        return l;
	    }
	    int m = n / 2;
	    l = parse(m, l);
	    int tl = cnt - 1;
	    if (l > sz(s)) return l;
	    l = parse(n - m, l);
	    int tr = cnt - 1;
        if (l > sz(s)) return l;
	    int num_l = m, num_r = n - m;
	    int sl = l;
	    while (num_l > 0 && num_r > 0) {
	        if (l >= sz(s)) return sz(s) + 1;
	        if (s[l] == '0') --num_l;
	        else --num_r;
	        ++l;
	    }
	    a[cnt].l = tl;
        a[cnt].r = tr;
        a[cnt].sl = sl;
        a[cnt].sr = l - 1;
        ++cnt;
	    return l;
	}
};


int main() {
	TaskE solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}