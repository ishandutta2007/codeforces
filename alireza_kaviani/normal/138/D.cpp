/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-03-20 11:13:04
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 40 + 10;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll n , m , tot , mark[20 * 20 + 10] , grundy[MAXN][MAXN][MAXN][MAXN];
string s[MAXN];

int main() {
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    cin >> n >> m;
    for(ll i = 1 ; i <= n ; i++)    cin >> s[i] , s[i] = "." + s[i];

    for(ll color = 0 ; color < 2 ; color++){
        memset(grundy , 0 , sizeof(grundy));
        for(ll lx = (n + m) / 2 ; lx >= 0 ; lx--){
            for(ll rx = lx ; rx <= (n + m) / 2 ; rx++){
                for(ll ly = (n + m) / 2 ; ly >= 0 ; ly--){
                    for(ll ry = ly ; ry <= (n + m) / 2 ; ry++){
                        memset(mark , 0 , sizeof(mark));
                        for(ll i = 1 ; i <= n ; i++){
                            for(ll j = 1 ; j <= m ; j++){
                                ll x = (i + j) / 2 , y = (i + m + 1 - j) / 2;
                                if((i + j) % 2 == color && lx <= x && x <= rx && ly <= y && y <= ry){
                                    if(s[i][j] == 'L')  mark[grundy[lx][x - 1][ly][ry] ^ grundy[x + 1][rx][ly][ry]] = 1;
                                    if(s[i][j] == 'R')  mark[grundy[lx][rx][ly][y - 1] ^ grundy[lx][rx][y + 1][ry]] = 1;
                                    if(s[i][j] == 'X')  mark[grundy[lx][x - 1][ly][y - 1] ^ grundy[x + 1][rx][ly][y - 1] ^ grundy[lx][x - 1][y + 1][ry] ^ grundy[x + 1][rx][y + 1][ry]] = 1;
                                }
                            }
                        }
                        ll res = 0;
                        while(mark[res])    res++;
                        grundy[lx][rx][ly][ry] = res;
                    }
                }
            }
        }
        tot ^= grundy[0][(n + m) / 2][0][(n + m) / 2];
    }
    cout << (tot == 0 ? "LOSE" : "WIN");

    return 0;
}
/*

*/