/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Petr
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

typedef long long ll;

class TaskB {
public:
    void findDepth(int at, vector<ll>& depth, const vector<int>& p, const vector<int>& w) {
        if (depth[at] >= 0) return;
        findDepth(p[at], depth, p, w);
        depth[at] = depth[p[at]] + w[at];
    }

    void dfs(int at, const vector<int>& firstChild, const vector<int>& nextSibling, vector<int>& l, vector<int>& r, int& nxt) {
        l[at] = nxt++;
        int cur = firstChild[at];
        while (cur >= 0) {
            dfs(cur, firstChild, nextSibling, l, r, nxt);
            cur = nextSibling[cur];
        }
        r[at] = nxt;
    }

    void fupd(vector<int>& a, int at, int by) {
        while (at < a.size()) {
            a[at] += by;
            at |= (at + 1);
        }
    }

    int fget(const vector<int>& a, int upto) {
        int res = 0;
        while (upto >= 0) {
            res += a[upto];
            upto = (upto & (upto + 1)) - 1;
        }
        return res;
    }

    void solve(istream& in, ostream& out) {
        int n;
        in >> n;
        vector<int> a(n);
        for (int& aa : a) {
            in >> aa;
        }
        vector<int> p(n);
        vector<int> w(n);
        vector<int> firstChild(n, -1);
        vector<int> nextSibling(n, -1);
        p[0] = -1;
        for (int i = 1; i < n; ++i) {
            in >> p[i] >> w[i];
            --p[i];
            nextSibling[i] = firstChild[p[i]];
            firstChild[p[i]] = i;
        }
        vector<ll> depth(n, -1);
        depth[0] = 0;
        for (int i = 1; i < n; ++i) {
            findDepth(i, depth, p, w);
        }
        vector<pair<ll, int>> events(2 * n);
        for (int i = 0; i < n; ++i) {
            events[i] = {depth[i], i + 1};
            events[i + n] = {depth[i] - a[i], -(i + 1)};
        }
        sort(events.begin(), events.end());
        vector<int> l(n, -1);
        vector<int> r(n, -1);
        int nxt = 0;
        dfs(0, firstChild, nextSibling, l, r, nxt);
        assert(nxt == n);
        vector<int> fenwick(n, 0);
        vector<int> answer(n, -1);
        for (const auto& e : events) {
            if (e.second < 0) {
                fupd(fenwick, l[-e.second - 1], 1);
            } else {
                answer[e.second - 1] = fget(fenwick, r[e.second - 1] - 1) - fget(fenwick, l[e.second - 1]);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (i > 0) out << " ";
            out << answer[i];
        }
        out << "\n";
	}
};

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	TaskB solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}