/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author marX
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>
#include <vector>

using namespace std;

const double eps = 1e-9, oo = numeric_limits<double>::infinity();

typedef vector<double> vec;
typedef vector<vec> mat;

double simplexMethodPD(mat &A, vec &b, vec &c, vec &x) {
    int n = c.size(), m = b.size();
    mat T(m + 1, vec(n + m + 1));
    vector<int> base(n + m), row(m);
    for (int j = 0; j < m; ++j) {
        for (int i = 0; i < n; ++i)
            T[j][i] = A[j][i];
        T[j][n + j] = 1;
        base[row[j] = n + j] = 1;
        T[j][n + m] = b[j];
    }
    for (int i = 0; i < n; ++i)
        T[m][i] = c[i];

    while (1) {
        int p = 0, q = 0;
        for (int i = 0; i < n + m; ++i)
            if (T[m][i] <= T[m][p])
                p = i;
        for (int j = 0; j < m; ++j)
            if (T[j][n + m] <= T[q][n + m])
                q = j;
        double t = min(T[m][p], T[q][n + m]);

        if (t >= -eps) {
            x = vec(n);
            for (int i = 0; i < m; ++i)
                if (row[i] < n) x[row[i]] = T[i][n + m];
            // x is the solution
            return -T[m][n + m]; // optimal
        }

        if (t < T[q][n + m]) {
            // tight on c -> primal update
            for (int j = 0; j < m; ++j)
                if (T[j][p] >= eps)
                    if (T[j][p] * (T[q][n + m] - t)
                        >= T[q][p] * (T[j][n + m] - t))
                        q = j;
            if (T[q][p] <= eps)
                return oo; // primal infeasible
        } else {
            // tight on b -> dual update
            for (int i = 0; i < n + m + 1; ++i)
                T[q][i] = -T[q][i];
            for (int i = 0; i < n + m; ++i)
                if (T[q][i] >= eps)
                    if (T[q][i] * (T[m][p] - t)
                        >= T[q][p] * (T[m][i] - t))
                        p = i;
            if (T[q][p] <= eps)
                return -oo; // dual infeasible
        }
        for (int i = 0; i < m + n + 1; ++i)
            if (i != p)
                T[q][i] /= T[q][p];
        T[q][p] = 1; // pivot(q, p)
        base[p] = 1;
        base[row[q]] = 0;
        row[q] = p;
        for (int j = 0; j < m + 1; ++j)
            if (j != q) {
                double alpha = T[j][p];
                for (int i = 0; i < n + m + 1; ++i)
                    T[j][i] -= T[q][i] * alpha;
            }
    }
    return oo;
}

/*
	Solve the linear programming problem (in integers)
	min: C * x
	sa:  A * x <= B

	Answer is stored in best
*/
bool SolveInteger(mat &A, vec &B, vec &C, long long &best, vector<long long> &solution) {
    vec x;
    double v = simplexMethodPD(A, B, C, x);

    // Infeasible
    if (v == oo || v == -oo) return false;

    if ((long long) ceil(v) >= best) return true;

    for (int i = 0; i < (int) x.size(); ++i) {
        double a = floor(x[i]);
        double b = ceil(x[i]);

        if (min(x[i] - a, b - x[i]) >= eps) {
            mat NA = A;
            vec NB = B;
            int vars = C.size();
            vec nv(vars);
            nv[i] = -1;

            NA.push_back(nv);
            NB.push_back(-b);

            bool ok = SolveInteger(NA, NB, C, best, solution);

            NA.pop_back();
            NB.pop_back();

            nv[i] = 1;
            NA.push_back(nv);
            NB.push_back(a);
            ok |= SolveInteger(NA, NB, C, best, solution);

            return ok;
        }
    }

    // Solution is stored in x.
    // You may safely assume that it will be integer.

    auto cur_value = (long long) round(v);

    if (cur_value < best) {
        best = cur_value;
        solution = vector<long long>(x.begin(), x.end());
    }

    return true;
}

class SimplexSolutionInteger {
public:
    long long value;
    vector<long long> solution;

    SimplexSolutionInteger(long long value, vector<long long> solution) : value(value), solution(move(solution)) {}

    bool has_solution() {
        return !solution.empty();
    }
};

class SimplexSolution {
public:
    double value;
    vector<double> solution;

    SimplexSolution(double value, vector<double> solution) : value(value), solution(move(solution)) {}

    bool has_solution() {
        return !solution.empty();
    }
};

class Equation {
public:
    vector<double> *lhs;
    double *__rhs;

    Equation(vector<double> *lhs, double *rhs) : lhs(lhs), __rhs(rhs) {}

    double &operator[](int u) {
        return (*lhs)[u];
    }

    double &rhs() {
        return *__rhs;
    }
};

class Simplex {
    vector<vector<double>> A;
    vector<double> b;
    vector<double> c;

public:
    Simplex(int variables) {
        c = vector<double>(variables);
    }

    // Return the number of variables of the system
    int variables() {
        return c.size();
    }

    void add_equation() {
        A.push_back(vector<double>(variables()));
        b.push_back(0);
    }

    void add_equation(vector<double> eq, double limit) {
        A.push_back(eq);
        b.push_back(limit);
    }

    Equation operator[](int ix) {
        if (ix < 0) {
            ix = A.size() + ix;
        }
        return Equation(&A[ix], &b[ix]);
    }

    vector<double> &target() {
        return c;
    }

    SimplexSolution solve() {
        vector<double> x;
        double value = simplexMethodPD(A, b, c, x);
        return SimplexSolution(value, x);
    }

    SimplexSolutionInteger solve_integer() {
        vector<long long> solution;
        long long value = (1LL << 63) - 1;

        if (SolveInteger(A, b, c, value, solution)) {
            return SimplexSolutionInteger(value, solution);
        } else {
            return SimplexSolutionInteger(numeric_limits<long long>::infinity(), vector<long long>());
        }
    }
};


using namespace std;

class FDivideTheStudents {
public:
    void solve(std::istream &in, std::ostream &out) {
        int t;
        in >> t;

        while (t--) {
            vector<int> a(6), b(7);
            for (int i = 0; i < 6; ++i) {
                in >> a[i];
            }

            for (int i = 0; i < 7; ++i) {
                in >> b[i];
            }

            Simplex simplex(7);

            for (int i = 0; i < 7; ++i) {
                simplex.add_equation();
                simplex[-1][i] = +1;
                simplex[-1].rhs() = b[i];
            }

            for (int i = 0; i < 3; ++i) {
                simplex.add_equation();
                simplex.add_equation();

                simplex[-2].rhs() = a[i];
                simplex[-1].rhs() = a[3 + i];

                for (int j = 0; j < 7; ++j) {
                    if ((j >> (2 - i) & 1) == 0) {
                        simplex[-2][j] = +1;
                        simplex[-1][j] = -1;
                        simplex[-1].rhs() -= b[j];
                    }
                }
            }

            auto solution = simplex.solve_integer();

            if (solution.has_solution()) {
                for (auto x : solution.solution) {
                    out << x << " ";
                }
                out << endl;
            } else {
                out << -1 << endl;
            }
        }
    }
};


int main() {
    FDivideTheStudents solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}