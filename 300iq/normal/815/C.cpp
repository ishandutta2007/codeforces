/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author gainullin.ildar
 */

#include <bits/stdc++.h>

#include <cmath>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <list>
#include <time.h>
#include <math.h>
#include <random>
#include <deque>
#include <queue>
#include <cassert>
#include <unordered_map>
#include <iomanip>
#include <cstring>

using namespace std;


typedef long long ll;
typedef unsigned long long ull;

const int N = 5000 + 7, LIM = 1e9 + 1;

int dp[N][N][2];
int res[N][N][2];
vector<int> g[N];
int c[N], d[N];
int sz[N];


int min(int a, int b)
{
    int c = (a < b ? a : b);
    if (c > LIM)
    {
        return LIM;
    }
    else
    {
        return c;
    }
}

void dfs(int v)
{
    for (int i = 0; i < (int) g[v].size(); i++)
    {
        int to = g[v][i];
        dfs(to);
    }
    int mx = 0;
    int lim = (int) g[v].size();
    for (int j = 0; j <= sz[v]; j++)
    {
        res[v][j][0] = res[v][j][1] = LIM;
    }
    for (int i = 0; i <= lim; i++)
    {
        for (int j = 0; j <= sz[v]; j++)
        {
            dp[i][j][0] = dp[i][j][1] = LIM;
        }
    }
    dp[0][0][0] = 0;
    int cur = 0;
    for (int i = 0; i < (int) g[v].size(); i++)
    {
        int to = g[v][i];
        for (int a = 0; a <= cur; a++)
        {
            for (int j = 0; j <= sz[to]; j++)
            {
                for (int t1 = 0; t1 < 2; t1++)
                {
                    for (int t2 = 0; t2 < 2; t2++)
                    {
                        dp[i + 1][a + j][t1 | t2] = min(dp[i + 1][a + j][t1 | t2], dp[i][a][t1] + res[to][j][t2]);
                    }
                }
            }
        }
        cur += sz[to];
    }
    for (int i = 0; i <= cur; i++)
    {
        for (int t = 0; t < 2; t++)
        {
            if (t)
            {
                res[v][i + 1][1] = min(res[v][i + 1][1], dp[lim][i][1] + (c[v] - d[v]));
            }
            else
            {
                res[v][i][0] = min(res[v][i][0], dp[lim][i][0]);
                res[v][i + 1][0] = min(res[v][i + 1][0], dp[lim][i][0] + c[v]);
                res[v][i + 1][1] = min(res[v][i + 1][1], dp[lim][i][0] + (c[v] - d[v]));
            }
        }
    }
}

class Main
{
public:
    void solve(std::istream &in, std::ostream &out)
    {
        int n, b;
        in >> n >> b;
        for (int i = 0; i < n; i++)
        {
            g[i].clear();
            sz[i] = 1;
        }
        for (int i = 0; i < n; i++)
        {
            in >> c[i] >> d[i];
            if (i != 0)
            {
                int p;
                in >> p;
                p--;
                g[p].push_back(i);
            }
        }
        for (int i = n - 1; i >= 0; i--)
        {
            for (auto to : g[i])
            {
                sz[i] += sz[to];
            }
        }
        dfs(0);
        int ans = 0;
        for (int i = 0; i <= n; i++)
        {
            for (int t = 0; t < 2; t++)
            {
                if (res[0][i][t] <= b)
                {
                    ans = i;
                }
            }
        }
        out << ans << '\n';
        return;
    }
};


int main()
{
    ios::sync_with_stdio(0);
    Main solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}