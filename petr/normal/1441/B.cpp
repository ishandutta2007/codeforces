/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long int64;
typedef vector<int> vi;
typedef pair<int, int> ii;

constexpr int MODULO = 998244353;

struct Distance {
  int moves;
  int reverses;

  Distance(int moves, int reverses) : moves(moves), reverses(reverses) {
  }

  bool operator<(const Distance &rhs) const {
    if (reverses == rhs.reverses) {
      return moves < rhs.moves;
    }
    if (reverses > rhs.reverses && reverses > 20) {
      return false;
    }
    if (reverses < rhs.reverses && rhs.reverses > 20) {
      return true;
    }
    return moves + (1 << reverses) < rhs.moves + (1 << rhs.reverses);
  }
};

const int INF = (int) 1e9;

class TaskB {
 public:
  void solveOne(istream &in, ostream &out) {
    int n, m;
    in >> n >> m;
    vector<vector<vector<int>>> e(2, vector<vector<int>>(n));
    for (int i = 0; i < m; ++i) {
      int u, v;
      in >> u >> v;
      --u; --v;
      e[0][u].push_back(v);
      e[1][v].push_back(u);
    }
    vector<int> d(n, INF);
    vector<int> reachAt(n, -1);
    vector<bool> done(n);
    vector<int> reached;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> queue;
    int reverses = 0;
    Distance res(0, (int) 1e6);
    while (true) {
      int t = reverses % 2;
      if (reverses == 0) {
        d[0] = 0;
        queue.emplace(d[0], 0);
      }
      if (queue.empty()) break;
      while (!queue.empty()) {
        auto p = queue.top();
        queue.pop();
        if (done[p.second]) continue;
        int v = p.second;
        if (v == n - 1) {
          Distance cur(p.first, reverses);
          if (cur < res) {
            res = cur;
          }
        }
        done[v] = true;
        reached.push_back(v);
        if (reachAt[v] == -1) reachAt[v] = reverses;
        for (int dest : e[t][v]) {
          int destD = p.first + 1;
          if (!done[dest] && d[dest] > destD) {
            d[dest] = destD;
            queue.emplace(d[dest], dest);
          }
        }
      }
      ++reverses;
      for (int x : reached) {
        if (reverses < 20 + reachAt[x]) {
          done[x] = false;
          queue.emplace(d[x], x);
        }
      }
      reached.clear();
    }
    int64 ret = 1;
    for (int i = 0; i < res.reverses; ++i) {
      ret = ret * 2 % MODULO;
    }
    ret = (ret + res.moves) % MODULO;
    ret = (ret + MODULO - 1) % MODULO;
    out << ret << "\n";
  }

  void solve(std::istream &in, std::ostream &out) {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne(in, out);
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  TaskB solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}