/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author marX
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>

using namespace std;

const long long oo = 2000000000000000000LL + 1;

struct node {
    node *l, *r;
    long long sum;
    long long min_sum;

    node() : l(0), r(0), sum(0), min_sum(0) {}
};

long long get_sum(node *u) {
    return u ? u->sum : 0;
}

long long get_min_sum(node *u) {
    return u ? u->min_sum : 0;
}

void update(node* u, int b, int e, int x, long long v) {
    if (b + 1 == e) {
        u->sum = v;
        u->min_sum = min(0LL, v);
    } else {
        int m = (b + e) / 2;
        if (x < m) {
            if (u->l == nullptr) u->l = new node();
            update(u->l, b, m, x, v);
        } else {
            if (u->r == nullptr) u->r = new node();
            update(u->r, m, e, x, v);
        }
        u->sum = get_sum(u->l) + get_sum(u->r);
        u->min_sum = min(get_min_sum(u->l), get_sum(u->l) + get_min_sum(u->r));
    }
}

int find(node *u, int b, int e, int x, int y, long long &v) {
    if (x <= b && e <= y) {
        if (u->min_sum + v > 0) {
            v += u->sum;
            return -1;
        } else {
            if (b + 1 == e) {
                return b;
            } else {
                int m = (b + e) / 2;
                if (get_min_sum(u->l) + v <= 0)
                    return find(u->l, b, m, x, y, v);
                else {
                    v += get_sum(u->l);
                    return find(u->r, m, e, x, y, v);
                }
            }
        }
    } else {
        int m = (b + e) / 2;

        if (x < m && u->l) {
            auto r = find(u->l, b, m, x, y, v);
            if (r >= 0) return r;
        }

        if (m < y && u->r) {
            auto r = find(u->r, m, e, x, y, v);
            if (r >= 0) return r;
        }

        return -1;
    }
}

class ESashaAndAPatientFriend {
public:
    void solve(std::istream& in, std::ostream& out) {
        const int R = 1000000002;
        out.precision(10);

        auto root = new node();

        int q; in >> q;

        set<long long> active;
        map<long long, long long> speed;

        auto add = [&](long long p, long long s) {
            auto it = active.lower_bound(p);

            if (it != active.end()) {
                update(root, 1, R, p, s * (*it - p));
            } else if (s < 0) {
                update(root, 1, R, p, -oo);
            }

            if (it != active.begin()) {
                auto prev = it; --prev;
                update(root, 1, R, *prev, speed[*prev] * (p - *prev));
            }

            active.insert(p);
            speed[p] = s;
        };

        auto remove = [&](long long p) {
            update(root, 1, R, p, 0);

            auto it = active.lower_bound(p);
            assert(*it == p);

            if (it != active.begin()) {
                auto prev = it; --prev;
                long long r_prev = *prev;

                auto nxt = it; ++nxt;

                if (nxt != active.end()) {
                    long long r_nxt = *nxt;
                    assert(r_nxt > r_prev);
                    update(root, 1, R, *prev, speed[*prev] * (r_nxt - r_prev));
                } else {
                    if (speed[*prev] < 0) {
                        update(root, 1, R, *prev, -oo);
                    } else {
                        update(root, 1, R, *prev, 0);
                    }
                }
            }

            speed.erase(p);
            active.erase(p);
        };

        while (q-->0) {
            int t; in >> t;

            if (t == 1) {
                long long p, s;
                in >> p >> s;
                add(p, s);
            } else if (t == 2) {
                long long p; in >> p;
                remove(p);
            } else {
                long long l, r, v;
                in >> l >> r >> v;

                // TODO
                if (v == 0) {
                    out << l << '\n';
                    continue;
                }

                bool added = false;
                auto it = active.lower_bound(r);
                if (it == active.end() || *it != r) {
                    added = true;
                    add(r, 0);
                }

                auto x = find(root, 1, R, l, r, v);

                if (x == -1) {
                    out << -1 << '\n';
                } else {
                    auto s = speed[x];
                    long double ans = -1. * v / s + x;
                    out << fixed << ans << '\n';
                    // calculate
                }

                if (added) {
                    remove(r);
                }
            }
        }
    }
};


int main() {
	ESashaAndAPatientFriend solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}