/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author alireza_kaviani
 */

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template<class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 5000 + 10;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll n, m, s[MAXN], f[MAXN], h[MAXN], L[MAXN], R[MAXN], c1[MAXN], c2[MAXN], c12[MAXN], ans[MAXN], mx;
vector<ll> ind[MAXN];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;
    for (ll i = 1; i <= n; i++) {
        cin >> s[i];
        ind[s[i]].push_back(i);
    }
    for (ll i = 1; i <= m; i++) {
        cin >> f[i] >> h[i];
        if (SZ(ind[f[i]]) < h[i]) L[i] = INF, R[i] = -INF;
        else {
            L[i] = ind[f[i]][h[i] - 1];
            R[i] = ind[f[i]][SZ(ind[f[i]]) - h[i]];
        }
        //cout << L[i] << sep << R[i] << endl;
    }

    for (ll i = 0; i <= m; i++) {
        if (L[i] == INF) continue;
        fill(c1, c1 + MAXN, 0);
        fill(c2, c2 + MAXN, 0);
        fill(c12, c12 + MAXN, 0);
        ll cnt = 0, ways = 1;
        c1[f[i]] += (i != 0);
        for (ll j = 1; j <= m; j++) {
            if (L[j] < L[i] && f[j] != f[i] && R[j] > L[i]) c12[f[j]]++;
            else if (L[j] < L[i] && f[j] != f[i]) c1[f[j]]++;
            else if (j != i && R[j] > L[i]) c2[f[j]]++;
        }
        for (ll j = 1; j <= n; j++) {
            //cout << j << sep << c1[j] << sep << c2[j] << sep << c12[j] << endl;
            if (c1[j] + c2[j] + c12[j] == 0) continue;
            if ((c1[j] != 0) + (c2[j] != 0) + (c12[j] != 0) == 1 && c12[j] < 2) {
                cnt++;
                ways = ways * (c1[j] + c2[j] + 2 * c12[j]) % MOD;
            } else {
                cnt += 2;
                ways = ways * (((c1[j] + c12[j]) * (c12[j] + c2[j]) - c12[j]) % MOD) % MOD;
            }
        }
        //cout << i << sep << L[i] << sep << cnt << sep << ways << endl;
        //cout << "==========" << endl;
        ans[cnt] = (ans[cnt] + ways) % MOD;
        mx = max(mx, cnt);
    }
    cout << mx << sep << ans[mx] << endl;

    return 0;
}
/*

*/