#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{class logger{private:std::ostream*_1a;std::string _13="\x2c\x20";bool _c=true;int _9=0;std::string _14="\033[0;31m";std::string _17="\033[0;32m";std::string _d="\033[0;33m";std::string _1b="\033[0;34m";std::string _12="\033[0;35m";std::string _15="\033[0;36m";std::string _16="\033[1;31m";std::string _18="\033[1;32m";std::string _a="\033[1;33m";std::string _19="\033[1;34m";std::string _1c="\033[1;35m";std::string _2="\033[1;36m";std::string _e="\033[0m";std::string _3(std::string _1d){if(_1d=="red")return _14;if(_1d=="green")return _17;if(_1d=="yellow")return _d;if(_1d=="blue")return _1b;if(_1d=="magenta")return _12;if(_1d=="cyan")return _15;if(_1d=="red bold")return _16;if(_1d=="green bold")return _18;if(_1d=="yellow bold")return _a;if(_1d=="blue bold")return _19;if(_1d=="magenta bold")return _1c;if(_1d=="cyan bold")return _2;if(_1d=="reset")return _e;return "";}public:logger(std::ostream&_1a):_1a(&_1a){}logger&set_ostream(std::ostream&_1a){this->_1a=&_1a;return*this;}logger&set_sep(const std::string&_13){this->_13=_13;return*this;}logger&assert_exit(){_c=true;return*this;}logger&assert_noexit(){_c=false;return*this;}logger&set_exit_code(int _4){_9=_4;return*this;}logger&endl(){*_1a<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_13).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1a<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_f){log("{");for(auto it=_f.begin();it!=_f.end();++it){if(it!=_f.begin())log(_13);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _10="cyan"){_10=_3(_10);return log(_10).log(x).log("\x3a\x20").log(_e);}template<class...T>logger&operator()(T..._11){return log(_11...).endl();}template<class...T>logger&_1(const std::string&_5,int _6,const std::string&_7,bool _11,const std::string&_b,T..._8){if(!_11){endl();hint(_5,"magenta").hint(_6,"magenta").log(_d).log("Assertion `").log(_a).log(_7).log(_d).log("` failed").log(_e).endl();if(_b!="")hint("detail","magenta").hint(_b)(_8...);if(_c)exit(_9);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#define see(...)
#define asee(...)
#define cm_assert(...)
#include <cctype>
#include <cstdio>
namespace cm{template<class _1c,size_t _1b>class buffer_reader{protected:FILE*src;_1c*const buff;_1c*buff_end;_1c*buff_pos;void _12(){buff_end=buff+fread(buff,sizeof(_1c),_1b,src);buff_pos=buff;if(buff_end==buff){*buff_end='\0';}}public:buffer_reader(FILE*_14):src(_14),buff(new _1c[_1b]){_12();}buffer_reader(const buffer_reader&)=delete;buffer_reader(buffer_reader&&)=delete;buffer_reader&operator=(const buffer_reader&)=delete;buffer_reader&operator=(buffer_reader&&)=delete;_1c get()const{return*buff_pos;}_1c next(){_1c result=get();buff_pos++;if(buff_pos==buff_end)_12();return result;}~buffer_reader(){fclose(src);delete[]buff;}};using optimal_reader=buffer_reader<char,1<<16>;template<class _18>class scanner:protected _18{private:using _18::get;using _18::next;inline bool _15(char c){return c<=' ';}inline bool _17(char c){return c=='\n'||c=='\r';}int _16(){while(!isdigit(get())&&get()!='-')next();if(get()=='-')return next(),-1;return 1;}public:scanner()=delete;using _18::_18;char next_char(){while(_15(get()))next();return next();}char*next_token(char*s){while(_15(get()))next();while(!_15(get()))*s++=next();*s='\0';return s;}char*next_line(char*s){while(_15(get()))next();while(!_17(get()))*s++=next();*s='\0';return s;}int next_int(){int sign=_16();int result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}long long next_long(){int sign=_16();long long result=0;while(isdigit(get()))result=result*10+(next()-'0');return sign*result;}template<class _19>_19 next_integer(){_19 sign=_16();_19 result(0);while(isdigit(get()))result=result*_19(10)+_19(next()-'0');return sign*result;}double next_double(){int sign=_16();double result=0;while(isdigit(get()))result=result*10+(next()-'0');if(get()=='.'){next();double cur_ep=0.1;while(isdigit(get()))result+=cur_ep*(next()-'0'),cur_ep*=0.1;}return sign*result;}};}
#include <utility>
#include <vector>
#define _1b inline __attribute__((always_inline))
namespace cm{template<class T>inline bool check_min(T&a,const T&b){return b<a?a=b,1:0;}template<class T>inline bool check_max(T&a,const T&b){return a<b?a=b,1:0;}struct once_t{bool _14=true;bool operator()(){return _14?(_14=false,true):false;}};}using cm::check_max;using cm::check_min;template<class A,class B>_1b std::pair<A,B>operator+(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first+rhs.first,lhs.second+rhs.second);}template<class A,class B>_1b std::pair<A,B>operator-(const std::pair<A,B>&lhs,const std::pair<A,B>&rhs){return std::make_pair(lhs.first-rhs.first,lhs.second-rhs.second);}template<class A,class B>_1b std::pair<A,B>&operator+=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first+=rhs.first;lhs.second+=rhs.second;return lhs;}template<class A,class B>_1b std::pair<A,B>&operator-=(std::pair<A,B>&lhs,const std::pair<A,B>&rhs){lhs.first-=rhs.first;lhs.second-=rhs.second;return lhs;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const std::vector<T>&b){a.insert(a.end(),b.begin(),b.end());return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,const T&b){a.insert(a.end(),b);return a;}template<class T>std::vector<T>&operator+=(std::vector<T>&a,T&&b){a.insert(a.end(),std::forward<T>(b));return a;}template<class T>std::vector<T>operator+(std::vector<T>a,const std::vector<T>&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&b){a+=b;return a;}template<class T>std::vector<T>operator+(std::vector<T>a,T&&b){a+=std::forward<T>(b);return a;}
#define M__AT_INIT(line, Pred) struct CM_INNER_ATINIT##line##_17 {   CM_INNER_ATINIT##line## _17 () Pred } CM_INNER_ATINIT##line
#define M_AT_INIT(line, Pred) M__AT_INIT(line, Pred)
#define AT_INIT(Pred) M_AT_INIT(__LINE__, Pred)
#define M__AT_EXIT(line, Pred) struct CM_INNER_ATEXIT##line##_17 {   ~CM_INNER_ATEXIT##line## _17 () Pred } CM_INNER_ATEXIT##line
#define M_AT_EXIT(line, Pred) M__AT_EXIT(line, Pred)
#define AT_EXIT(Pred) M_AT_EXIT(__LINE__, Pred)
#define CONSTRAINT(n, a, b) constexpr auto n = a;
#undef _1b
#include <limits>
#include <set>
cm::scanner<cm::optimal_reader>sc(stdin);struct node_t{using min_t=std::pair<int,int>;node_t*f=nullptr;node_t*s[2]={nullptr,nullptr};bool rev=false;int cnt_v=1;int cnt_a=1;min_t e_max={-1,0};min_t e_val=e_max;bool is_root(){return f==nullptr||(f->s[0]!=this&&f->s[1]!=this);}bool get_son(){return f->s[1]==this;}void push_up(){e_max=e_val;cnt_a=cnt_v;if(s[0]!=nullptr){check_max(e_max,s[0]->e_max);cnt_a+=s[0]->cnt_a;}if(s[1]!=nullptr){check_max(e_max,s[1]->e_max);cnt_a+=s[1]->cnt_a;}}void push_rev(){std::swap(s[0],s[1]);rev=!rev;}void push_down(){if(rev){if(s[0]!=nullptr)s[0]->push_rev();if(s[1]!=nullptr)s[1]->push_rev();rev=false;}}void push(){if(!is_root())f->push();push_down();}void rotate(){node_t*const uu=this;node_t*const ff=uu->f;node_t*const aa=ff->f;const bool ss=get_son();if(!ff->is_root())aa->s[ff->get_son()]=uu;ff->f=uu;ff->s[ss]=uu->s[!ss];uu->f=aa;uu->s[!ss]=ff;if(ff->s[ss]!=nullptr)ff->s[ss]->f=ff;ff->push_up();}void splay(){push();while(!is_root()){if(f->is_root()){rotate();break;}else{(get_son()==f->get_son()?f:this)->rotate();rotate();}}push_up();}void access(){node_t*uu=this;node_t*ss=nullptr;while(uu!=nullptr){uu->splay();if(uu->s[1]!=nullptr)uu->cnt_v+=uu->s[1]->cnt_a;uu->s[1]=ss;if(uu->s[1]!=nullptr)uu->cnt_v-=uu->s[1]->cnt_a;uu->push_up();ss=uu;uu=uu->f;}}void make_root(){access();splay();push_rev();}node_t*find_root(){access();splay();node_t*uu=this;while(uu->s[0]!=nullptr){uu->push_down();uu=uu->s[0];}uu->splay();return uu;}};constexpr int N=100005;constexpr int M=300005;node_t p[N+M];void link(int u,int v){p[u].make_root();p[v].make_root();p[u].f=&p[v];p[v].cnt_v+=p[u].cnt_a;p[v].push_up();}void split(int u,int v){p[u].make_root();p[v].access();p[v].splay();}void cut(int u,int v){split(u,v);p[v].s[0]=nullptr;p[u].f=nullptr;p[v].push_up();}int get_size(int u){p[u].access();p[u].splay();return p[u].cnt_a;}int n,m;struct edge_t{int u,v,w;};edge_t e[M];std::set<std::pair<int,int>>es;int odd_cnt;void cut_edge(int id){const auto[u,v,w]=e[id];const int r=n+id+1;cut(u,r);cut(v,r);es.erase({w,id});int su=get_size(u),sv=get_size(v);if(su%2==1&&sv%2==1)odd_cnt+=2;}void add_edge(int id){const auto[u,v,w]=e[id];if(p[u].find_root()==p[v].find_root()){split(u,v);const auto[max_w,max_id]=p[v].e_max;if(max_w<w)return;cut_edge(max_id);}int su=get_size(u),sv=get_size(v);if(su%2==1&&sv%2==1)odd_cnt-=2;const int r=n+id+1;p[r].e_val={w,id};p[r].cnt_v=0;link(u,r);link(v,r);es.insert({w,id});}int main(){n=sc.next_int();odd_cnt=n;m=sc.next_int();for(int i=0;i<m;i++){e[i].u=sc.next_int();e[i].v=sc.next_int();e[i].w=sc.next_int();}for(int i=0;i<m;i++){add_edge(i);while(odd_cnt==0){const auto[max_w,max_id]=*es.rbegin();cut_edge(max_id);see(es,odd_cnt);if(odd_cnt!=0){add_edge(max_id);break;}}see(es,odd_cnt);printf("%d\n",odd_cnt==0?es.rbegin()->first:-1);}return 0;}