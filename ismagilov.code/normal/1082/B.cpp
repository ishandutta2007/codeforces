/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Azat Ismagilov
 */

/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */
/* VLADOS PRIDI */

#include <bits/stdc++.h>

#define int long long
#define fs first
#define sc second
#define pb push_back
#define mp make_pair
#define len(v) ((int)v.size())
#define vc vector
#define pr pair
#define all(v) v.begin(), v.end()

using namespace std;

typedef long long ll;
typedef long double ld;


class TaskB {
public:
	void solve(std::istream& in, std::ostream& out) {
		int n;
		in >> n;
		string s;
		in >> s;
		int ans = 0;
		vc<pr<char, int>> kubk;
		int countofG = 0;
		for (auto v : s){
			if (len(kubk) == 0 || kubk.back().fs != v){
				kubk.pb({v, 0});
			}
			kubk.back().sc++;
		}
		if (len(kubk) == 1){
			if (kubk.back().fs == 'G'){
				out << n;
			}
			else{
				out << 0;
			}
			return;
		}
		for (auto v : kubk){
			if (v.fs == 'G') {
				countofG++;
			}
		}
		for (auto v : kubk){
			if (v.fs == 'G') {
				if (countofG >= 2) {
					ans = max(ans, v.sc + 1);
				}
				ans = max(ans, v.sc);
			}
		}
		for (int i = 0; i < len(kubk) - 2; i++){
			if (kubk[i].fs == 'G'){
				if (kubk[i + 1].sc == 1){
					if (countofG >= 3){
						ans = max(ans, kubk[i].sc + kubk[i + 2].sc + 1);
					}
					ans = max(ans, kubk[i].sc + kubk[i + 2].sc);
				}
			}
		}
		out << ans;
	}
};


main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
	TaskB solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}