/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Majk
 */

#include <vector>
#include <iostream>
#include <unordered_map>
#include <map>
#include <iomanip>
#include <set>
#include <functional>
#include <fstream>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <string>
#include <sstream>
#include <queue>
using namespace std;

#define x first
#define y second
constexpr int MOD = 1000000007;

typedef std::pair<int,int> pii;
typedef long long ll;
typedef unsigned int ui;

template<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}
template<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<" \n"[i == t.size()-1];}return o;}

namespace std {
    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};
}
template<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}
template<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}
template<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }



#include <cstddef>



template<typename F>struct NoCombine {
    const int NOCOMB=-2;
    void setup(size_t){}void op(F&p,F n,size_t,size_t,size_t){p=n;}F up(F l,F r,size_t){return l==r?l:NOCOMB;}
    void down(F&u,F&l,F&r,size_t,size_t,size_t){if(u!=NOCOMB){l=r=u;}u=NOCOMB;}};
template<typename F,typename Op>struct Persistent{Op o;void setup(size_t){}void op(F&p,F n,size_t,size_t, size_t){p=n;}F up(F l, F r, size_t){return o(l,r);}void down(F&,F&,F&,size_t,size_t, size_t b) {}};

template<typename F,typename SetOp,typename CombineOp,typename PowerOp>struct LazyProp{
    void setup(size_t s){this->s=s;L=new F[s]();}
    void down(F&u,F&l,F&r,size_t i,size_t a,size_t b){op(l,L[i],2*i,a,(a+b)/2);op(r,L[i],2*i+1,(a+b)/2,b);L[i]=0;}
    void op(F&p,F n,size_t i,size_t a,size_t b){p=sop(p,pop(n,b-a));if(i<this->s)this->L[i]=sop(this->L[i],n);}
    F up(F l,F r,size_t){return cop(l,r);}SetOp sop;CombineOp cop;PowerOp pop;F*L;size_t s;
};

template <typename F> struct AddOp { F operator()(F a, F b) { return a+b; }};
template <typename F> struct MultOp { F operator()(F a, F b) { return a*b; }};
template <typename F> struct IdempOp { F operator()(F a, F b) { return a; }};
template <typename F> struct MinOp { F operator()(F a, F b) { return std::min(a,b); }};
template <typename F> struct MaxOp { F operator()(F a, F b) { return std::max(a,b); }};

template <typename F, typename Combine> struct Tree {
    void setup(size_t s, F def) {
        size = 1; while (size < s) size *= 2;
        T = new F[2*size];
        for (size_t i = size; i < 2*size; i++) T[i] = def;
        for (size_t i = size-1; i > 0; i--) T[i] = op.up(T[2*i],T[2*i+1], i);
        op.setup(2*size);
    }

    void setup(std::vector<F> & data) {
        size = 1; while (size < data.size()) size *= 2;
        T = new F[2*size];
        for (size_t i = size; i < 2*size; i++) T[i] = data[i-size];
        for (size_t i = size-1; i > 0; i--) T[i] = op.up(T[2*i],T[2*i+1], i);
        op.setup(2*size);
    }

    inline void put(size_t x, F n) { put(x, x, n); }
    inline void put(size_t from, size_t to, F n) { put2(from, to+1, n, 1, 0, size); }
    inline F get(size_t x) { return get(x, x); }
    inline F get(size_t from, size_t to) { return get2(from, to+1, 1, 0, size); }

    void put2(size_t from, size_t to, F n, size_t i, size_t a, size_t b) {
        if (from <= a && to >= b) { op.op(T[i], n, i, a, b); return; }
        if (from >= b || to <= a) { return; }
        op.down(T[i], T[2*i], T[2*i+1], i, a, b);
        put2(from, to, n, 2*i, a, (a+b)/2);
        put2(from, to, n, 2*i+1, (a+b)/2, b);
        T[i] = op.up(T[2*i], T[2*i+1], i);
    }

    F get2(size_t from, size_t to, size_t i, size_t a, size_t b) {
        if (from <= a && to >= b) { return T[i]; }
        op.down(T[i], T[2*i], T[2*i+1], i, a, b);
        if (to <= (a+b)/2) { return get2(from, to, 2*i, a, (a+b)/2); }
        else if (from >= (a+b)/2) { return get2(from, to, 2*i+1, (a+b)/2, b); }
        else return op.up(get2(from, to, 2*i, a, (a+b)/2), get2(from, to, 2*i+1, (a+b)/2, b), i);
    }

    size_t size; F * T; Combine op;
};

typedef Tree<int, NoCombine<int>> SetGetTree;
typedef Tree<int, LazyProp<int, AddOp<int>, AddOp<int>, MultOp<int>>> AddSumTree;
typedef Tree<int, LazyProp<int, AddOp<int>, MaxOp<int>, IdempOp<int>>> AddMaxTree;
typedef Tree<int, LazyProp<int, AddOp<int>, MinOp<int>, IdempOp<int>>> AddMinTree;
typedef Tree<int, Persistent<int, MinOp<int>>> SetMinTree;
typedef Tree<int, Persistent<int, MaxOp<int>>> SetMaxTree;




class C {
public:
	void solve(istream& cin, ostream& cout) {
		/*
		AddMinTree T;
		T.setup(20, 0);
		T.put(10,15, -1);
		cout << -1 << ' ' << T.get(15) << endl;
		cout << 0 << ' ' << T.get(16) << endl;
		cout << -1 << ' ' << T.get(10) << endl;
		cout << -1 << ' ' << T.get(13) << endl;
		cout << -1 << ' ' << T.get(12, 14) << endl;
		cout << -1 << ' ' << T.get(8, 11) << endl;
		cout << -1 << ' ' << T.get(12, 16) << endl;
		cout << -1 << ' ' << T.get(4,18) << endl;
		cout << 0 << ' ' << T.get(3,9) << endl;
		cout << 0 << ' ' << T.get(16,18) << endl;

		T.put(8,12, -1);
		cout << 0 << ' ' << T.get(7) << endl;
		cout << -1 << ' ' << T.get(8) << endl;
		cout << -1 << ' ' << T.get(9) << endl;
		cout << -2 << ' ' << T.get(10) << endl;
		cout << -2 << ' ' << T.get(11) << endl;
		cout << -2 << ' ' << T.get(12) << endl;
		cout << -1 << ' ' << T.get(13) << endl;

		T.put(3, 1);
		cout << 1 << ' ' << T.get(3) << endl;

		T.put(10,12, 1);
		cout << -1 << ' ' << T.get(9,13) << endl;
		 */

		int N;
		cin >> N;
		AddMaxTree T;
		T.setup(N, 0);
		vector<int> E(N);
		for (int i = 0; i < N; ++i) {
			int p, t; cin >> p >> t;
			T.put(0, p-1, 2*t-1);
			if (t == 1) {
				int x; cin >> x;
				E[p-1] = x;
			}

			int mx = T.get(0, N-1);
			if (mx <= 0) {
				cout << -1 << '\n';
				continue;
			}

			int hi = bsh(0, N-1, [&](int i) { return T.get(i, N-1) > 0; });
			// int lo =  bsh(0, hi-1, [&](int i) { return T.get(i) != 1; });
			cout << E[hi] << '\n';
		}
	}
};


int main() {
	ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
	C solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}