/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author RiaD
 */

#include <iostream>
#include <fstream>


#include <iostream>
#include <vector>

#include <ostream>


#include <type_traits>
//namespace spcppl


#include <string>
#include <stdexcept>
#ifdef SPCPPL_DEBUG
	#define SPCPPL_ASSERT(condition)
	if(!(condition)) {
		throw std::runtime_error(std::string() + #condition + " in line " + std::to_string(__LINE__) + " in " + __PRETTY_FUNCTION__);
	}
#else
#endif


//namespace spcppl




//namespace spcppl


static const int INF = 1000000000;

class C {
public:
	void solve(std::istream& in, std::ostream& out) {
		std::string s, p;
		in >> s >> p;
		//std::cout << s << std::endl;
		std::vector<int> go(s.size() + 1, 0);
		for(int i = 0; i <= s.size(); ++i) {
			int pos = i;
			for(int j = 0; j < p.size(); ++j) {
				while(pos != s.size() && s[pos] != p[j]) {
					++pos;
				}
				if(pos == s.size()) {
					pos = INF;
					break;
				}
				else
					++pos;

			}
			go[i] = pos;
		}

		std::vector<std::vector<int>> dp(s.size() + 1, std::vector<int>(s.size() + 2, -INF));
		dp[0][0] = 0;
		for(int i = 0; i < s.size(); ++i) {
			for(int j = 0; j <= s.size(); ++j) {
				if(dp[i][j] < 0)
					continue;

				{
					int newI = i + 1;
					int newJ = j + 1;
					dp[newI][newJ] = std::max(dp[newI][newJ], dp[i][j]);
				}
				{
					int newI = i + 1;
					int newJ = j;
					dp[newI][newJ] = std::max(dp[newI][newJ], dp[i][j]);
				}
				{
					int newI = go[i];
					if(go[i] == INF)
						continue;
					int newJ = (int)(j + go[i] - i - p.size());
					dp[newI][newJ] = std::max(dp[newI][newJ], dp[i][j] + 1);
				}
			}
		}

		for(int i = 0; i <= s.size(); ++i) {
			out << dp[s.size()][i] << " ";
		}

	}
};


int main() {
	C solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}