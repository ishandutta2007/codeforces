/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-04-04 15:02:48
**/

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 2e3 + 10;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 998244353; // 1e9 + 9;

ll n , E , O , res , A[MAXN] , ans[11] , fact[MAXN] , inv[MAXN];
int dp[2][MAXN][MAXN][11];
vector<ll> vec[2];

ll C(ll r , ll n){
    if(r == -1 && n == -1)  return 1;
    if(r > n || r < 0 || n < 0) return 0;
    return fact[n] * inv[r] % MOD * inv[n - r] % MOD;
}

void solve() {
    cin >> n;
    E = O = res = 0;
    vec[0] = vec[1] = {0};
    for(ll i = 1 ; i <= n ; i++){
        cin >> A[i];
        ll x = A[i] , c = 0;
        while(x)    x /= 10 , c++;
        if(c & 1)   O++;
        else    E++;
        vec[c % 2].push_back(A[i] % 11);
    }

    for(ll i = 0 ; i < 2 ; i++){
        dp[i][0][0][0] = 1;
        for(ll j = 0 ; j + 1 < vec[i].size() ; j++){
            for(ll k = 0 ; k <= j ; k++){
                for(ll l = 0 ; l < 11 ; l++){
                    dp[i][j + 1][k][(l + vec[i][j + 1]) % 11] = (dp[i][j + 1][k][(l + vec[i][j + 1]) % 11] + dp[i][j][k][l]) % MOD;
                    dp[i][j + 1][k + 1][(l + 11 - vec[i][j + 1]) % 11] = (dp[i][j + 1][k + 1][(l + 11 - vec[i][j + 1]) % 11] + dp[i][j][k][l]) % MOD;
                }
            }
        }
    }

    for(ll i = 0 ; i < 11 ; i++)    ans[i] = 1ll * dp[1][SZ(vec[1]) - 1][O / 2][i] * fact[O / 2] % MOD * fact[O - O / 2] % MOD;
    for(ll i = 0 ; i < 11 ; i++){
        ll t = (11 - i) % 11;
     //   cout << ans[i] << sep << E << sep << O << endl;
        for(ll j = 0 ; j <= E ; j++){
       //     cout << dp[0][SZ(vec[0]) - 1][j][t] << endl;
            res = (res + ans[i] * dp[0][SZ(vec[0]) - 1][j][t] % MOD * fact[j] % MOD * fact[E - j] % MOD * C((O + 1) / 2 - 1 , j + (O + 1) / 2 - 1) % MOD * C(O / 2 , E - j + O / 2)) % MOD;
        }
    }
    cout << res << endl;
 
    for(ll i = 0 ; i <= n ; i++)    for(ll j = 0 ; j <= n ; j++)    for(ll k = 0 ; k < 11 ; k++)    dp[0][i][j][k] = 0;
    for(ll i = 0 ; i <= n ; i++)    for(ll j = 0 ; j <= n ; j++)    for(ll k = 0 ; k < 11 ; k++)    dp[1][i][j][k] = 0;
    return ;
}

int main(){
    ios::sync_with_stdio(false) ; cin.tie(0) ; cout.tie(0);
    
    fact[0] = inv[0] = 1;
    for(ll i = 1 ; i < MAXN ; i++)  fact[i] = fact[i - 1] * i % MOD , inv[i] = poww(fact[i] , MOD - 2 , MOD);

    ll q;
    cin >> q;
    while(q--)  solve();
}

/*

*/