/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-04-02 14:27:32
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 1e6 + 10;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = (1 << 30) - 1; // 998244353; // 1e9 + 9;

ll n , q , ans , par[MAXN] , A[MAXN] , sz[MAXN] , mark[MAXN] , dist[MAXN] , prv[MAXN] , B[MAXN];
vector<ll> ps[MAXN];
vector<pll> V[MAXN] , D[MAXN] , adj[MAXN];

void DFS_Size(ll v , ll p = -1){
    sz[v] = 1;
    for(pll i : adj[v]){
        ll u = i.X , w = i.Y;
        if(!mark[u] && u != p)  DFS_Size(u , v) , sz[v] += sz[u];
    }
}

ll centroid(ll v , ll p , ll root){
    for(pll i : adj[v]){
        ll u = i.X;
        if(!mark[u] && u != p && sz[u] > sz[root] / 2)  return centroid(u , v , root);
    }
    return v;
}

void DFS(ll v , ll p , ll h , ll root){
    dist[v] = h;
    V[root].push_back({B[v] , v});
    for(pll i : adj[v]){
        ll u = i.X , w = i.Y;
        if(!mark[u] && u != p)  DFS(u , v , h + w , root);
    }
}

ll build(ll v){
    DFS_Size(v);
    ll cent = centroid(v , -1 , v);
    DFS(cent , -1 , 0 , cent);
    Sort(V[cent]);
//    cout << v << sep << cent << endl;
    for(ll i = 0 ; i < SZ(V[cent]) ; i++){
        ll x = V[cent][i].Y;
        ps[cent].push_back(dist[x] - prv[x]);
        prv[x] = dist[x];
        D[cent].push_back({x , dist[x]});
    }
    Sort(D[cent]);
    partial_sum(all(ps[cent]) , ps[cent].begin());
    mark[cent] = 1;
//    for(pll i : adj[cent]) cout << i.X << sep << i.Y << endl;
//    cout << endl;
    for(pll i : adj[cent])  if(!mark[i.X]){
        ll C = build(i.X);
        par[C] = cent;
    }
    return cent;
}

ll query(ll l , ll r , ll x){
    ll ans = 0 , cnt = 0;
    ll v = x;
//    if(l > r || l < 1 || r > n || x < 1 || x > n)   cout << "WA" << endl , exit(0);
//    cout << l << sep << r << sep << x << endl;
//    if(l > MAXN || l < 0 || r > MAXN || r < 0 || x > MAXN || x < 0) return cout << -1 << endl , 0;
//    for(ll i = 1 ; i <= n ; i++)    cout << A[i] << sep;
//    cout << endl;
    while(v != 0){
        ll L = lower_bound(all(V[v]) , pll(l , -INF)) - V[v].begin() , R = lower_bound(all(V[v]) , pll(r , INF)) - V[v].begin();
        ans += (R == 0 ? 0 : ps[v][R - 1]) - (L == 0 ? 0 : ps[v][L - 1]);
        ans += (R - L - cnt) * (*lower_bound(all(D[v]) , pll(x , -INF))).Y;
        cnt = R - L;
//        cout << l << sep << r << sep << x << sep << v << sep << L << sep << R << sep << ans << endl;
        v = par[v];
    }
    return ans;
}

void update(ll x){
    ll v = A[x] , u = A[x + 1] , t = v;
//    cout << "swap " << v << sep << u << sep << t << sep << x << endl;
//    if(x >= n || x < 1)  cout << "WA" << endl , exit(0);
    while(t != 0){
        ll ind = lower_bound(all(V[t]) , pll(x , -INF)) - V[t].begin();
        ll ind2 = lower_bound(all(V[t]) , pll(x , INF)) - V[t].begin();
//        cout << x << sep << t << sep << ind << sep << ind2 << endl;
        if(ind2 == SZ(V[t]) || V[t][ind2].X != x + 1){
            V[t][ind].X = x + 1;
        }
        t = par[t];
    }
    t = u;
    while(t != 0){
        ll ind = lower_bound(all(V[t]) , pll(x , -INF)) - V[t].begin();
        ll ind2 = lower_bound(all(V[t]) , pll(x , INF)) - V[t].begin();
//        if(ind >= SZ(V[t]) || ind2 >= SZ(V[t])) cout << -1 << endl , exit(0);
        if(V[t][ind].X != x){
            V[t][ind2].X = x;
        }
        else{
//            if(ind2 <= ind) assert(0);
            ll x = (ind == 0 ? 0 : ps[t][ind - 1]) , y = ps[t][ind] , z = ps[t][ind2];
            ps[t][ind] = x + z - y;
        }
        t = par[t];
    }
    swap(A[x] , A[x + 1]);
}

int main() {
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    cin >> n >> q;
    for(ll i = 1 ; i <= n ; i++)    cin >> A[i] , B[A[i]] = i;
//    for(ll i = 1 ; i <= n ; i++)    cout << i << sep << A[i] << sep << B[i] << endl;
    for(ll i = 1 ; i < n ; i++){
        ll v , u , w;
        cin >> v >> u >> w;
        adj[v].push_back({u , w});
        adj[u].push_back({v , w});
    }
    build(1);
    
//    if(n != 5)  return cout << -1 << endl , 0;
    /*for(ll i = 1 ; i <= n ; i++){
        cout << i << endl;
        for(pll j : V[i])   cout << j.X << sep << j.Y << endl;
        cout << endl;
        for(pll j : D[i])   cout << j.X << sep << j.Y << endl;
        cout << endl;
        for(ll j : ps[i])  cout << j << sep;
        cout << endl << "============\n";
    }*/

//    for(ll i = 1 ; i <= n ; i++)    cout << par[i] << sep;
//    cout << endl;
    while(q--){
        ll t , l , r , x;
        cin >> t;
        //cout << ans << endl;
        /*for(ll i = 1 ; i <= n ; i++)    cout << A[i] << sep;
        cout << endl;
        for(ll i = 1 ; i <= n ; i++){
            for(pll j : V[i])   cout << j.X << sep << j.Y << endl;
            cout << "============\n";
        }
        cout << endl;*/
        if(t == 1){
            cin >> l >> r >> x;
            l ^= ans & MOD;
            r ^= ans & MOD;
            x ^= ans & MOD;
            //cout << l << sep << r << sep << x << endl;
            cout << (ans = query(l , r , x)) << endl;
            //break;
        }
//        if(t == 1 && l == 1 && r == 3)  break;
        if(t == 2){
            cin >> x;
            x ^= ans & MOD;
            update(x);
        }
//        cout << "=============" << endl;
    }

    return 0;
}
/*

*/