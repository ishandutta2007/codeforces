/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-03-20 17:14:35
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 26e5 + 10;
const ll LCM = 2520;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll n , q , cur , ans[MAXN] , inDeg[MAXN] , cnt[MAXN] , k[MAXN] , M[MAXN] , mark[MAXN];
vector<ll> vec , E[MAXN] , adj[MAXN] , radj[MAXN];

void DFS(ll v){
    mark[v] = 1;
    vec.push_back(v);
    for(ll u : adj[v])  if(!mark[u])    DFS(u);
    for(ll u : radj[v]) if(!mark[u])    DFS(u);
}

void solve(vector<ll> V){
    queue<ll> Q;
    for(ll i : V)   if(inDeg[i] == 0)   Q.push(i);
    while(!Q.empty()){
        ll v = Q.front() ; Q.pop();
        mark[v] = 2;
        for(ll u : adj[v]){
            inDeg[u]--;
            if(inDeg[u] == 0)   Q.push(u);
        }
    }
    for(ll i : V)   if(mark[i] == 1){
        if(cnt[i / LCM] == 0)   cur++;
        cnt[i / LCM]++;
    }
    for(ll i : V)   ans[i] = cur;
    cur = 0;
    for(ll i : V)   cnt[i / LCM] = 0;
}

int main() {
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    cin >> n;
    for(ll i = 1 ; i <= n ; i++)    cin >> k[i] , k[i] = (k[i] % LCM + LCM) % LCM;
    for(ll i = 1 ; i <= n ; i++){
        cin >> M[i];
        for(ll j = 0 , x ; j < M[i] ; j++){
            cin >> x;
            E[i].push_back(x);
        }
    }

    for(ll i = 1 ; i <= n ; i++){
        for(ll j = 0 ; j < LCM ; j++){
            ll t = (j + k[i]) % LCM;
            /*if(E[i][t % M[i]] * LCM + t >= MAXN){
                cout << "Bug" << sep << i << sep << j << sep << t << sep << E[i][t % M[i]] << endl;
                return 0;
            }*/
            adj[i * LCM + j].push_back(E[i][t % M[i]] * LCM + t);
            radj[E[i][t % M[i]] * LCM + t].push_back(i * LCM + j);
            inDeg[E[i][t % M[i]] * LCM + t]++;
        }
    }

    ll cnt = 0;
    for(ll i = 0 ; i < MAXN ; i++){
        if(!mark[i]){
            vec = {};
            //cout << "debug " << i << sep << ++cnt << endl;
            //cout.flush();
            //if(i / LCM == 2)    return cout << "debug " << endl , 0;
            DFS(i);
            //cout << "debug " << i << sep << ++cnt << endl;
            //for(ll j : vec) cout << j << sep;
            //cout << endl;
            //cout.flush();
            solve(vec);
            //cout << "debug " << i << sep << ++cnt << endl;
            //cout.flush();
        }
    }

    cin >> q;
    while(q--){
        ll x , y;
        cin >> x >> y;
        y = (y % LCM + LCM) % LCM;
        cout << ans[x * LCM + y] << endl;
    }

    return 0;
}
/*

*/