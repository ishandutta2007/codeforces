#include <bits/stdc++.h>
#define EB emplace_back
#define ctz __builtin_ctz

typedef unsigned int u32;
typedef std::vector <int> vector;

const int N = 100054, M = N * 2, mod = 1000000007;

struct edge {
	int u, v, w;
	edge (int u0 = 0, int v0 = 0, int w0 = 0) : u(u0), v(v0), w(w0) {}
} e[M];

int V, E, Es = 0;
int to[M], first[N], next[M];
int p[N], bel[N], W0[N], coval[N];
bool isnb[N];
int cnt_nb = 0, F1[N], F2[N], BF[N];
int state[N], dp[2][375], *cur = *dp, *nxt = dp[1];
vector lb[N];

inline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}

namespace linear {
	const u32 all[374] = {
		0x00000000, 0x00000002, 0x00000004, 0x00000006, 0x00000008, 0x00000010, 0x00000012, 0x00000014, 0x00000016, 0x00000018, 0x00000020, 0x00000024, 0x00000028, 0x00000040, 0x00000042, 0x00000080, 0x00000100,
		0x00000102, 0x00000104, 0x00000106, 0x00000108, 0x00000110, 0x00000112, 0x00000114, 0x00000116, 0x00000118, 0x00000120, 0x00000124, 0x00000128, 0x00000140, 0x00000142, 0x00000180, 0x00000200, 0x00000204,
		0x00000208, 0x00000210, 0x00000214, 0x00000218, 0x00000220, 0x00000224, 0x00000228, 0x00000240, 0x00000280, 0x00000400, 0x00000402, 0x00000410, 0x00000412, 0x00000420, 0x00000440, 0x00000442, 0x00000480,
		0x00000800, 0x00000810, 0x00000820, 0x00000840, 0x00000880, 0x00001000, 0x00001002, 0x00001004, 0x00001006, 0x00001008, 0x00002000, 0x00002004, 0x00002008, 0x00004000, 0x00004002, 0x00008000, 0x00010000,
		0x00010002, 0x00010004, 0x00010006, 0x00010008, 0x00010010, 0x00010012, 0x00010014, 0x00010016, 0x00010018, 0x00010020, 0x00010024, 0x00010028, 0x00010040, 0x00010042, 0x00010080, 0x00010100, 0x00010102,
		0x00010104, 0x00010106, 0x00010108, 0x00010110, 0x00010112, 0x00010114, 0x00010116, 0x00010118, 0x00010120, 0x00010124, 0x00010128, 0x00010140, 0x00010142, 0x00010180, 0x00010200, 0x00010204, 0x00010208,
		0x00010210, 0x00010214, 0x00010218, 0x00010220, 0x00010224, 0x00010228, 0x00010240, 0x00010280, 0x00010400, 0x00010402, 0x00010410, 0x00010412, 0x00010420, 0x00010440, 0x00010442, 0x00010480, 0x00010800,
		0x00010810, 0x00010820, 0x00010840, 0x00010880, 0x00011000, 0x00011002, 0x00011004, 0x00011006, 0x00011008, 0x00012000, 0x00012004, 0x00012008, 0x00014000, 0x00014002, 0x00018000, 0x00020000, 0x00020004,
		0x00020008, 0x00020010, 0x00020014, 0x00020018, 0x00020020, 0x00020024, 0x00020028, 0x00020040, 0x00020080, 0x00020100, 0x00020104, 0x00020108, 0x00020110, 0x00020114, 0x00020118, 0x00020120, 0x00020124,
		0x00020128, 0x00020140, 0x00020180, 0x00020200, 0x00020204, 0x00020208, 0x00020210, 0x00020214, 0x00020218, 0x00020220, 0x00020224, 0x00020228, 0x00020240, 0x00020280, 0x00020400, 0x00020410, 0x00020420,
		0x00020440, 0x00020480, 0x00020800, 0x00020810, 0x00020820, 0x00020840, 0x00020880, 0x00021000, 0x00021004, 0x00021008, 0x00022000, 0x00022004, 0x00022008, 0x00024000, 0x00028000, 0x00040000, 0x00040002,
		0x00040010, 0x00040012, 0x00040020, 0x00040040, 0x00040042, 0x00040080, 0x00040100, 0x00040102, 0x00040110, 0x00040112, 0x00040120, 0x00040140, 0x00040142, 0x00040180, 0x00040200, 0x00040210, 0x00040220,
		0x00040240, 0x00040280, 0x00040400, 0x00040402, 0x00040410, 0x00040412, 0x00040420, 0x00040440, 0x00040442, 0x00040480, 0x00040800, 0x00040810, 0x00040820, 0x00040840, 0x00040880, 0x00041000, 0x00041002,
		0x00042000, 0x00044000, 0x00044002, 0x00048000, 0x00080000, 0x00080010, 0x00080020, 0x00080040, 0x00080080, 0x00080100, 0x00080110, 0x00080120, 0x00080140, 0x00080180, 0x00080200, 0x00080210, 0x00080220,
		0x00080240, 0x00080280, 0x00080400, 0x00080410, 0x00080420, 0x00080440, 0x00080480, 0x00080800, 0x00080810, 0x00080820, 0x00080840, 0x00080880, 0x00081000, 0x00082000, 0x00084000, 0x00088000, 0x00100000,
		0x00100002, 0x00100004, 0x00100006, 0x00100008, 0x00100100, 0x00100102, 0x00100104, 0x00100106, 0x00100108, 0x00100200, 0x00100204, 0x00100208, 0x00100400, 0x00100402, 0x00100800, 0x00101000, 0x00101002,
		0x00101004, 0x00101006, 0x00101008, 0x00102000, 0x00102004, 0x00102008, 0x00104000, 0x00104002, 0x00108000, 0x00200000, 0x00200004, 0x00200008, 0x00200100, 0x00200104, 0x00200108, 0x00200200, 0x00200204,
		0x00200208, 0x00200400, 0x00200800, 0x00201000, 0x00201004, 0x00201008, 0x00202000, 0x00202004, 0x00202008, 0x00204000, 0x00208000, 0x00400000, 0x00400002, 0x00400100, 0x00400102, 0x00400200, 0x00400400,
		0x00400402, 0x00400800, 0x00401000, 0x00401002, 0x00402000, 0x00404000, 0x00404002, 0x00408000, 0x00800000, 0x00800100, 0x00800200, 0x00800400, 0x00800800, 0x00801000, 0x00802000, 0x00804000, 0x00808000,
		0x01000000, 0x01000002, 0x01000004, 0x01000006, 0x01000008, 0x01000010, 0x01000012, 0x01000014, 0x01000016, 0x01000018, 0x01000020, 0x01000024, 0x01000028, 0x01000040, 0x01000042, 0x01000080, 0x02000000,
		0x02000004, 0x02000008, 0x02000010, 0x02000014, 0x02000018, 0x02000020, 0x02000024, 0x02000028, 0x02000040, 0x02000080, 0x04000000, 0x04000002, 0x04000010, 0x04000012, 0x04000020, 0x04000040, 0x04000042,
		0x04000080, 0x08000000, 0x08000010, 0x08000020, 0x08000040, 0x08000080, 0x10000000, 0x10000002, 0x10000004, 0x10000006, 0x10000008, 0x20000000, 0x20000004, 0x20000008, 0x40000000, 0x40000002, 0x80000000
	};

	u32 un[375][375], ins[375][32];

	int solve(const vector &v) {
		int i, j, lb[5] = {0}; u32 ret = 0;
		for (int x : v) {
			for (i = 4; i >= 0; --i) if (x >> i & 1) {
				if (lb[i]) x ^= lb[i];
				else {lb[i] = x; break;}
			}
			if (!x) return 374;
		}
		for (i = 4; i >= 0; --i)
			for (j = i - 1; j >= 0; --j)
				if ((lb[i] & lb[j]) >> j & 1) lb[i] ^= lb[j];
		for (i = 0; i < 5; ++i) if (lb[i]) ret |= 1 << lb[i];
		j = std::lower_bound(all, all + 374, ret) - all;
		return assert(all[j] == ret), j;
	}

	void init() {
		int i, j; u32 S; vector t;
		for (i = 0; i < 374; ++i) {
			for (j = i; j < 374; ++j) {
				t.clear();
				for (S = all[i]; S; S &= S - 1) t.EB(ctz(S));
				for (S = all[j]; S; S &= S - 1) t.EB(ctz(S));
				un[i][j] = un[j][i] = solve(t);
			}
			t.clear();
			for (S = all[i]; S; S &= S - 1) t.EB(ctz(S));
			t.EB(0);
			for (j = 0; j < 32; ++j) t.back() = j, ins[i][j] = solve(t);
		}
		for (i = 0; i < 375; ++i) un[i][374] = un[374][i] = 374;
		for (i = 0; i < 32; ++i) ins[374][i] = 374;
	}
}

inline void addedge(int u, int v, int w) {
	e[++Es] = edge(u, v, w), next[Es] = first[u], first[u] = Es;
	e[++Es] = edge(v, u, w), next[Es] = first[v], first[v] = Es;
}

void dfs(int x, int B) {
	int i, y; bel[x] = B;
	for (i = first[x]; i; i = next[i])
		if (!(~p[y = e[i].v] || isnb[y])) p[y] = x, W0[y] = W0[x] ^ e[i].w, dfs(y, B);
}

int main() {
	int i, j, u, v, ex, w;
	scanf("%d%d", &V, &E);
	for (i = 0; i < E; ++i) scanf("%d%d%d", &u, &v, &w), addedge(u, v, w);
	memset(p, -1, sizeof p), W0[1] = p[1] = 0;
	for (i = first[1]; i; i = next[i]) isnb[v = e[i].v] = true, p[v] = 1, W0[v] = e[i].w;
	for (v = 1; v <= V; ++v) if (isnb[v] && !BF[v]) {
		for (i = first[v]; i; i = next[i])
			if (isnb[u = e[i].v]) {
				BF[v] = BF[u] = ++cnt_nb, coval[cnt_nb] = W0[u] ^ W0[v] ^ e[i].w;
				F1[cnt_nb] = v, F2[cnt_nb] = u; break;
			}
		if (!i) BF[v] = ++cnt_nb, F1[cnt_nb] = v;
	}
	for (v = 1; v <= V; ++v) if (isnb[v]) dfs(v, v);
	for (i = 1; i <= Es; i += 2) {
		u = e[i].u, v = e[i].v;
		if (u == 1 || v == 1) continue;
		if (BF[u] && BF[v]) {assert(BF[u] == BF[v]); continue;}
		if (u == p[v] || v == p[u]) continue;
		assert(bel[u] == bel[v]);
		lb[bel[u]].EB(W0[u] ^ W0[v] ^ e[i].w);
	}
	linear::init();
	for (v = 1; v <= V; ++v) if (isnb[v]) state[v] = linear::solve(lb[v]);
/*	for (i = 1; i <= cnt_nb; ++i)
		if (F2[i]) {
			fprintf(stderr, "%d : [%d, %d] with co-value %d\n> %d : ", i, F1[i], F2[i], coval[i], F1[i]);
			for (int x : lb[F1[i]]) fprintf(stderr, "%d, ", x); fprintf(stderr, "\n> %d : ", F2[i]);
			for (int x : lb[F2[i]]) fprintf(stderr, "%d, ", x); fputc(10, stderr);
		} else {
			fprintf(stderr, "%d : [%d] single.\n> %d: ", i, F1[i], F1[i]);
			for (int x : lb[F1[i]]) fprintf(stderr, "%d, ", x); fputc(10, stderr);
		} */
	*nxt = 1;
	for (i = 1; i <= cnt_nb; ++i) {
		std::swap(cur, nxt), memset(nxt, 0, sizeof *dp);
		u = state[F1[i]], v = linear::un[ state[F2[i]] ][u], ex = linear::ins[v][ coval[i] ];
		for (j = 0; j < 374; ++j) if ((w = cur[j])) {
			if (F2[i])
				add(nxt[j], w), add(nxt[linear::un[j][ex]], w),
				add(nxt[linear::un[j][v]], w), add(nxt[linear::un[j][v]], w);
			else
				add(nxt[j], w), add(nxt[linear::un[j][u]], w);
		}
	}
	printf("%d\n", int(std::accumulate(nxt, nxt + 374, 0ll) % mod));
	return 0;
}