/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <chrono>
//#include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

class DNravitsyaNeNravitsya {
 public:
  void solveOne() {
    int n, m, p;
    cin >> n >> m >> p;
    vector<int64> a(n);
    for (int i = 0; i < n; ++i) {
      string s;
      cin >> s;
      for (int j = 0; j < m; ++j) if (s[j] == '1') a[i] |= (int64(1) << j);
    }
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    int best = 0;
    int64 bestMask = 0;
    for (int iter = 0; iter < 30; ++iter) {
      int64 pivot = a[uniform_int_distribution<int>(0, n - 1)(rng)];
      vector<int> bits;
      for (int bit = 0; bit < m; ++bit) if (pivot & (int64(1) << bit)) {
        bits.push_back(bit);
      }
      vector<int> cnt(1 << bits.size());
      for (int i = 0; i < n; ++i) {
        int got = 0;
        for (int j = 0; j < bits.size(); ++j) {
          if (a[i] & (int64(1) << bits[j])) {
            got |= 1 << j;
          }
        }
        ++cnt[got];
      }
      for (int k = 0; k < bits.size(); ++k) {
        for (int i = 0; i < cnt.size(); ++i) {
          int j = i ^ (1 << k);
          if (j < i) {
            cnt[j] += cnt[i];
          }
        }
      }
      for (int i = 0; i < cnt.size(); ++i) if (cnt[i] >= (n + 1) / 2) {
        int got = __builtin_popcount(i);
        if (got > best) {
          best = got;
          bestMask = 0;
          for (int j = 0; j < bits.size(); ++j) if (i & (1 << j)) {
            bestMask |= int64(1) << bits[j];
          }
        }
      }
    }
    for (int i = 0; i < m; ++i) {
      if (bestMask & (int64(1) << i)) {
        cout << "1";
      } else {
        cout << "0";
      }
    }
    cout << "\n";
  }

  void solve() {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne();
    }
  }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    DNravitsyaNeNravitsya solver;


    solver.solve();
    return 0;
}