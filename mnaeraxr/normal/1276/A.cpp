/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author marX
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>
#include <vector>

using namespace std;

template<size_t alpha = 26, typename char_type=char, size_t zero = 'a'>
class Trie {

public:
    vector<vector<int>> go;
    vector<bool> fin;

    Trie() {
        new_node();
    }

    int states() {
        return go.size();
    }

    vector<int> &operator[](int ix) {
        return go[ix];
    }

    int new_node() {
        int res = go.size();
        go.push_back(vector<int>(alpha));
        fin.push_back(false);
        return res;
    }

    void push(basic_string<char_type> s) {
        int node = 0;

        for (auto c : s) {
            int pos = c - zero;

            if (!go[node][pos]) {
                int new_pos = new_node();
                go[node][pos] = new_pos;
            }

            node = go[node][pos];
        }

        fin[node] = true;
    }

    void aho_corasik() {
        queue<pair<int, int>> q;
        for (int i = 0; i < alpha; ++i) {
            if (go[0][i]) {
                q.push({go[0][i], 0});
            }
        }

        while (!q.empty()) {
            int node, fail;
            tie(node, fail) = q.front();
            q.pop();

            if (fin[fail]) {
                fin[node] = true;
            }

            for (int i = 0; i < alpha; ++i) {
                if (go[node][i]) {
                    q.push({go[node][i], go[fail][i]});
                } else {
                    go[node][i] = go[fail][i];
                }
            }
        }
    }
};

using namespace std;

class AAsSimpleAsOneAndTwo {
public:
    void solve(std::istream &in, std::ostream &out) {
        auto A = Trie<>();
        A.push("one");
        A.push("two");
        A.aho_corasik();

        int t;
        in >> t;

        while (t--) {
            string s;
            in >> s;

            auto n = A.states();

            vector<vector<int>> dp(s.length() + 1, vector<int>(n, s.length()));
            vector<vector<int>> bk(s.length() + 1, vector<int>(n, 0));
            dp[0][0] = 0;

            for (int i = 0; i < s.length(); ++i) {
                dp[i + 1] = dp[i];
                for (auto &x : dp[i + 1]) ++x;
                iota(bk[i + 1].begin(), bk[i + 1].end(), 0);

                int pos = s[i] - 'a';

                for (int j = 0; j < n; ++j) {
                    int nx = A[j][pos];

                    if (A.fin[nx])
                        continue;

                    if (dp[i + 1][nx] > dp[i][j]) {
                        dp[i + 1][nx] = dp[i][j];
                        bk[i + 1][nx] = j;
                    }
                }
            }

            int p = min_element(dp.back().begin(), dp.back().end()) - dp.back().begin();

            vector<int> answer;

            for (int i = s.length(); i; --i) {
                int np = bk[i][p];

                if (dp[i - 1][np] < dp[i][p]) {
                    answer.push_back(i);
                }

                p = np; // we did it ;)
            }

            reverse(answer.begin(), answer.end());

            out << answer.size() << endl;
            for (auto x : answer) {
                out << x << " ";
            }
            out << endl;
        }
    }
};


int main() {
    AAsSimpleAsOneAndTwo solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}