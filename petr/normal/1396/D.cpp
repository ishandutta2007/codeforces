/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long int64;
typedef vector<int> vi;
typedef pair<int, int> ii;

struct MM {
  int64 x;
  int64 y;
  int c;
};

constexpr int64 MODULO = (int64) 1e9 + 7;

class TaskD {
 public:
  void solveOne(istream &in, ostream &out) {
    int n, k;
    int64 L;
    in >> n >> k >> L;
    vector<MM> mms(n);
    vector<int> counts(k);
    for (auto& v : mms) {
      in >> v.x >> v.y >> v.c;
      --v.c;
      ++counts[v.c];
    }
    for (int x : counts) {
      assert(x >= 1);
    }
    int64 xmin = L;
    int64 xmax = -1;
    int64 ymin = L;
    int64 ymax = -1;
    vector<MM> inters;
    for (const auto& v : mms) {
      if (counts[v.c] == 1) {
        xmin = min(xmin, v.x);
        xmax = max(xmax, v.x + 1);
        ymin = min(ymin, v.y);
        ymax = max(ymax, v.y + 1);
      } else {
        inters.push_back(v);
      }
    }
    if (inters.empty()) {
      assert(xmin < xmax);
      int64 res = (xmin + 1) * (L - xmax + 1) % MODULO * (ymin + 1) % MODULO * (L - ymax + 1) % MODULO;
      out << res << "\n";
      return;
    }
    sort(all(inters), [](const auto& u, const auto& v) {
      return u.y < v.y;
    });
    n = inters.size();
    int64 from = 0;
    int64 res = 0;
    int need = 0;
    for (int x : counts) if (x >= 2) {
      ++need;
    }
    counts.assign(k, 0);
    vector<MM> visible;
    visible.reserve(n);
    for (int top = 0; top < n;) {
      visible.clear();
      int64 topChoices;
      if (ymin > ymax) {
        topChoices = inters[top].y - from + 1;
      } else {
        topChoices = min(ymin, inters[top].y) - from + 1;
      }
      if (topChoices > 0) {
        for (int bottom = top; bottom < n; ++bottom) {
          const MM &cur = inters[bottom];
          {
            int left = -1;
            int right = visible.size();
            while (right - left > 1) {
              int middle = (left + right) / 2;
              if (cur.x <= visible[middle].x) {
                right = middle;
              } else {
                left = middle;
              }
            }
            visible.insert(visible.begin() + right, cur);
          }
          int64 bottomChoices;
          int64 maxBottom = (bottom + 1 < n ? inters[bottom + 1].y : L);
          if (ymin > ymax) {
            bottomChoices = maxBottom - inters[bottom].y;
          } else {
            bottomChoices = maxBottom - max(inters[bottom].y, ymax - 1);
          }
          if (bottomChoices > 0) {
            int64 ychoices = topChoices * bottomChoices % MODULO;
            int64 xchoices = 0;
            int left = 0;
            int right = 0;
            int have = 0;
            int fromx = 0;
            while (left < visible.size()) {
              if (have == need) {
                int64 leftChoices;
                if (xmin > xmax) {
                  leftChoices = visible[left].x - fromx + 1;
                } else {
                  leftChoices = min(visible[left].x, xmin) - fromx + 1;
                }
                if (leftChoices > 0) {
                  int64 rightChoices;
                  if (xmin > xmax) {
                    rightChoices = L - visible[right - 1].x;
                  } else {
                    rightChoices = L - max(xmax - 1, visible[right - 1].x);
                  }
                  if (rightChoices > 0) {
                    xchoices += leftChoices * rightChoices;
                  }
                }
                fromx = visible[left].x + 1;
              }
              if (right == visible.size() || have == need) {
                int which = visible[left].c;
                --counts[which];
                if (counts[which] == 0) --have;
                ++left;
              } else {
                int which = visible[right].c;
                if (counts[which] == 0) ++have;
                ++counts[which];
                ++right;
              }
            }
            res = (res + ychoices * (xchoices % MODULO)) % MODULO;
          }
        }
      }
      from = inters[top].y + 1;
      int nextTop = top;
      while (nextTop < n && inters[nextTop].y == inters[top].y) ++nextTop;
      top = nextTop;
    }
    out << res << "\n";
  }

  void solve(std::istream &in, std::ostream &out) {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne(in, out);
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  TaskD solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}