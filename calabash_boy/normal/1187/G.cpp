/* Generated by powerful Codeforces Tool
 * Author: calabash_boy_love_15 
 * Time: 2019-10-10 15:18:51
 * Personal Code Template: https://github.com/4thcalabash/ACM-Code-Library
**/
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;
#ifdef __LOCAL_DEBUG__
# define _debug(fmt, ...) fprintf(stderr, "\033[91m[%s %3d]: " fmt "\n\033[0m", \
  __func__,__LINE__, ##__VA_ARGS__)
#else
# define _debug(...) (void(0))
#endif
#define PB(x) push_back(x)
#define rep(i,l,r) for (int i = l,_ = r;i< _;i++)
#define REP(i,l,r) for (int i=l,_=r;i<=_;i++)
#define leave(x) do {cout<<#x<<endl;fflush(stdout);return 0;}while (0);
#define untie do{ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);}while (0)
#define range(x) x.begin(),x.end()
typedef long long LL;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double db;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
const int inf = 0x3f3f3f3f;
const ll inf_ll = 0x3f3f3f3f3f3f3f3fLL;
/************* header ******************/
const int N = 100;
const int maxn = N * N + 1000;
const int maxm = maxn * N * 2 + 10;

const int INF = 0x3f3f3f3f;
struct MCMF{
    int ss,tt,dis[maxn],pre[maxn];
    int first[maxn],from[maxm*2],des[maxm*2],nxt[maxm*2],cost[maxm*2],flow[maxm*2],tot;
    bool in[maxn];
    MCMF(){
        clear();
    }
    void clear(){
        tot =-1;
        memset(first,-1,sizeof first);
    }
    // <u,v,flow,cost>
    void init(vector<tuple<int,int,int,int> > E){
        for (auto edge : E){
            int u,v,f,c;
            tie(u,v,f,c) = edge;
            addEdge(u, v, f, c);
        }
    }
    void __addE(int x,int y,int f,int c){
        tot++;
        from[tot] =x;des[tot] =y;
        flow[tot] =f;cost[tot] =c;
        nxt[tot] = first[x];first[x] = tot;
    }
    inline void addEdge(int x,int y,int f,int c){
        __addE(x,y,f,c);__addE(y,x,0,-c);
    }
    bool spfa(){
        memset(in,0,sizeof in);
        for (int i=0;i<maxn;i++)dis[i] = INF;
        memset(pre,-1,sizeof pre);
        dis[ss] =0;in[ss] =1;
        queue<int> Q;Q.push(ss);
        while (!Q.empty()){
            int q = Q.front();
            Q.pop();in[q] = 0;
            for (int t = first[q];t!=-1;t = nxt[t]){
                int v=des[t],len=cost[t],cx=flow[t];
                if (cx&&dis[v]>dis[q]+len){
                    dis[v] = dis[q]+len;
                    pre[v] = t;
                    if (!in[v]){
                        Q.push(v);in[v] = 1;
                    }
                }
            }
        }
        // min cost max flow
        return pre[tt] != -1;
    }
    // <flow,cost>
    pair<int,int> run(int s, int t){
        ss =s;tt=t;
        int totflow =0,totcost =0,nowflow =0,nowcost =0;
        while (spfa()){
            nowcost =0;nowflow = INF;
            int now =pre[tt];
            while (now!=-1){
                nowflow = min(nowflow,flow[now]);
                now = pre[from[now]];
            }
            now = pre[tt];
            while (now!=-1){
                flow[now] -= nowflow;
                flow[now^1] += nowflow;
                nowcost +=cost[now];
                now = pre[from[now]];
            }
            nowcost*=nowflow;
            totflow +=nowflow;
            totcost +=nowcost;
        }
        return make_pair(totflow,totcost);
    }
    // special
    void output(int cost);
}mcmf;

int n,m,k,c,d;
inline int get_id(int u,int time){
    return (u-1) * (N+1) + time + 1;
}
int main(){
    cin>>n>>m>>k>>c>>d;
    vector<int> badguys(0);
    for (int i=0;i<k;i++){
        int x;cin>>x;
        badguys.push_back(x);
    }
    vector<tuple<int,int,int,int> > edges(0);
    for (int i=0;i<m;i++){
        int x,y;
        cin>>x>>y;
        for (int time = 0;time <N;time ++){
            int u = get_id(x,time);
            int v = get_id(y,time + 1);
            int uu = get_id(y,time);
            int vv = get_id(x,time + 1);
            for (int weight = 0;weight <=k;weight ++){
                int w = (weight * 2 + 1) * d;
                edges.push_back(make_tuple(u,v,1,w));
                edges.push_back(make_tuple(uu,vv,1,w));
            }
            edges.push_back(make_tuple(u,vv,1000000,0));
            edges.push_back(make_tuple(uu,v,1000000,0));
        }
    }
    int s = get_id(n,N) + 1;
    int t = s + 1;
    for (int guy : badguys){
        edges.push_back(make_tuple(s,get_id(guy,0),1,0));
    }
    for (int time = 0;time <=N;time ++){
        edges.push_back(make_tuple(get_id(1,time),t ,1000000, c * time));
    }
    mcmf.init(edges);
    pair<int,int> ans = mcmf.run(s,t);
    int flow,cost;
    tie(flow,cost) = ans;
    cout<<cost<<endl;
    return 0;
}