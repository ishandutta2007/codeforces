/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author RiaD
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <set>
#include <utility>
#include <cassert>
#include <map>
#include <queue>
//#define PROBLEM "problem_name.h"
//#include PROBLEM
//#include <message.h>
//#include <spcppl/dgcj.h>

using namespace std;

class TaskC {
public:
	void solve(std::istream& in, std::ostream& out) {
		//static int testnumber = 0;
		//out << "Case #" << ++testnumber << ": ";

		//for (int n = 10; n < 1000; ++n) {
		int n;
		in >> n;
			auto x = solve(n);
			for (auto y: x) {
				out << y.first << ' ' << y.second << "\n";
			}
			return;
			map<pair<int, int>, int> cnt;
			queue<pair<int, int>> q;

			int dx[] = {1, -1, 2, -2, 1, -1, 2, -2};
			int dy[] = {2, 2, 1, 1, -2, -2, -1, -1};

			for (auto y: x) {
				for (int i = 0; i < 8; ++i) {
					if (++cnt[{y.first + dx[i], y.second + dy[i]}] == 4) {
						//cerr << "push" << y.first << ' ' << y.second << endl;
						q.push({y.first + dx[i], y.second + dy[i]});
					}
				}
			}

			while (!q.empty()) {
				auto y = q.front();
				q.pop();
				if (x.count(y)) {
					continue;
				}
				x.insert(y);
				for (int i = 0; i < 8; ++i) {
					if (++cnt[{y.first + dx[i], y.second + dy[i]}] == 4) {
						q.push({y.first + dx[i], y.second + dy[i]});
					}
				}
			}

			cerr << n << ' ' << n * n / 10 << ' ' << x.size() << endl;
			assert(x.size() > n * n / 10);
			//return;
		//}
	}


	set<pair<int, int>> solve(int n) {
		set<pair<int, int>> res;

		for (int i = 0; res.size() < n; ++i) {
			if (i % 2 == 0) {
				res.insert({i, 0});
			} else {
				res.insert({i, 1});
				if (res.size() < n) {
					res.insert({i, -1});
				}
			}
		}
		return res;
	}
};


int main() {
	std::ios_base::sync_with_stdio(false);
	TaskC solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	in.tie(nullptr);
	out << std::fixed;
	out.precision(20);
	solver.solve(in, out);
	return 0;
}