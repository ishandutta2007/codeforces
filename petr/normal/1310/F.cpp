/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long int64;
typedef unsigned long long uint64;
typedef vector<int> vi;
typedef pair<int, int> ii;

class TaskF {
 public:
  uint64 multiply(uint64 a, uint64 b) {
    uint64 ans = 0;
    uint64 sb = b;
    while (a > 0) {
      uint64 p1 = ((a ^ (a - 1)) >> 1) + 1;
      a ^= p1;
      b = sb;
      while (b > 0) {
        uint64 p2 = ((b ^ (b - 1)) >> 1) + 1;
        b ^= p2;
        ans ^= multiply_powers_of_2(p1, p2);
      }
    }
    return ans;
  }

  vector<vector<uint64>> bitMul = vector<vector<uint64>>(64, vector<uint64>(64));

  uint64 quickMultiply(uint64 a, uint64 b) {
    uint64 res = 0;
    for (int i = 0; i < 64; ++i) {
      if ((a & (uint64(1) << i)) != 0) {
        for (int j = 0; j < 64; ++j) {
          if ((b & (uint64(1) << j)) != 0) {
            res ^= bitMul[i][j];
          }
        }
      }
    }
    return res;
  }

  uint64 multiply_powers_of_2(uint64 a, uint64 b) {
    if (a == 1) return b;
    if (b == 1) return a;
    int n = 0;
    while (n + 1 <= 5 && (uint64(1) << (1 << (n + 1))) <= max(a, b)) {
      ++n;
    }
    uint64 power = uint64(1) << (1 << n);
    if (a >= power and b >= power) {
      return multiply(power * 3 / 2, multiply_powers_of_2(a >> (1 << n), b >> (1 << n)));
    } else if (a >= power) {
      return multiply_powers_of_2(a >> (1 << n), b) << (1 << n);
    } else {
      return multiply_powers_of_2(a, b >> (1 << n)) << (1 << n);
    }
  }

  int degree(uint64 x, uint64 mask) {
    uint64 a = 1;
    int deg = 0;
    while (true) {
      a = quickMultiply(a, x);
      ++deg;
      if (a == 1) break;
    }
    return deg;
  }

  uint64 quickPow(uint64 x, uint64 k) {
    uint64 res = 1;
    while (k != 0) {
      if (k & 1) {
        res = quickMultiply(res, x);
      }
      k >>= 1;
      x = quickMultiply(x, x);
    }
    return res;
  }

  uint64 normalPow(uint64 a, uint64 k, uint64 m) {
    uint64 r = 1;
    while (k > 0) {
      if (k & 1) {
        r = r * a % m;
      }
      k >>= 1;
      a = a * a % m;
    }
    return r;
  }

  const int BUBEN = 10000;

  uint64 discreteLog(int w, uint64 a) {
    uint64 big = 1;
    uint64 bigPow = 0;
    while (true) {
      auto it = gpow[w].find(quickMultiply(big, a));
      if (it != gpow[w].end()) {
        uint64 res = (it->second + mod[w] - bigPow) % mod[w];
        return res;
      } else {
        bigPow += BUBEN;
        bigPow %= mod[w];
        big = quickMultiply(big, bigStep[w]);
      }
    }
  }

  vector<uint64> decompose(uint64 a) {
    vector<uint64> res(7);
    for (int i = 0; i < 7; ++i) {
      uint64 prod = 1;
      for (int j= 0; j < 7; ++j) if (i != j) prod *= mod[j];
      uint64 b = quickPow(a, prod);
      uint64 k = discreteLog(i, b);
      k = k * normalPow(prod % mod[i], mod[i] - 2, mod[i]) % mod[i];
      res[i] = k;
    }
    return res;
  }

  void solveOne(istream &in, ostream &out) {
    uint64 a;
    uint64 b;
    in >> a;
    in >> b;
    vector<uint64> da = decompose(a);
    vector<uint64> db = decompose(b);
    vector<uint64> r(7);
    for (int i = 0; i < 7; ++i) {
      if (da[i] == 0 && db[i] != 0) {
        out << -1 << "\n";
        return;
      }
      if (da[i] != 0) {
        r[i] = db[i] * normalPow(da[i], mod[i] - 2, mod[i]) % mod[i];
      }
    }
    uint64 res = 0;
    for (int i = 0; i < 7; ++i) {
      res = stupidAdd(res, stupidMul(r[i], units[i]));
    }
    assert(quickPow(a, res) == b);
    out << res << "\n";
  }

  uint64 stupidAdd(uint64 a, uint64 b) {
    uint64 s = a + b;
    uint64 big = (uint64) -1;
    if (a > big - b) {
      ++s;
    }
    if (s == big) s = 0;
    return s;
  }

  uint64 stupidMul(uint64 a, uint64 b) {
    uint64 r = 0;
    while (b > 0) {
      if (b & 1) {
        r = stupidAdd(r, a);
      }
      b >>= 1;
      a = stupidAdd(a, a);
    }
    return r;
  }

  vector<uint64> g = vector<uint64>(7);
  vector<uint64> mod = vector<uint64>(7);
  vector<unordered_map<uint64, uint64>> gpow = vector<unordered_map<uint64, uint64>>(7);
  vector<uint64> bigStep = vector<uint64>(7);
  vector<uint64> units = vector<uint64>(7);

  void solve(std::istream &in, std::ostream &out) {
    for (int i = 0; i < 64; ++i) {
      for (int j =0; j < 64; ++j) {
        bitMul[i][j] = multiply_powers_of_2(uint64(1) << i, uint64(1) << j);
      }
    }
    for (int n = 0; n <= 5; ++n) {
      uint64 chunk = uint64(1) << (1 << n);
      uint64 v = chunk;
      for (;;++v) {
        uint64 vv = quickPow(v, chunk - 1);
        if (vv == 1) continue;
        if (quickPow(vv, 641) == 1) continue;
        if (quickPow(vv, 6700417) == 1) continue;
        v = vv;
        assert(quickPow(v, chunk + 1) == 1);
        g[n] = v;
        break;
      }
      mod[n] = chunk + 1;
    }
    g[6] = quickPow(g[5], 641);
    g[5] = quickPow(g[5], 6700417);
    mod[5] = 641;
    mod[6] = 6700417;
    for (int i = 0; i < 7; ++i) {
      uint64 pw = 1;
      for (int j = 0; j < BUBEN; ++j) {
        gpow[i][pw] = j;
        pw = quickMultiply(pw, g[i]);
      }
      bigStep[i] = pw;
    }
    for (int i = 0; i < 7; ++i) {
      uint64 prod = 1;
      for (int j = 0; j < 7; ++j) if (i != j) {
        prod *= mod[j];
      }
      units[i] = prod * normalPow(prod % mod[i], mod[i] - 2, mod[i]);
    }
    int nt;
    in >> nt;
    for (int it = 0; it < nt; ++it) {
      solveOne(in, out);
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  TaskF solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}