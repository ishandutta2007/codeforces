/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <chrono>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

const int MODULO = 998244353;

using namespace std;

typedef long long int64;
typedef vector<int> vi;
typedef pair<int, int> ii;

class TaskG {
 public:
  void solveOne(istream &in, ostream &out) {
    int n;
    in >> n;
    vector<vector<ii>> a(n, vector<ii>(n));
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        int d;
        in >> d;
        a[i][j] = {d, j};
      }
      sort(all(a[i]));
    }

    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
    typedef mt19937_64::result_type hash;
    vector<hash> h(n);
    for (int i = 0; i < n; ++i) h[i] = rng();

    vector<hash> closest(n);
    vector<int> topmost(n, -1);
    vector<int> parent;
    vector<int> sizes;
    int blocks = 0;
    for (int size = 1; size <= n; ++size) {
      for (int i = 0; i < n; ++i) closest[i] += h[a[i][size - 1].second];
      vector<pair<hash, int>> have(n);
      for (int i = 0; i < n; ++i) have[i] = {closest[i], i};
      sort(all(have));
      for (int i = 0; i < n;) {
        int j = i;
        while (j < n && have[j].first == have[i].first) ++j;
        int count = j - i;
        assert(count <= size);
        if (count == size) {
          int maxInside = 0;
          int minOutside = (int) 1e9;
          for (int k = i; k < j; ++k) {
            maxInside = max(maxInside, a[have[k].second][size - 1].first);
            if (size < n) {
              minOutside = min(minOutside, a[have[k].second][size].first);
            }
          }
          if (maxInside < minOutside) {
            for (int k = i; k < j; ++k) {
              if (topmost[have[k].second] >= 0) {
                parent[topmost[have[k].second]] = blocks;
              }
              topmost[have[k].second] = blocks;
            }
            parent.push_back(-1);
            sizes.push_back(size);
            ++blocks;
          }
        }

        i = j;
      }
    }
    int root = blocks - 1;
    assert(sizes[root] == n);

    vector<vector<int>> poly(blocks, vector<int>(1, 1));
    for (int i = 0; i < blocks; ++i) {
      if (sizes[i] == 1) {
        poly[i].clear();
      }
      while (poly[i].size() < 2) {
        poly[i].push_back(0);
      }
      ++poly[i][1];
      poly[i][1] %= MODULO;
      if (parent[i] == -1) {
        assert(i == root);
      } else {
        poly[parent[i]] = mul(poly[parent[i]], poly[i]);
      }
    }

    assert(poly[root].size() == n + 1);
    for (int i = 1; i <= n; ++i) {
      out << poly[root][i] << " ";
    }
    out << "\n";
  }

  vector<int> mul(const vector<int>& a, const vector<int>& b) {
    vector<int> c(a.size() + b.size() - 1);
    for (int i = 0; i < a.size(); ++i) {
      for (int j = 0; j < b.size(); ++j) {
        c[i + j] = (c[i + j] + a[i] * (int64) b[j]) % MODULO;
      }
    }
    return c;
  }

  void solve(std::istream &in, std::ostream &out) {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne(in, out);
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  TaskG solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}