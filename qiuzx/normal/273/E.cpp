//ANMHLIJKTJIY!
#pragma GCC optimize(2)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline","fast-math","unroll-loops","no-stack-protector")
#pragma GCC diagnostic error "-fwhole-program"
#pragma GCC diagnostic error "-fcse-skip-blocks"
#pragma GCC diagnostic error "-funsafe-loop-optimizations"
#include <bits/stdc++.h>
#define INF 1000000000
#define LINF 1000000000000000000
#define mod 1000000007
#define F first
#define S second
#define ll long long
#define N 1010
using namespace std;
pair<ll,ll> cg[]={{1,0},{3,1},{4,2},{5,1},{7,2},{9,0},{13,1},{15,2},{19,0},{27,1},{39,2},{40,0},{57,2},{58,1},{81,2},{85,0},{120,2},{121,1},{174,2},{179,0},{255,2},{260,1},{363,2},{382,0},{537,2},{544,1},{780,2},{805,0},{1146,2},{1169,1},{1632,2},{1718,0},{2415,2},{2447,1},{3507,2},{3622,0},{5154,2},{5260,1},{7341,2},{7730,0},{10866,2},{11011,1},{15780,2},{16298,0},{23190,2},{23669,1},{33033,2},{34784,0},{48894,2},{49549,1},{71007,2},{73340,0},{104352,2},{106510,1},{148647,2},{156527,0},{220020,2},{222970,1},{319530,2},{330029,0},{469581,2},{479294,1},{668910,2},{704371,0},{990087,2},{1003364,1},{1437882,2},{1485130,0},{2113113,2},{2156822,1},{3010092,2},{3169669,0},{4455390,2},{4515137,1},{6470466,2},{6683084,0},{9509007,2},{9705698,1},{13545411,2},{14263510,0},{20049252,2},{20318116,1},{29117094,2},{30073877,0},{42790530,2},{43675640,1},{60954348,2},{64185794,0},{90221631,2},{91431521,1},{131026920,2},{135332446,0},{192557382,2},{196540379,1},{274294563,2},{288836072,0},{405997338,2},{411441844,1},{589621137,2},{608996006,0},{866508216,2},{884431705,1},{10000000000,0}};
ll cnt[3],n,p,dp[N][5];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	ll i,j;
	cin>>n>>p;
	for(i=0;;i++)
	{
		if(p<=cg[i+1].F)
		{
			cnt[cg[i].S]+=((p-cg[i].F+1)*(p-cg[i].F)/2)%mod;
			cnt[cg[i].S]%=mod;
			break;
		}
		cnt[cg[i].S]+=((p-(cg[i+1].F-1)+p-cg[i].F)*(cg[i+1].F-cg[i].F)/2)%mod;
		cnt[cg[i].S]%=mod;
	}
	dp[0][0]=1;
	for(i=1;i<=n;i++)
	{
		for(j=0;j<4;j++)
		{
			dp[i][j]=(dp[i][j]+dp[i-1][j]*cnt[0])%mod;
			dp[i][j^1]=(dp[i][j^1]+dp[i-1][j]*cnt[1])%mod;
			dp[i][j^2]=(dp[i][j^2]+dp[i-1][j]*cnt[2])%mod;
		}
	}
	cout<<(dp[n][1]+dp[n][2]+dp[n][3])%mod<<endl;
	return 0;
}