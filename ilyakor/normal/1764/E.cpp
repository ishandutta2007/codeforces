/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

class TaskF {
public:
	void solve(std::istream& in, std::ostream& out) {

//	    for (int it = 0; it < 100000; ++it) {
//	        int n = rand() % 7 + 1;
//	        vector<ii> v;
//	        for (int i = 0; i < n; ++i) {
//	            v.pb(ii(rand() % 100 + 1, rand() % 100 + 1));
//	        }
//            int64 res = solve(v);
//            int64 res0 = stupid(v);
//            if (res != res0) {
//                cerr << n << "\n";
//                for (int i = 0; i < n; ++i)
//                    cerr << v[i].first << " " << v[i].second << "\n";
//                cerr << res << " " << res0 << "\n";
//                stupid(v);
//            }
//            assert(res == res0);
//	    }

	    int n, k;
	    in >> n >> k;
	    vector<ii> v(n);
	    for (int i = 0; i < n; ++i)
	        in >> v[i].first >> v[i].second;
	    int64 res = solve(v);
	    if (res >= k) out << "YES\n";
	    else out << "NO\n";
	}

	int64 solve(vector<ii> v) {
	    int n = sz(v);
        rotate(v.begin(), v.begin() + 1, v.end());
        int64 res = v[n - 1].first;
        sort(v.begin(), v.begin() + (n - 1), [](const ii &x, const ii &y) {
            return min(x.first + x.second, y.first) + y.second > min(y.first + y.second, x.first) + x.second;
        });
        vector<Clamp> pref(n), suf(n);

        for (int i = 0; i < n; ++i) {
            pref[i] = Clamp(v[i]);
            suf[i] = pref[i];
        }
        for (int i = 1; i < n; ++i) {
            pref[i] = compose(pref[i - 1], pref[i]);
        }
        for (int i = n - 3; i >= 0; --i) {
            suf[i] = compose(suf[i], suf[i + 1]);
        }
        int I = 0;
        vi garbage;
        for (int i = 0; i < 300 && i < n - 1; ++i)
            garbage.pb(i);

        vi order;
        for (int i = 0; i < n - 1; ++i) {
            order.pb(i);
        }
        sort(all(order), [&](int x, int y) { return v[x].first < v[y].first; });
        for (int i = 0; i < 20 && i < n - 1; ++i)
            garbage.pb(order[i]);
        sort(all(order), [&](int x, int y) { return v[x].second < v[y].second; });
        for (int i = 0; i < 20 && i < n - 1; ++i)
            garbage.pb(order[i]);
        sort(all(order), [&](int x, int y) { return v[x].first > v[y].first; });
        for (int i = 0; i < 20 && i < n - 1; ++i)
            garbage.pb(order[i]);
        sort(all(order), [&](int x, int y) { return v[x].second > v[y].second; });
        for (int i = 0; i < 20 && i < n - 1; ++i)
            garbage.pb(order[i]);
        sort(all(order), [&](int x, int y) { return v[x].first + v[x].second < v[y].first + v[y].second; });
        for (int i = 0; i < 20 && i < n - 1; ++i)
            garbage.pb(order[i]);
        sort(all(order), [&](int x, int y) { return v[x].first + v[x].second > v[y].first + v[y].second; });
        for (int i = 0; i < 20 && i < n - 1; ++i)
            garbage.pb(order[i]);

        sort(all(garbage));
        garbage.erase(unique(all(garbage)), garbage.end());

        for (int i : garbage) {
            int x = v[i].first;
            if (i > 0) {
                int sx = x;
                for (int j = 0; j < i; ++j) {
                    sx = max(sx, max(v[j].first, min(sx, v[j].first) + v[j].second));
                }
//                x = pref[i - 1].apply(x);
                x = sx;
//                assert(sx == x);
            }
            if (i < n - 2) {
                int sx = x;
                for (int j = i + 1; j < n - 1; ++j) {
                    sx = max(sx, max(v[j].first, min(sx, v[j].first) + v[j].second));
                }
//                x = suf[i + 1].apply(x);
                x = sx;
//                assert(sx == x);
            }
            x = max(v[n - 1].first, min(x, v[n - 1].first) + v[n - 1].second);
            if (x > res) {
                res = x;
                I = i;
            }
        }
//        if (I > 3) {
//            cerr << "Opt: " << I << "\n";
//        }



//        auto V = v;
//        int64 M = -1;
//        int64 last = 0;
//        for (ii e : v) {
//            int64 cur;
//            if (M == -1) cur = e.first;
//            else cur = max<int64>(e.first, min<int64>(M, e.first) + e.second);
//            M = max(M, cur);
//            last = cur;
//        }
//        if (last > res) {
//            res = last;
//        }

//
//        int I = 0;
//        for (int i = 0; i < n - 1; ++i) {
//            if (v[i].second > v[I].second) I = i;
//        }
////        int I = 0;
//        for (int i = I; i < n - 1 && i < I + 1; ++i) {
//            v = V;
//            rotate(v.begin(), v.begin() + i, v.begin() + (n - 1));
//            sort(v.begin() + 1, v.begin() + (n - 1), [](const ii &x, const ii &y) {
//                return min(x.first + x.second, y.first) + y.second > min(y.first + y.second, x.first) + x.second;
//            });
//            int64 M = -1;
//            int64 last = 0;
//            for (ii e : v) {
//                int64 cur;
//                if (M == -1) cur = e.first;
//                else cur = max<int64>(e.first, min<int64>(M, e.first) + e.second);
//                M = max(M, cur);
//                last = cur;
//            }
//            if (last > res) {
//                res = last;
//                I = i;
//            }
//        }

        return res;
	}

    int64 stupid(vector<ii> v) {
	    ii p0 = v[0];
	    v.erase(v.begin());
        sort(all(v));
        int64 res = 0;
        do {
            int64 M = -1;
            for (ii e : v) {
                int64 cur;
                if (M == -1) cur = e.first;
                else cur = max<int64>(e.first, min<int64>(M, e.first) + e.second);
                M = max(M, cur);
            }
            int64 cur;
            if (M == -1) cur = p0.first;
            else cur = max<int64>(p0.first, min<int64>(M, p0.first) + p0.second);
            res = max(res, cur);
        } while (next_permutation(all(v)));
        return res;
    }

    struct Clamp {
	    int l, r, c;

        Clamp() {}
	    Clamp(ii e) {
	        l = e.first - e.second;
	        r = e.first;
	        c = e.second;
	    }

	    int apply(int x) {
	        x = min(x, r);
	        x = max(x, l);
	        x += c;
	        return x;
	    }
	};

	Clamp compose(Clamp a, Clamp b) {
	    int l1 = a.l, r1 = a.r;
	    b.l -= a.c;
	    b.r -= a.c;
	    b.c += a.c;
	    l1 = min(l1, b.r);
	    b.l = max(b.l, l1);
	    b.r = min(b.r, r1);
	    return b;
	}

};


int main() {
	TaskF solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	int n;
in >> n;
for(int i = 0; i < n; ++i) {
	solver.solve(in, out);
}

	return 0;
}