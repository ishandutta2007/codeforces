/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#undef NDEBUG

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
// AtCoder library from https://github.com/atcoder/ac-library
// #include "../atcoder/fenwicktree"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

constexpr int64 INF = (int64) 1e18;

struct Case {
  int n;
  int k;
  int index;
};

class DArtisticPartition {
 public:
  void solveOne() {
    int nt;
    cin >> nt;
    vector<Case> cases(nt);
    for (int i = 0; i < nt; ++i) {
      cin >> cases[i].n >> cases[i].k;
      cases[i].index = i;
    }
    vector<int64> answers(nt);
    sort(all(cases), [](const auto& a, const auto& b) {
      return a.n < b.n;
    });
    int maxn = max(2, cases.back().n);
    vector<int> d(maxn + 1);
    for (int i = 2; i <= maxn; ++i) {
      if (d[i] == 0) {
        d[i] = i;
        for (int j = 2 * i; j <= maxn; j += i) if (d[j] == 0) d[j] = i;
      }
    }
    vector<int> phi(maxn + 1);
    phi[1] = 1;
    for (int i = 2; i <= maxn; ++i) {
      int by = d[i];
      int cur = i / by;
      int mul = by - 1;
      while (cur % by == 0) {
        cur /= by;
        mul *= by;
      }
      phi[i] = phi[cur] * mul;
    }
    vector<vector<int>> divisors(maxn + 1);
    for (int i = 1; i <= maxn; ++i) {
      for (int j = i; j <= maxn; j += i) {
        divisors[j].push_back(i);
      }
    }
    int maxk = 20;
    vector<vector<int64>> best(maxk + 1, vector<int64>(maxn + 1, INF));
    best[0][0] = 0;
    vector<int64> penalty(maxn + 1);

    for (int k = 1; k <= maxk; ++k) {
      auto rec = [&](auto self, int leftn, int rightn, int leftm, int rightm, int64 penaltyAfter) {
        if (leftn > rightn) return;
        int midn = (leftn + rightn) / 2;
        for (int n = leftn; n <= midn; ++n) {
          for (int g : divisors[n]) {
            int64 times = phi[n / g];
            if (g < leftm) {
              // do nothing
            } else if (g > rightm) {
              penaltyAfter += times;
            } else {
              penalty[g] += times;
            }
          }
        }
        int bestm = -1;
        int64 sofar = penaltyAfter;
        for (int prev = rightm; prev >= leftm; --prev) {
          if (prev < midn) {
            int64 cur = best[k - 1][prev] + sofar;
            if (cur < best[k][midn]) {
              best[k][midn] = cur;
              bestm = prev;
            }
          }
          sofar += penalty[prev];
        }
        if (bestm == -1) bestm = leftm;
        self(self, midn + 1, rightn, bestm, rightm, penaltyAfter);
        for (int n = leftn; n <= midn; ++n) {
          for (int g : divisors[n]) {
            int64 times = phi[n / g];
            if (g < leftm) {
              // do nothing
            } else if (g > rightm) {
              penaltyAfter -= times;
            } else {
              penalty[g] -= times;
            }
          }
        }
        for (int i = rightm; i > bestm; --i) {
          penaltyAfter += penalty[i];
        }
        self(self, leftn, midn - 1, leftm, bestm, penaltyAfter);
      };

      rec(rec, 1, maxn, 0, maxn, 0);
    }

    int ptr = 0;
    while (ptr < cases.size()) {
      int64 res = best[min(maxk, cases[ptr].k)][cases[ptr].n];
      answers[cases[ptr].index] = res;
      ++ptr;
    }
    for (auto x : answers) cout << x << "\n";
  }

  void solve() {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne();
    }
  }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    DArtisticPartition solver;


    solver.solve();
    return 0;
}