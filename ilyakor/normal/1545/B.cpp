/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

constexpr int mod = 998244353;

class TaskB {
public:
	void solve(std::istream& in, std::ostream& out) {
//	    vector<string> cand = {"1111000", "1110100", "1110010", "1110001", "1101100", "1101010",
//                               "1011100", "1011001",
//                               "11111000000", "11110100000", "11110000001", "11100110000", "01110110000", "10110010100",
//                               "11100101000", "11001101000", "00111101000", "11110001000", "11110000100", "11110000010",
//                               "10100110001"};
//	    for (string s : cand) {
//	        int k = 0;
//	        for (char c : s) if (c == '1') ++k;
//            vector<int64> f(100);
//            f[0] = 1;
//            for (int i = 1; i <= sz(f) - 1; ++i)
//                f[i] = (f[i - 1] * (int64) i) % mod;
//	        int64 val = calc(s);
//	        int N = -1, K = -1;
//	        for (int i = 0; i < sz(s) && N == -1; ++i)
//	            for (int j = 0; j <= k && N == -1; ++j) {
//	                int64 cur = f[i];
//	                cur *= pow(f[j], mod - 2, mod);
//	                cur %= mod;
//                    cur *= pow(f[i - j], mod - 2, mod);
//                    cur %= mod;
//                    if (cur == val) {
//                        N = i;
//                        K = j;
//                    }
//	            }
//	        cerr << s << " " << val << " " << N << " " << K << "\n";
//	    }
//	    cerr << "#\t";
//        for (int k = 2; k <= 20; ++k) {
//            cerr << k << "\t";
//        }
//        cerr << "\t";
//        for (int it = 0; it < 100; ++it) {
//            for (int n = 2; n <= 20; ++n) {
////            cerr << n << ":\t";
//                for (int k = 2; k <= n; ++k) {
//                    string s;
//                    for (int i = 0; i < k; ++i)
//                        s += '1';
//                    for (int i = 0; i < n - k; ++i)
//                        s += '0';
//                    random_shuffle(all(s));
//                    //cerr << calc(s) << "\t";
//                    if (calc(s) != smart(s)) {
//                        cerr << "WTF " << s << "\n";
//                        exit(57);
//                    }
//                }
//                //cerr << "\n";
//            }
//        }

        string s;
        int unused;
        in >> unused >> s;

        out << smart(s) << "\n";
        //out << calc(s) << "\n";
	}

	int64 smart(string s) {
        bool ok = false;
        int k = 0;
        for (int i = 0; i < sz(s); ++i) {
            if (s[i] == '1') ++k;
        }
        int n = sz(s);
        for (int i = 0; i + 1 < sz(s); ++i) {
            if (s[i] == '1' && s[i + 1] == '1') ok = true;
        }
        //cerr << ok << " " << n << " " << k << "\n";
        if (!ok || n == k) {
            return 1;
        }
        int dec = 0;
        int cur = 0;
        for (int i = 0; i < sz(s); ++i) {
            if (s[i] == '1') ++cur;
            else {
                dec += cur % 2;
                cur = 0;
            }
        }
        dec += cur % 2;

        // k >= 2
        int N = n - (k + dec) / 2;
        int K = (k - dec) / 2;
        //cerr << n << " " << k << " " << N << " " << K << "\n";
        vector<int64> f(N + 1);
        f[0] = 1;
        for (int i = 1; i <= N; ++i)
            f[i] = (f[i - 1] * (int64) i) % mod;
        int64 res = f[N];
        res *= pow(f[K], mod - 2, mod);
        res %= mod;
        res *= pow(f[N - K], mod - 2, mod);
        res %= mod;
        return res;
	}

	int64 pow(int64 x, int64 y, int mod) {
	    int64 res = 1;
	    while (y) {
	        if (y % 2) {
	            --y;
	            res = (res * x) % mod;
	        } else {
	            y /= 2;
	            x = (x * x) % mod;
	        }
	    }
	    return res;
	}

	set<string> d;
	int calc(string s) {
	    d.clear();
	    dfs(s);
	    return sz(d);
	}

	void dfs(string s) {
	    d.insert(s);
	    for (int i = 0 ;i + 2 < sz(s); ++i) {
	        if (s[i] == '1' && s[i + 1] == '1' && s[i + 2] == '0') {
	            string t = s;
	            t[i] = '0';
	            t[i + 2] = '1';
	            if (!d.count(t)) dfs(t);
	        }
	    }
        for (int i = 0; i + 2 < sz(s); ++i) {
            if (s[i] == '0' && s[i + 1] == '1' && s[i + 2] == '1') {
                string t = s;
                t[i] = '1';
                t[i + 2] = '0';
                if (!d.count(t)) dfs(t);
            }
        }
	}
};


int main() {
	TaskB solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	int n;
in >> n;
for(int i = 0; i < n; ++i) {
	solver.solve(in, out);
}

	return 0;
}