/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long int64;
typedef vector<int> vi;
typedef pair<int, int> ii;

class TaskF {
 public:
  int n;
  vector<vector<int>> adj;
  vector<int> res;
  vector<int> depth1;
  vector<int> d1via;
  vector<int> depth2;
  vector<int> maxUp;
  vector<vector<int>> childDepths;
  vector<int> p;

  void dfs1(int root, int parent) {
    p[root] = parent;
    for (int x : adj[root]) {
      if (x == parent) continue;
      dfs1(x, root);
      childDepths[root].push_back(1 + depth1[x]);
      if (1 + depth1[x] > depth1[root]) {
        depth2[root] = depth1[root];
        depth1[root] = 1 + depth1[x];
        d1via[root] = x;
      } else if (1 + depth1[x] > depth2[root]) {
        depth2[root] = 1 + depth1[x];
      }
    }
    sort(childDepths[root].begin(), childDepths[root].end());
    reverse(childDepths[root].begin(), childDepths[root].end());
  }

  void dfs2(int root, int parent) {
    if (parent < 0)
      maxUp[root] = 0;
    else {
      maxUp[root] = 1 + maxUp[parent];
      if (root == d1via[parent]) {
        maxUp[root] = max(maxUp[root], 1 + depth2[parent]);
      } else {
        maxUp[root] = max(maxUp[root], 1 + depth1[parent]);
      }
    }

    for (int x : adj[root]) {
      if (x == parent) continue;
      dfs2(x, root);
    }
  }
  int insertionPosition(int d, const vector<int>& depths) {
    int left = -1;
    int right = depths.size();
    while (right - left > 1) {
      int middle = (left + right) / 2;
      if (depths[middle] <= d) {
        right = middle;
      } else {
        left = middle;
      }
    }
    return right;
  }

  void stress() {
    mt19937 rng;
    while (true) {
      n = uniform_int_distribution<int>(1, 10)(rng);
      adj = vector<vector<int>>(n);
      for (int i = 1; i < n; ++i) {
        int j = uniform_int_distribution<int>(0, i - 1)(rng);
        adj[i].push_back(j);
        adj[j].push_back(i);
      }
      innerSolve();
      stupid();
      for (int i = 1; i <= n; ++i) if (res[i] != resStupid[i]) {
        for (int i = 0; i < n; ++i) {
          for (int j : adj[i]) {
            if (j < i) {
              cout << i << " " << j << endl;
            }
          }
        }
        for (int i = 1; i <= n; ++i) {
          cout << i << " " << res[i] << " " << resStupid[i] << endl;
        }
        innerSolve();
        assert(false);
      }
    }
  }

  vector<int> resStupid;

  void stupid() {
    resStupid = vector<int>(n + 1, 1);
    vector<vector<int>> d(n, vector<int>(n, n));
    for (int i = 0; i < n; ++i) {
      d[i][i] = 0;
      for (int j : adj[i]) d[i][j] = 1;
    }
    for (int k = 0; k < n; ++k) {
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
          d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
        }
      }
    }
    for (int set = 1; set < (1 << n); ++set) {
      if ((set & (set - 1)) == 0) continue;
      int mn = n;
      int mx = 0;
      int cnt = 0;
      for (int i =0 ; i < n ;++i) if ((set & (1 << i)) != 0) {
        ++cnt;
        for (int j = 0; j < i; ++j) if ((set & (1 << j)) != 0) {
          mn = min(mn, d[i][j]);
          mx = max(mx, d[i][j]);
        }
      }
      if (mx == mn) {
        resStupid[mx] = max(resStupid[mx], cnt);
        resStupid[mx - 1] = max(resStupid[mx - 1], cnt);
      } else if (mx == mn + 1) {
        resStupid[mn] = max(resStupid[mn], cnt);
      }
    }
  }

  void solve(std::istream &in, std::ostream &out) {
    //stress();
    in >> n;
    adj = vector<vector<int>>(n);
    for (int i =0 ; i < n - 1; ++i) {
      int a;
      int b;
      in  >> a >> b;
      --a;
      --b;
      adj[a].push_back(b);
      adj[b].push_back(a);
    }

    innerSolve();

    for (int i = 1; i <= n; ++i) {
      out << res[i] << " ";
    }
    out << "\n";
  }

  void innerSolve() {
    res = vector<int>(2 * n + 1, 1);
    for (int i = 0; i < n; ++i) {
      res[1] = max(res[1], int(1 + adj[i].size()));
    }
    maxUp = vector<int>(n, 0);
    d1via = vector<int>(n, -1);
    depth1 = vector<int>(n, 0);
    depth2 = vector<int>(n, 0);
    childDepths = vector<vector<int>>(n);
    p = vector<int>(n, -1);
    dfs1(0, -1);
    dfs2(0, -1);
    vector<int> depths;
    vector<int> maxBefore;
    for (int i = 0; i < n; ++i) {
      depths.clear();
      for (int x : adj[i]) {
        if (x != p[i]) {
          depths.push_back(1 + depth1[x]);
        }
      }
      if (p[i] >= 0) {
        depths.push_back(maxUp[i]);
      }
      sort(depths.begin(), depths.end());
      reverse(depths.begin(), depths.end());
      maxBefore.clear();
      maxBefore.resize(depths.size() + 1);
      for (int j : adj[i]) {
        if (j == p[i]) continue;
        int skip = insertionPosition(1 + depth1[j], depths);
        int cntBefore = 0;
        for (int d : childDepths[j]) {
          ++cntBefore;
          int where = insertionPosition(d - 1, depths);
          maxBefore[where] = max(maxBefore[where], cntBefore - 1);
          int realPos = where;
          if (realPos > skip) {
            --realPos;
          } else {
            assert(false);
          }
          realPos += cntBefore;
          res[2 * d] = max(res[2 * d], realPos);
        }
      }
      for (int i = 0; i + 1 < maxBefore.size(); ++i) {
        maxBefore[i + 1] = max(maxBefore[i + 1], maxBefore[i]);
      }
      for (int take = 2; take <= depths.size(); ++take) {
        res[2 * depths[take - 1]] = max(res[2 * depths[take - 1]], take + maxBefore[take - 1]);
        res[2 * depths[take - 1] - 1] = max(res[2 * depths[take - 1] - 1], take);
        if (depths[take - 2] > depths[take - 1]) {
          res[2 * depths[take - 1] + 1] = max(res[2 * depths[take - 1] + 1], take);
        }
      }
    }

    for (int i = res.size() - 3; i >= 2; --i) {
      res[i] = max(res[i], res[i + 2]);
    }

  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  TaskF solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}