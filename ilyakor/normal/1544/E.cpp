/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

class TaskE {
public:
	void solve(std::istream& in, std::ostream& out) {
//	    for (int it = 0; it < 1000000; ++it) {
//	        int n = rand() % 6 + 2;
//	        int k = rand() % 3 + 1;
//	        string s;
//	        for (int i = 0; i < n; ++i)
//	            s += (char)('a' + rand() % k);
//	        if (sz(set<char>(all(s))) <= 1) continue;
//	        //int val = stupid(s);
//	        int val = pref(doSolve(s));
//	        if (val > 1) cerr << it << " " << s << " " << val << "\n";
//	    }
        string s;
        in >> s;
        out << doSolve(s) << "\n";
	}

	string doSolve(string s) {
        vi cnt(26, 0);
        for (char c : s) {
            cnt[c - 'a']++;
        }
        int distinct = 0;
        int uniq = -1;
        for (int i = 0; i < sz(cnt); ++i) {
            if (cnt[i] > 0) ++distinct;
            if (cnt[i] == 1 && uniq == -1) {
                uniq = i;
            }
        }
        if (distinct <= 1) {
            return s;
        }
        if (uniq != -1) {
            string res;
            res += (char)(uniq + 'a');
            --cnt[uniq];
            for (int i = 0; i < sz(cnt); ++i) {
                while (cnt[i]) {
                    res += (char)(i + 'a');
                    --cnt[i];
                }
            }
            return res;
        }
        // Now answer is always 1.
        string res;
        int ca = 0;
        while (cnt[ca] == 0) ++ca;
        res += (char) (ca + 'a');
        --cnt[ca];
        int remaining = 0;
        for (int i = 0; i < sz(cnt); ++i) if (i != ca)
                remaining += cnt[i];
        if (cnt[ca] - 1 <= remaining) {
            // AA
            res += (char)(ca + 'a');
            --cnt[ca];
            string other;
            for (int i = 0; i < sz(cnt); ++i) if (i != ca) {
                    for (int j = 0; j < cnt[i]; ++j)
                        other += (char)(i + 'a');
                }
            for (int i = 0; i < sz(other); ++i) {
                res += other[i];
                if (cnt[ca] > 0) {
                    --cnt[ca];
                    res += (char)(ca + 'a');
                }
            }
            assert(sz(res) == sz(s));
            assert(pref(res) == 1);
            return res;
        }
        // AB
        int cb = ca + 1;
        while (cb < sz(cnt) && cnt[cb] == 0) ++cb;
        assert(cb < sz(cnt));
        res += (char)(cb + 'a');
        --cnt[cb];

        int cc = cb + 1;
        while (cc < sz(cnt) && cnt[cc] == 0) ++cc;
        if (cc >= sz(cnt)) {
            // No other chars, we're forced to do ABBBBAAAAA
            while (cnt[cb] > 0) {
                res += (char)(cb + 'a');
                --cnt[cb];
            }
            while (cnt[ca] > 0) {
                res += (char)(ca + 'a');
                --cnt[ca];
            }
            assert(sz(res) == sz(s));
            assert(pref(res) == 1);
            return res;
        }
        // ABAAAAAC....
        while (cnt[ca] > 0) {
            res += (char)(ca + 'a');
            --cnt[ca];
        }
        res += (char)(cc + 'a');
        --cnt[cc];
        for (int i = 0; i < sz(cnt); ++i) {
            for (int j = 0; j < cnt[i]; ++j)
                res += (char)(i + 'a');
        }
        assert(sz(res) == sz(s));
        assert(pref(res) == 1);
        return res;
	}

	int stupid(string s) {
	    sort(all(s));
	    int res = sz(s);
	    do {
	        res = min(res, pref(s));
	        if (res == 1) break;
	    } while (next_permutation(all(s)));
	    return res;
	}

	int pref(string s) {
        int n = (int) s.length();
        vector<int> pi (n);
        for (int i=1; i<n; ++i) {
            int j = pi[i-1];
            while (j > 0 && s[i] != s[j])
                j = pi[j-1];
            if (s[i] == s[j])  ++j;
            pi[i] = j;
        }
        int res = 0;
        for (int x : pi) res = max(res, x);
        return res;
	}
};


int main() {
	TaskE solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	int n;
in >> n;
for(int i = 0; i < n; ++i) {
	solver.solve(in, out);
}

	return 0;
}