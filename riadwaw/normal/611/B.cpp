/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author RiaD
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <assert.h>
#include <vector>
#include <type_traits>

template <typename T, size_t N>
struct MakeVector {
	template <
			typename... Args,
			typename R = std::vector<decltype(MakeVector<T, N - 1>::make_vector(std::declval<Args>()...))>
	>
	static R make_vector(std::size_t first, Args... sizes) {
		auto inner = MakeVector<T, N - 1>::make_vector(sizes...);
		return R(first, inner);
	}
};

template <typename T>
struct MakeVector<T, 1> {
	/*
	 * This template is to fool CLion.
	 * Without it CLion thinks that make_vector always returns std::vector<T> and marks code like
	 *
	 * auto dp = make_vector<int>(n, m, 0);
	 * dp[0][0] = 1 as error because it suppose that dp[0] is int
	 *
	 * TODO: Consider removing it once https://youtrack.jetbrains.com/issue/CPP-3340 is fixed
	 */
	template <typename R = std::vector<T>>
	static R make_vector(std::size_t size, const T& value) {
		return R(size, value);
	}
};

template <typename T, typename... Args>
auto make_vector(Args... args) -> decltype(MakeVector<T, sizeof...(Args) - 1>::make_vector(args...)) {
	return MakeVector<T, sizeof...(Args) - 1>::make_vector(args...);
}


using namespace std;

class TaskB {
public:
	void solve(std::istream& in, std::ostream& out) {
		long long a, b;
		in >> a >> b;
		out << solve(b) - solve(a - 1);
	}
	long long solve(long long n) {
		auto dp = make_vector<long long>(61, 2, 2, 2, 0LL);
		dp[60][0][0][1] = 1;
		for (int i = 59; i >= 0; --i) {
			for(int started = 0; started < 2; ++started) {
				for (int cnt = 0; cnt < 2; ++cnt) {
					for (int wasSame = 0; wasSame < 2; ++wasSame) {
						if (dp[i + 1][started][cnt][wasSame] == 0)
							continue;
						for (int st = 0; st < 2; ++st) {
							if (st && (n & (1LL << i)) == 0 && wasSame == 1) {
								continue;
							}
							int newStarted = started || st;
							int newCnt = cnt + (st == 0);
							if(!newStarted) {
								newCnt = 0;
							}
							if (newCnt >= 2)
								continue;
							int newWasSame = wasSame && ((n >> i) & 1) == st;
							dp[i][newStarted][newCnt][newWasSame] += dp[i + 1][started][cnt][wasSame];
							//cerr << i << ' ' << newCnt << ' ' << newWasSame << ' ' << endl;
						}
					}
				}
			}
		}
		if (n == 0) {
			assert(dp[0][1][1][0] + dp[0][1][1][1] == 0);
		}
		return dp[0][1][1][0] + dp[0][1][1][1];
	}
};


int main() {
	std::ios_base::sync_with_stdio(false);
	TaskB solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	in.tie(0);
	out << std::fixed;
	out.precision(20);
	solver.solve(in, out);
	return 0;
}