/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-09-01 10:14:03
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<int, int> pii;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 2e5 + 10;
const ll LOG = 22;
const ll SQ = 120;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

int n , q , c[26] , F[MAXN] , rnk[MAXN] , ans[MAXN];
string s , S;
vector<int> vec[MAXN] , pos[26];
vector<pair<pii , int>> Q[MAXN];

int solve(string s , string t , int k){
	vector<int> res;
	int m = SZ(t);
	for(int i = 1 , k = 0 ; i < m ; i++){
		while(k && t[i] != t[k])	k = F[k - 1];
		if(t[i] == t[k])	k++;
		F[i] = k;
	}
	for(int i = 0 , k = 0 ; i < n ; i++){
		while(k && s[i] != t[k])	k = F[k - 1];
		if(s[i] == t[k])	k++;
		if(k == m){
			res.push_back(i);
			k = F[k - 1];
		}
	}
	if(SZ(res) < k)	return -1;
	int ans = MOD;
	for(int i = k - 1 ; i < SZ(res) ; i++){
		ans = min(ans , res[i] - (res[i - k + 1] - m));
	}
	return ans;
}

int main() {
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

	cin >> s >> q;
	n = SZ(s); S = s;
	for(int i = 0 ; i < q ; i++){
		int k;
		string t;
		cin >> k >> t;
		if(SZ(t) > SZ(s))	ans[i] = -1;
		else if(SZ(t) > SQ)	ans[i] = solve(s , t , k);
		else{
			Q[SZ(t)].push_back({{SZ(S) , i} , k});
			S += t;
		}
	}
	s = S;
	for(int i = 0 ; i < SZ(s) ; i++)	pos[s[i] - 97].push_back(i);
	//cout << s << endl;
	for(int i = 1 ; i <= SQ ; i++){
		for(int j = 0 ; j < 26 ; j++){
			for(int k : pos[j]){
				if(k < i - 1)	continue;
				vec[rnk[k - i + 1]].push_back(k - i + 1);
			}
		}
		int ind = 0;
		vector<int> x;
	//	cout << s << endl;
		for(int j = 0 ; j < MAXN ; j++){
			x = {};
			for(int k : vec[j]){
				int val = s[k + i - 1] - 97;
	//			cout << val << endl;
	//			cout << j << sep << k << sep << val << endl;
				//cout << j << sep << k << sep << s[k + i - 1] << endl;
				c[val]++;
				if(c[val] == 1)	rnk[k] = ++ind;
				else	rnk[k] = ind;
			}
			for(int k : vec[j])	c[s[k + i - 1] - 97] = 0;
			vec[j] = {};
		}
	//	for(int j = 0 ; j + i <= SZ(S) ; j++){
	//		cout << rnk[j] << sep;
	//	}
	//	if(i < 10)	cout << endl << "********************\n";
		for(int j = 0 ; j + i <= SZ(s) ; j++)	vec[rnk[j]].push_back(j);
		for(pair<pii , int> j : Q[i]){
			int st = j.X.X , ind = j.X.Y , kk = j.Y;
			int res = MOD;
	//		cout << st << sep << ind << sep << kk << sep << rnk[st] << endl;
	//		cout << SZ(vec[rnk[st]]) << endl;
			for(int k = kk - 1 ; k < SZ(vec[rnk[st]]) ; k++){
				if(vec[rnk[st]][k] + i > n)	break;
				res = min(res , vec[rnk[st]][k] - vec[rnk[st]][k - kk + 1] + i);
	//			cout << vec[rnk[st]][k] << sep << vec[rnk[st]][k - kk + 1] << endl;
			}
			ans[ind] = (res == MOD ? -1 : res);
	//		cout << endl;
		}
		for(int j = 0 ; j < MAXN ; j++)	vec[j] = {};
	}

	for(int i = 0 ; i < q ; i++)	cout << ans[i] << endl;

    return 0;
}
/*

*/