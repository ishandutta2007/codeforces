/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-04-01 14:57:37
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 1e5 + 10;
const ll SQ = 320;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll n , q , timer , res , ans[MAXN] , M[MAXN] , cnt[2][MAXN] , mark[MAXN] , V[MAXN] , U[MAXN] , st[MAXN] , fn[MAXN] , A[MAXN] , F[MAXN] , H[MAXN] , par[LOG][MAXN];
vector<ll> compress , vec , adj[MAXN];
vector<pair<pll , ll>> Q;

void DFS(ll v , ll p = 0){
    H[v] = H[p] + 1;
    par[0][v] = p;
    st[v] = timer++;
    vec.push_back(v);
    for(ll u : adj[v])  if(u != p)  DFS(u , v);
    fn[v] = timer++;
    vec.push_back(v);
}

ll getPar(ll v , ll h){
    for(ll i = 0 ; i < LOG ; i++)   if(h & (1 << i))    v = par[i][v];
    return v;
}

ll LCA(ll v , ll u){
    if(H[v] > H[u]) swap(v , u);
    u = getPar(u , H[u] - H[v]);
    if(v == u)  return v;
    for(ll i = LOG - 1 ; i >= 0 ; i--)  if(par[i][v] != par[i][u])  v = par[i][v] , u = par[i][u];
    return par[0][v];
}

ll cmp(pair<pll , ll> A , pair<pll , ll> B){
    if(A.X.X / SQ != B.X.X / SQ)    return A.X.X < B.X.X;
    return (A.X.X / SQ % 2 == 0 ? A.X.Y < B.X.Y : A.X.Y > B.X.Y);
}

void insert(ll x){
    x = vec[x];
//    cout << "insert " << x << sep;
    res += cnt[1 - A[x]][F[x]];
    cnt[A[x]][F[x]]++;
    M[x] = 1 - M[x];
//    cout << res << endl;
}

void remove(ll x){
    x = vec[x];
//    cout << "remove " << x << sep;
    res -= cnt[1 - A[x]][F[x]];
    cnt[A[x]][F[x]]--;
    M[x] = 1 - M[x];
//    cout << res << endl;
}

int main() {
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    cin >> n;
    for(ll i = 1 ; i <= n ; i++)    cin >> A[i];
    for(ll i = 1 ; i <= n ; i++)    cin >> F[i] , compress.push_back(F[i]);
    for(ll i = 1 ; i < n ; i++){
        ll v , u;
        cin >> v >> u;
        adj[v].push_back(u);
        adj[u].push_back(v);
    }
    DFS(1);
    sort(all(compress));
    compress.resize(unique(all(compress)) - compress.begin());
    for(ll i = 1 ; i <= n ; i++)    F[i] = lower_bound(all(compress) , F[i]) - compress.begin();
    for(ll i = 1 ; i < LOG ; i++)   for(ll j = 0 ; j <= n ; j++)    par[i][j] = par[i - 1][par[i - 1][j]];
    
    cin >> q;
//    for(ll i : vec) cout << i << sep;
//    cout << endl;
    for(ll i = 0 ; i < q ; i++){
        cin >> V[i] >> U[i];
        if(st[V[i]] > st[U[i]]) swap(V[i] , U[i]);
        ll lca = LCA(V[i] , U[i]);
        if(lca == V[i]){
            mark[i] = 1;
            Q.push_back({{st[V[i]] , st[U[i]]} , i});
        }
        else    Q.push_back({{fn[V[i]] , st[U[i]]} , i});
//        cout << "V U LCA Query" << endl;
//        cout << V[i] << sep << U[i] << sep << lca << sep << Q.back().X.X << sep << Q.back().X.Y << sep << Q.back().Y << endl;
    }

    sort(all(Q) , cmp);
    
    ll L = 0 , R = -1;
    for(pair<pll , ll> i : Q){
        while(R < i.X.Y)    if(!M[vec[++R]])    insert(R);  else    remove(R);
        while(R > i.X.Y)    if(!M[vec[R]])      insert(R--);else    remove(R--);
        while(L < i.X.X)    if(!M[vec[L]])      insert(L++);else    remove(L++);
        while(L > i.X.X)    if(!M[vec[--L]])    insert(L);  else    remove(L);
        ll lca = LCA(V[i.Y] , U[i.Y]);
        ans[i.Y] = res + (1 - mark[i.Y]) * cnt[1 - A[lca]][F[lca]];
//        cout << "Query" << sep << "V U ANS" << endl;
//        cout << i.X.X << sep << i.X.Y << sep << i.Y << sep << V[i.Y] << sep << U[i.Y] << sep << ans[i.Y] << endl; 
    }
    for(ll i = 0 ; i < q ; i++) cout << ans[i] << endl;

    return 0;
}
/*

*/