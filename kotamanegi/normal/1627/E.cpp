#include "bits/stdc++.h"
using namespace std;

typedef string::const_iterator State;
#define eps 1e-8L
#define MAX_MOD 1000000007LL
#define GYAKU 500000004LL
#define MOD 998244353LL
#define pb push_back
#define mp make_pair
typedef long long ll;
typedef long double ld;
#define REP(a, b) for (long long(a) = 0; (a) < (b); ++(a))
#define ALL(x) (x).begin(), (x).end()

#define int long long
vector<tuple<int, pair<int, int>, int>> chairs[200000];
vector<int> dp[200000];
void solve()
{
  int n, m, k;
  cin >> n >> m >> k;
  vector<int> X;
  REP(i, n)
  {
    int a;
    cin >> a;
    X.push_back(a);
    chairs[i].clear();
    dp[i].clear();
  }
  chairs[n].clear();
  dp[n].clear();
  REP(i, k)
  {
    int a, b, c, d, h;
    cin >> a >> b >> c >> d >> h;
    chairs[a - 1].push_back({b, {c-1, d}, -h});
    dp[a - 1].push_back(1e18);
  }
  chairs[n - 1].push_back({m, {n, 1}, 0});
  dp[n - 1].push_back(1e18);
  REP(i, n)
  {
    sort(ALL(chairs[i]));
  }
  REP(i,chairs[0].size()){
    dp[0][i] = abs(get<0>(chairs[0][i]) - 1) * X[0];
  }
  REP(i,n){
    for (int q = 0; q < (int)chairs[i].size()-1;++q){
      int next_cost = dp[i][q];
      next_cost += X[i] * abs(get<0>(chairs[i][q]) - get<0>(chairs[i][q + 1]));
      dp[i][q + 1] = min(dp[i][q + 1], next_cost);
    }
    for (int q = (int)chairs[i].size() - 1; q >= 1; --q)
    {
      int next_cost = dp[i][q];
      next_cost += X[i] * abs(get<0>(chairs[i][q]) - get<0>(chairs[i][q - 1]));
      dp[i][q - 1] = min(dp[i][q - 1], next_cost);
    }
    REP(q, chairs[i].size())
    {
      if(dp[i][q] == 1e18)
        continue;
      int next_go = get<2>(chairs[i][q]) + dp[i][q];
      pair<int, int> targetDist = get<1>(chairs[i][q]);
      tuple<int, pair<int, int>, int> A = {targetDist.second, {-1, -1}, -1};
      int x = lower_bound(ALL(chairs[targetDist.first]), A) - chairs[targetDist.first].begin();
      if (x < chairs[targetDist.first].size())
      {
        int now_go = next_go + abs(targetDist.second - get<0>(chairs[targetDist.first][x])) * X[targetDist.first];
        dp[targetDist.first][x] = min(dp[targetDist.first][x], now_go);
      }
      x--;
      if(x >= 0){
        int now_go = next_go + abs(targetDist.second - get<0>(chairs[targetDist.first][x])) * X[targetDist.first];
        dp[targetDist.first][x] = min(dp[targetDist.first][x], now_go);
      }
    }
  }
  if(dp[n-1].back() == 1e18){
    cout << "NO ESCAPE" << endl;
    return;
  }
  cout << dp[n - 1].back() << endl;
}
#undef int

// generated by oj-template v4.7.2
// (https://github.com/online-judge-tools/template-generator)
int main() {
  // Fasterize input/output script
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << fixed << setprecision(100);
  // scanf/printf user should delete this fasterize input/output script

  int t = 1;
  cin >> t; // comment out if solving multi testcase
  for (int testCase = 1; testCase <= t; ++testCase) {
    solve();
  }
  return 0;
}