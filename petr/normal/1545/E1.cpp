/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
//#include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int int64;
typedef pair<int, int> ii;

constexpr int INF = (int64) 1e9;
constexpr int SINF = (int) 1e8;

class E1AquaMoonIOstanovkaVremeniProstayaVersiya {
 public:
  void solveOne() {
    int n;
    cin >> n;
    int start;
    cin >> start;
    vector<int> tl(n), tr(n), l(n), r(n);
    for (int i = 0; i < n; ++i) {
      cin >> tl[i] >> tr[i] >> l[i] >> r[i];
      --tl[i]; ++tr[i]; --l[i]; ++r[i];
    }
    vector<int> corners;
    corners.emplace_back(start);
    for (int i = 0; i < n; ++i) {
      corners.emplace_back(r[i] - tl[i]);
      corners.emplace_back(l[i] - tr[i]);
      //corners.emplace_back(tr[i], r[i]);
      //corners.emplace_back(tl[i], l[i]);
    }
    sort(all(corners));
    corners.erase(unique(all(corners)), corners.end());
    vector<int> times;
    vector<int> poss;
    times.emplace_back(0);
    for (int i = 0; i < n; ++i) {
      times.emplace_back(tl[i]);
      times.emplace_back(tr[i]);
      poss.emplace_back(l[i]);
      poss.emplace_back(r[i]);
    }
    poss.emplace_back(-SINF);
    poss.emplace_back(SINF);
    sort(all(times));
    sort(all(poss));
    times.erase(unique(all(times)), times.end());
    poss.erase(unique(all(poss)), poss.end());
    vector<int> pevents;
    for (int i = 0; i < poss.size(); ++i) {
      pevents.emplace_back(poss[i]);
    }
    for (int i = 0; i < corners.size(); ++i) {
      pevents.emplace_back(corners[i]);
    }
    sort(all(pevents));
    pevents.erase(unique(all(pevents)), pevents.end());
    vector<int64> pbest(pevents.size());
    for (int i = 0; i < pevents.size(); ++i) {
      pbest[i] = abs(pevents[i] - start);
    }
    for (int stage = 1; stage < times.size(); ++stage) {
      int now = times[stage];
      int step = now - times[stage - 1];
      vector<int> events3;
      vector<int> nc(corners.size());
      for (int i = 0; i < corners.size(); ++i) {
        nc[i] = corners[i] + now;
      }
      vector<int> np(poss.size());
      for (int i = 0; i < poss.size(); ++i) {
        np[i] = poss[i] + step;
      }
      std::merge(all(poss), all(nc), back_inserter(events3));
      vector<int> events;
      std::merge(all(np), all(events3), back_inserter(events));

      /*for (int i = 0; i < poss.size(); ++i) {
        events.emplace_back(poss[i]);
        events.emplace_back(poss[i] + step);
      }
      for (int i = 0; i < corners.size(); ++i) {
        events.emplace_back(corners[i] + now);
      }
      sort(all(events));*/
      events.erase(unique(all(events)), events.end());
      vector<bool> interesting(events.size());
      int pat = 0;
      for (int i = 0; i < poss.size(); ++i) {
        int at = poss[i];
        while (events[pat] < at) ++pat;
        assert(events[pat] == at);
        interesting[pat] = true;
      }
      pat = 0;
      for (int i = 0; i < corners.size(); ++i) {
        int at = corners[i] + now;
        while (events[pat] < at) ++pat;
        assert(events[pat] == at);
        interesting[pat] = true;
      }

      vector<int64> best(events.size(), INF);
      int lj;
      int rj;
      int di;

      auto handleSegment = [&](int left, int right) {
        while (pevents[lj] < left) ++lj;
        while (pevents[rj] < right) ++rj;
        for (int j = lj; j <= rj; ++j) {
          int dest = pevents[j] + step;
          int64 cost = 0;
          if (dest > right) {
            cost = dest - right;
            dest = right;
          }
          while (events[di] < dest) ++di;
          assert(events[di] == dest);
          best[di] = min(best[di], pbest[j] + cost);
        }
      };

      {
        lj = 0;
        rj = 0;
        di = 0;
        vector<pair<int, int>> forbidden;
        for (int i = 0; i < n; ++i) {
          if (tl[i] <= times[stage - 1] && tr[i] >= times[stage]) {
            forbidden.emplace_back(l[i], 1);
            forbidden.emplace_back(r[i], -1);
          }
        }
        sort(all(forbidden));
        int left = -SINF;
        int balance = 0;
        for (int fi = 0; fi < forbidden.size(); ++fi) {
          bool was_zero = balance == 0;
          balance += forbidden[fi].second;
          assert(balance >= 0);
          if (was_zero) {
            handleSegment(left, forbidden[fi].first);
          } else if (balance == 0) {
            left = forbidden[fi].first;
          }
        }
        assert(balance == 0);
        handleSegment(left, SINF);
      }

      auto handleSegment2 = [&](int left, int right) {
        while (events[lj] < left) ++lj;
        while (events[rj] < right) ++rj;
        for (int i = lj; i < rj; ++i) {
          best[i + 1] = min(best[i + 1], best[i] + abs(events[i + 1] - events[i]));
        }
        for (int i = rj; i > lj; --i) {
          best[i - 1] = min(best[i - 1], best[i] + abs(events[i - 1] - events[i]));
        }
      };

      {
        lj = 0;
        rj = 0;
        vector<pair<int, int>> forbidden;
        if (stage + 1 < times.size()) {
          for (int i = 0; i < n; ++i) {
            if (tl[i] <= times[stage - 1] && tr[i] >= times[stage + 1]) {
              forbidden.emplace_back(l[i], 1);
              forbidden.emplace_back(r[i], -1);
            }
          }
        }
        sort(all(forbidden));
        int left = -SINF;
        int balance = 0;
        for (int fi = 0; fi < forbidden.size(); ++fi) {
          bool was_zero = balance == 0;
          balance += forbidden[fi].second;
          assert(balance >= 0);
          if (was_zero) {
            handleSegment2(left, forbidden[fi].first);
          } else if (balance == 0) {
            left = forbidden[fi].first;
          }
        }
        assert(balance == 0);
        handleSegment2(left, SINF);
      }

      pevents.clear();
      pbest.clear();
      for (int i = 0; i < events.size(); ++i) if (interesting[i]) {
        pevents.push_back(events[i]);
        pbest.push_back(best[i]);
      }
    }

    int64 res = INF;
    for (auto x : pbest) res = min(res, x);
    cout << res << "\n";
  }

  void solve() {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne();
    }
  }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    E1AquaMoonIOstanovkaVremeniProstayaVersiya solver;


    solver.solve();
    return 0;
}