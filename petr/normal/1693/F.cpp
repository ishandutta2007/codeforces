/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#undef NDEBUG

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
// AtCoder library from https://github.com/atcoder/ac-library
// #include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

constexpr int INF = (int) 1e9;

class FIMightBeWrong {
 public:
  int doit(string s) {
    int n = int(s.size());
    if (count(all(s), '0') < count(all(s), '1')) {
      reverse(all(s));
      for (auto& c : s) c ^= 1;
    }
    vector<int> balance(n + 1);
    vector<int> last(3 * n + 1, -1);
    balance[0] = 2 * n;
    last[n] = 0;
    for (int i = 0; i < n; ++i) {
      balance[i + 1] = balance[i] + (s[i] == '1' ? 1 : -1);
      last[balance[i + 1]] = i + 1;
    }
    int dest = n - int(count(all(s), '1'));
    int at = 0;
    while (at < n && s[at] == '0') ++at;
    int bal = balance[at];
    int atleast = at + 1;
    int res = 0;
    while (at < dest) {
      ++res;
      if (balance[n] >= bal) {
        break;
      }
      int bound = last[bal];
      assert(bound > atleast);
      assert((bound - at) % 2 == 0);
      at = (bound + at) / 2;
      atleast = bound;
      bal = balance[bound] - (bound - at);
    }
    return res;
  }

  void solveOne() {
    int n;
    cin >> n;
    string s;
    cin >> s;
    cout << doit(s) << "\n";
  }

  int stupid(string s) {
    int n = int(s.size());
    priority_queue<pair<int, int>> pq;
    vector<int> d(1 << n, INF);
    int start = 0;
    for (int i = 0; i < n; ++i) if (s[n - 1 - i] == '1') start |= 1 << i;
    d[start] = 0;
    pq.emplace(0, start);
    while (!pq.empty()) {
      auto pp = pq.top();
      pq.pop();
      int cur = pp.second;
      if (pp.first != -d[cur]) continue;
      for (int left = 0; left < n; ++left) {
        for (int right = left + 1; right <= n; ++right) {
          int mid = (cur >> left) & ((1 << (right - left)) - 1);
          int nxt = cur ^ (mid << left);
          int m1 = __builtin_popcount(mid);
          nxt ^= (((1 << m1) - 1) << left);
          int dist = d[cur] + abs(2 * m1 - (right - left)) + 1;
          if (dist < d[nxt]) {
            d[nxt] = dist;
            pq.emplace(-dist, nxt);
          }
        }
      }
    }
    int n1 = __builtin_popcount(start);
    return d[(1 << n1) - 1];
  }

  void solve() {
    int nt;
    cin >> nt;
    for (int it = 0; it < nt; ++it) {
      // cout << "Case #" << (it + 1) << ": ";
      solveOne();
    }
    /*while (true) {
      int n = rand() % 30 + 1;
      string s;
      for (int i = 0; i < n; ++i) s += (char) ('0' + rand() % 2);
      int got = doit(s);
      int must = stupid(s);
      if(got != must) {
        doit(s);
      }
    }*/
  }
};

// #define st_mtimespec st_mtim

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    FIMightBeWrong solver;


    solver.solve();
    return 0;
}