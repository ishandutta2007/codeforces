/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-03-18 17:28:51
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 2e5 + 10;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9; // 998244353; // 1e9 + 9;

ll n , q , A[MAXN] , F[MAXN] , ps[MAXN] , seg1[MAXN << 2] , seg2[MAXN << 2] , lz[MAXN << 2];

int getVal(int A , int B , int n){
	if(n == 0)	return A;
	if(n == 1)	return B;
	return (1ll * A * F[n - 2] + 1ll * B * F[n - 1]) % MOD;
}

void build(int id = 1 , int l = 0 , int r = MAXN){
	if(r - l == 1){
		seg1[id] = A[l];
		seg2[id] = A[l];
		return;
	}
	int mid = l + r >> 1;
	build(id << 1 , l , mid);
	build(id << 1 | 1 , mid , r);
	seg1[id] = (seg1[id << 1] + getVal(seg1[id << 1 | 1] , seg2[id << 1 | 1] , mid - l)) % MOD;
	seg2[id] = (seg2[id << 1] + getVal(seg1[id << 1 | 1] , seg2[id << 1 | 1] , mid - l + 1)) % MOD;
}

void shift(int id , int l , int r){
	lz[id << 1] = (lz[id << 1] + lz[id]) % MOD;
	lz[id << 1 | 1] = (lz[id << 1 | 1] + lz[id]) % MOD;
	seg1[id] = (seg1[id] + 1ll * lz[id] * ps[r - l - 1] % MOD) % MOD;
	seg2[id] = (seg2[id] + 1ll * lz[id] * (ps[r - l] + MOD - 1) % MOD) % MOD;
	lz[id] = 0;
}

void modify(int x , int v , int id = 1 , int l = 0 , int r = MAXN){
	shift(id , l , r);
	if(r - l == 1){
		seg1[id] = seg2[id] = v;
		return;
	}
	int mid = l + r >> 1;
	if(x < mid)	modify(x , v , id << 1 , l , mid);
	else	modify(x , v , id << 1 | 1 , mid , r);
	seg1[id] = (seg1[id << 1] + getVal(seg1[id << 1 | 1] , seg2[id << 1 | 1] , mid - l)) % MOD;
	seg2[id] = (seg2[id << 1] + getVal(seg1[id << 1 | 1] , seg2[id << 1 | 1] , mid - l + 1)) % MOD;
}

void update(int ql , int qr , int x , int id = 1 , int l = 0 , int r = MAXN){
	shift(id , l , r);
	if(qr <= l || r <= ql)	return;
	if(ql <= l && r <= qr){
		lz[id] += x;
		shift(id , l , r);
		return;
	}
	int mid = l + r >> 1;
	update(ql , qr , x , id << 1 , l , mid);
	update(ql , qr , x , id << 1 | 1 , mid , r);
	seg1[id] = (seg1[id << 1] + getVal(seg1[id << 1 | 1] , seg2[id << 1 | 1] , mid - l)) % MOD;
	seg2[id] = (seg2[id << 1] + getVal(seg1[id << 1 | 1] , seg2[id << 1 | 1] , mid - l + 1)) % MOD;
}

int get(int ql , int qr , int id = 1 , int l = 0 , int r = MAXN){
	shift(id , l , r);
	if(qr <= l || r <= ql)	return 0;
	if(ql <= l && r <= qr)	return getVal(seg1[id] , seg2[id] , l - ql);
	int mid = l + r >> 1;
	return (get(ql , qr , id << 1 , l , mid) + get(ql , qr , id << 1 | 1 , mid , r)) % MOD;
}

int main() {
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

	F[0] = F[1] = ps[0] = 1;
	for(ll i = 2 ; i < MAXN ; i++)	F[i] = (F[i - 1] + F[i - 2]) % MOD;
	for(ll i = 1 ; i < MAXN ; i++)	ps[i] = (ps[i - 1] + F[i]) % MOD;

	cin >> n >> q;
	for(ll i = 1 ; i <= n ; i++)	cin >> A[i];
	build();

	while(q--){
		ll t , l , r , x;
		cin >> t;
		if(t == 1){
			cin >> l >> x;
			modify(l , x);
		}
		if(t == 2){
			cin >> l >> r;
			cout << get(l , r + 1) << endl;
		}
		if(t == 3){
			cin >> l >> r >> x;
			update(l , r + 1 , x);
		}
	}

    return 0;
}
/*

*/