import java.util.Map;
import java.util.Collections;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.math.BigInteger;
import java.util.Collection;
import java.util.NavigableMap;
import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import java.io.*;
import java.util.Iterator;
import java.util.Comparator;
import java.util.Arrays;

/**
 * Generated by Contest helper plug-in
 * Actual solution is at the bottom
 */
public class Main {
	public static void main(String[] args) {
		InputReader in = new StreamInputReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		run(in, out);
	}

	public static void run(InputReader in, PrintWriter out) {
		Solver solver = new TaskA();
		solver.solve(1, in, out);
		Exit.exit(in, out);
	}
}

abstract class InputReader {
	private boolean finished = false;

	public abstract int read();

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuffer res = new StringBuffer();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	private boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public void setFinished(boolean finished) {
		this.finished = finished;
	}

	public abstract void close();

	}

class StreamInputReader extends InputReader {
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar, numChars;

	public StreamInputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	@Override
	public void close() {
		try {
			stream.close();
		} catch (IOException ignored) {
		}
	}
}

class Exit {
	private Exit() {
	}

	public static void exit(InputReader in, PrintWriter out) {
		in.setFinished(true);
		in.close();
		out.close();
	}
}

interface Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out);
}

class IndependentSetSystem {
	private final int[] color;
	private int setCount;

	public IndependentSetSystem(int size) {
		color = new int[size];
		for (int i = 0; i < size; i++)
			color[i] = i;
		setCount = size;
	}

	public IndependentSetSystem(IndependentSetSystem other) {
		color = other.color.clone();
		setCount = other.setCount;
	}

	public boolean join(int a, int b) {
		a = get(a);
		b = get(b);
		if (a == b)
			return false;
		setCount--;
		color[b] = a;
		return true;
	}

	public int get(int a) {
		if (color[a] == a)
			return a;
		return color[a] = get(color[a]);
	}

	public int getSetCount() {
		return setCount;
	}
}

class TaskA implements Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out) {
		int cityCount = in.readInt();
		int roadCount = in.readInt();
		int goldCost = in.readInt();
		int silverCost = in.readInt();
		Edge[] edges = new Edge[roadCount];
		for (int i = 0; i < roadCount; i++) {
			int source = in.readInt() - 1;
			int destination = in.readInt() - 1;
			int gold = in.readInt();
			int silver = in.readInt();
			edges[i] = new Edge(source, destination, gold, silver);
		}
		Arrays.sort(edges, new Comparator<Edge>() {
			public int compare(Edge o1, Edge o2) {
				return o1.gold - o2.gold;
			}
		});
		long answer = Long.MAX_VALUE;
		NavigableMap<Integer, IndependentSetSystem> state = new TreeMap<Integer, IndependentSetSystem>();
		for (Edge edge : edges) {
			NavigableMap<Integer, IndependentSetSystem> head = state.headMap(edge.silver, true);
			IndependentSetSystem current;
			if (head.isEmpty())
				current = new IndependentSetSystem(cityCount);
			else
				current = new IndependentSetSystem(head.lastEntry().getValue());
			current.join(edge.source, edge.destination);
			if (current.getSetCount() == 1)
				answer = Math.min(answer, (long)edge.gold * goldCost + (long)edge.silver * silverCost);
			state.put(edge.silver, current);
			for (Map.Entry<Integer, IndependentSetSystem> entry : state.tailMap(edge.silver, false).entrySet()) {
				if (!entry.getValue().join(edge.source, edge.destination))
					break;
				if (entry.getValue().getSetCount() == 1)
					answer = Math.min(answer, (long)edge.gold * goldCost + (long)entry.getKey() * silverCost);
			}
		}
		out.println(answer == Long.MAX_VALUE ? -1 : answer);
	}

	private static class Edge {
		private final int source;
		private final int destination;
		private final int gold;
		private final int silver;

		private Edge(int source, int destination, int gold, int silver) {
			this.source = source;
			this.destination = destination;
			this.gold = gold;
			this.silver = silver;
		}
	}
}