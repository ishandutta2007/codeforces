/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#undef NDEBUG

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
// AtCoder library from https://github.com/atcoder/ac-library
// #include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

constexpr int INF = (int) 1e9;

class DDecincDividing {
 public:
  void solveOne() {
    int n;
    cin >> n;
    vector<int> a(n);
    for (auto& x : a) {
      cin >> x;
      --x;
    }
    vector<int> stage1(n, -1);
    vector<int> stage2(n, -1);
    for (int i = 0; i + 1 < n; ++i) {
      if (a[i] < a[i + 1]) {
        stage1[i] = 0;
        stage2[i + 1] = 0;
      } else {
        stage1[i] = 1;
        stage2[i + 1] = 1;
      }
    }
    vector<array<int, 2>> stage1Next(n + 1, {INF, INF});
    vector<array<int, 2>> stage1NextContadiction(n + 1, {INF, INF});
    vector<array<int, 2>> stage2Next(n + 1, {INF, INF});
    vector<array<int, 2>> stage2NextContadiction(n + 1, {INF, INF});
    vector<array<int, 2>> stage1Prev(n + 1, {-INF, -INF});
    for (int i = 0; i < n; ++i) {
      stage1Prev[i + 1] = stage1Prev[i];
      if (i + 1 < n)
        stage1Prev[i + 1][stage1[i]] = i;
    }
    for (int stage = 1; stage <= 2; ++stage) {
      auto& cur = stage == 1 ? stage1 : stage2;
      auto& next = stage == 1 ? stage1Next : stage2Next;
      auto& contra = stage == 1 ? stage1NextContadiction : stage2NextContadiction;
      int from = n - 1;
      int to = 1;
      if (stage == 1) {
        --from;
        --to;
      }
      for (int i = from; i >= to; --i) {
        int val = cur[i];
        assert(val == 0 || val == 1);
        next[i] = next[i + 1];
        contra[i] = contra[i + 1];
        int onext = next[i][val];
        next[i][val] = i;
        if (onext < INF) {
          if (val == 0) {
            if (a[i] > a[onext]) {
              contra[i][val] = onext;
            }
          } else {
            if (a[i] < a[onext]) {
              contra[i][val] = onext;
            }
          }
        }
      }
    }
    int64 res = 0;
    for (int left = 0; left < n; ++left) {
      int stage1To = min(stage1NextContadiction[left][0], stage1NextContadiction[left][1]);
      if (stage1To >= n) {
        res += n - left;
        continue;
      }
      auto prev = stage1Prev[stage1To];
      int p0 = prev[0] < left ? -INF : a[prev[0]];
      int p1 = prev[1] < left ? INF : a[prev[1]];
      int stage2To = min(stage2NextContadiction[stage1To][0], stage2NextContadiction[stage1To][1]);
      if (stage2Next[stage1To][0] < INF && p0 > a[stage2Next[stage1To][0]]) {
        stage2To = min(stage2To, stage2Next[stage1To][0]);
      }
      if (stage2Next[stage1To][1] < INF && p1 < a[stage2Next[stage1To][1]]) {
        stage2To = min(stage2To, stage2Next[stage1To][1]);
      }
      if (stage2To >= n) {
        res += n - left;
        continue;
      }
      res += stage2To - left;
    }
    cout << res << "\n";
  }

  void solve() {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      // cout << "Case #" << (it + 1) << ": ";
      solveOne();
    }
  }
};

// #define st_mtimespec st_mtim

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    DDecincDividing solver;


    solver.solve();
    return 0;
}