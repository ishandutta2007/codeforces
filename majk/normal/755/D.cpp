/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Majk
 */

#include <vector>
#include <iostream>
#include <unordered_map>
#include <map>
#include <iomanip>
#include <functional>
#include <fstream>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <string>
#include <sstream>
#include <queue>
using namespace std;

#define x first
#define y second
constexpr int MOD = 1000000007;

typedef std::pair<int,int> pii;
typedef long long ll;

template<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}
template<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {for(size_t i=0;i<t.size();++i){o<<t[i]<<" \n"[i == t.size()-1];}return o;}

namespace std {
    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};
}
template<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}
template<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}
template<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }



template<typename F>struct NoCombine {
    const int NOCOMB=-2;
    void setup(size_t){}void op(F&p,F n,size_t,size_t,size_t){p=n;}F up(F l,F r,size_t){return l==r?l:NOCOMB;}
    void down(F&u,F&l,F&r,size_t,size_t,size_t){if(u!=NOCOMB){l=r=u;}u=NOCOMB;}};
template<typename F,typename Op>struct Persistent{Op o;void setup(size_t){}void op(F&p,F n,size_t,size_t, size_t){p=n;}F up(F l, F r, size_t){return o(l,r);}void down(F&,F&,F&,size_t,size_t, size_t b) {}};

template<typename F,typename SetOp,typename CombineOp,typename PowerOp>struct LazyProp{
    void setup(size_t s){this->s=s;L=new F[s]();}
    void down(F&u,F&l,F&r,size_t i,size_t a,size_t b){op(l,L[i],2*i,a,(a+b)/2);op(r,L[i],2*i+1,(a+b)/2,b);L[i]=0;}
    void op(F&p,F n,size_t i,size_t a,size_t b){p=cop(p,pop(n,b-a));if(i<this->s)this->L[i]=sop(this->L[i],n);}
    F up(F l,F r,size_t){return cop(l,r);}SetOp sop;CombineOp cop;PowerOp pop;F*L;size_t s;
};

template <typename F> struct AddOp { F operator()(F a, F b) { return a+b; }};
template <typename F> struct MultOp { F operator()(F a, F b) { return a*b; }};
template <typename F> struct IdempOp { F operator()(F a, F b) { return a; }};
template <typename F> struct MinOp { F operator()(F a, F b) { return min(a,b); }};
template <typename F> struct MaxOp { F operator()(F a, F b) { return max(a,b); }};

template <typename F, typename Combine> struct Tree {
    void setup(size_t s, F def) {
        size = 1; while (size < s) size *= 2;
        T = new F[2*size];
        for (size_t i = size; i < 2*size; i++) T[i] = def;
        for (size_t i = size-1; i > 0; i--) T[i] = op.up(T[2*i],T[2*i+1], i);
        op.setup(2*size);
    }

    void setup(vector<F> & data) {
        size = 1; while (size < data.size()) size *= 2;
        T = new F[2*size];
        for (size_t i = size; i < 2*size; i++) T[i] = data[i-size];
        for (size_t i = size-1; i > 0; i--) T[i] = op.up(T[2*i],T[2*i+1], i);
        op.setup(2*size);
    }

    inline void put(size_t x, F n) { put(x, x, n); }
    inline void put(size_t from, size_t to, F n) { put2(from, to+1, n, 1, 0, size); }
    inline F get(size_t x) { return get(x, x); }
    inline F get(size_t from, size_t to) { return get2(from, to+1, 1, 0, size); }

    void put2(size_t from, size_t to, F n, size_t i, size_t a, size_t b) {
        if (from <= a && to >= b) { op.op(T[i], n, i, a, b); return; }
        if (from >= b || to <= a) { return; }
        op.down(T[i], T[2*i], T[2*i+1], i, a, b);
        put2(from, to, n, 2*i, a, (a+b)/2);
        put2(from, to, n, 2*i+1, (a+b)/2, b);
        T[i] = op.up(T[2*i], T[2*i+1], i);
    }

    F get2(size_t from, size_t to, size_t i, size_t a, size_t b) {
        if (from <= a && to >= b) { return T[i]; }
        op.down(T[i], T[2*i], T[2*i+1], i, a, b);
        if (to <= (a+b)/2) { return get2(from, to, 2*i, a, (a+b)/2); }
        else if (from >= (a+b)/2) { return get2(from, to, 2*i+1, (a+b)/2, b); }
        else return op.up(get2(from, to, 2*i, a, (a+b)/2), get2(from, to, 2*i+1, (a+b)/2, b), i);
    }

    size_t size; F * T; Combine op;
};

typedef Tree<int, NoCombine<int>> SetGetTree;
typedef Tree<ll, LazyProp<ll, AddOp<ll>, AddOp<ll>, MultOp<ll>>> AddSumTree;
typedef Tree<int, Persistent<int, MinOp<int>>> SetMinTree;
typedef Tree<int, Persistent<int, MaxOp<int>>> SetMaxTree;




class TaskD {
public:
	void solve(istream& cin, ostream& cout) {
		unsigned int N, K; cin >> N >> K;
		K = min(K, N-K);
		vector<ll> A(N);
		ll a = 1;
		AddSumTree T;
		T.setup(N, 0);
		unsigned int b = 0;
		for (int i = 0; i < N; ++i) {
			unsigned int e = b + K;
			if (e >= N) {
				e -= N;
				if (e != 0) a += T.get(0, e-1);
				if (b != N-1) a += T.get(b+1, N-1);
			} else {
				a += T.get(b+1, e-1);
			}
			++a;
			T.put(b, 1);
			T.put(e, 1);

			A[i] = a;
			b = e;
		}

		cout << A;
	}
};


int main() {
	ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
	TaskD solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}