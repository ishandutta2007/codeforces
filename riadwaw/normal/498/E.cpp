/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author RiaD
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <vector>


#define int long long
const int mod = 1000000007;

std::vector<std::vector<int>> mult(const std::vector<std::vector<int>>& a, const std::vector<std::vector<int>>& b) {
	std::vector<std::vector<int>> c(a.size(), std::vector<int>(a.size()));
	for(int i = 0; i < a.size(); ++i) {
		for(int j = 0; j < a.size(); ++j) {
			for(int k = 0; k < a.size(); ++k) {
				c[i][k] += a[i][j] * b[j][k];
				c[i][k] %= mod;
			}
		}
	}
	return c;
}

std::vector<std::vector<int>> binpow(std::vector<std::vector<int>> aa, int b) {
	std::vector<std::vector<int>> res(aa.size(), std::vector<int>(aa.size()));
	for(int i = 0; i < aa.size(); ++i) {
		res[i][i] = 1;
	}

	while(b > 0) {
		if (b & 1) {
			res = mult(res, aa);
		}
		aa = mult(aa, aa);
		b >>= 1;
	}

	return res;

}


class E {
public:
	void solve(std::istream& in, std::ostream& out) {
		std::vector<int> curres(1, 1);
		for(int iter = 1; iter <= 7; ++iter) {
			int x;
			in >> x;
			std::vector<int> newres(2 * curres.size());
			for(int i = 0; i < curres.size(); ++i) {
				newres[i + curres.size()] = curres[i];
			}

			std::vector<std::vector<int>> matrix(1 << iter, std::vector<int>(1 << iter));

			for(int was = 0; was < (1 << iter); ++was) {
				for(int will = 0; will < (1 << iter); ++will) {
					for(int prom = 0; prom < (1 << (iter - 1)); ++prom) {
						int ok = true;
						for(int i = 0; i < iter; ++i) {
							if(was & (1 << i))
								if(will & (1 << i)) {
									if (i == 0 || (prom & (1 << (i - 1)))) {
										if(i == iter - 1 || (prom & (1 << i))) {
											ok = false;
											break;
										}
									}
								}
						}

						matrix[will][was] += ok;
					}
				}
			}

			matrix = binpow(matrix, x);

			curres.assign(newres.size(), 0);

			for(int i = 0; i < matrix.size(); ++i) {
				for(int j = 0; j < matrix.size(); ++j) {
					curres[i] += matrix[i][j] * newres[j];
					curres[i] %= mod;
				}
			}
		}
		out << curres.back();
	}
};


signed main() {
	std::cin.sync_with_stdio(false);
	std::cin.tie(0);
	std::cout << std::fixed;
	std::cout.precision(20);
	E solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}