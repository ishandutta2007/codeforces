/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author marX
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>

using namespace std;

vector<vector<int>> find_cost(vector<vector<int>> &to, vector<int> dev) {
    vector<int> order(to.size(), dev.size());

    for (int i = 0; i < dev.size(); ++i) {
        order[dev[i]] = i;
    }

    function<void(int)> fix_tree = [&](int s) {
        for (auto u : to[s]) {
            fix_tree(u);
            order[s] = min(order[s], order[u]);
        }

        sort(to[s].begin(), to[s].end(), [&](int x, int y) {
            return order[x] < order[y];
        });
    };

    fix_tree(0);

    int n = dev.size();

    vector<vector<int>> cost(n, vector<int>(n));

    int actual;
    int acc;

    function<int(int)> inner = [&](int s) {
        int rightmost = order[s];

        for (auto u : to[s]) {
            rightmost = max(rightmost, inner(u));

            if (order[u] >= actual)
                acc++;

            cost[actual][rightmost] = acc;
        }

        return rightmost;
    };

    function<void(int)> outer = [&](int s) {
        if (to[s].empty()) {
            actual = order[s];
            acc = 0;
            inner(0);
        }

        for (auto u : to[s]) {
            outer(u);
        }
    };

    outer(0);

    return cost;
}

struct my_input {
    vector<vector<int>> tree;
    vector<int> devices;
};

my_input read(std::istream &in, int k) {
    int n;
    in >> n;
    vector<vector<int>> tree(n);

    for (int i = 1; i < n; ++i) {
        int u;
        in >> u;
        u--;
        tree[u].push_back(i);
    }

    vector<int> devices(k);

    for (int i = 0; i < k; ++i) {
        in >> devices[i];
        devices[i]--;
    }

    return {tree, devices};
}

class FEconomicDifficulties {
public:
    void solve(std::istream &in, std::ostream &out) {
        int n;
        in >> n;

        auto A = read(in, n);
        auto B = read(in, n);

        auto ca = find_cost(A.tree, A.devices);
        auto cb = find_cost(B.tree, B.devices);

        vector<int> dp(n);

        for (int i = 0; i < n; ++i) {
            dp[i] = max(ca[0][i], cb[0][i]);

            for (int j = 1; j <= i; ++j) {
                dp[i] = max(dp[i], dp[j - 1] + max(ca[j][i], cb[j][i]));
            }
        }

        out << dp.back() << endl;
    }
};


int main() {
    FEconomicDifficulties solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}