/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author marX
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>


using namespace std;

struct disjoint_set {
    vector<int> ds;

    disjoint_set(int n) {
        ds = vector<int>(n, -1);
    }

    int root(int a) {
        return ds[a] < 0 ? a : ds[a] = root(ds[a]);
    }

    bool join(int a, int b) {
        a = root(a), b = root(b);
        if (a == b) return false;
        if (ds[a] < ds[b]) swap(a, b);
        ds[b] += ds[a];
        ds[a] = b;
        return true;
    }
};

using namespace std;

class DSegmentTree {
public:
    void solve(std::istream &in, std::ostream &out) {
        int n;
        in >> n;

        vector<pair<int, int>> a;

        disjoint_set ds(n);

        for (int i = 0; i < n; ++i) {
            int u, v;
            in >> u >> v;
            a.push_back({u, v});
        }

        sort(a.begin(), a.end());

        set<pair<int, int>> fin;

        int cc = n;
        bool ok = true;

        for (int i = 0; i < n && ok && cc >= 1; ++i) {
            int u = a[i].first;

            while (!fin.empty() && fin.begin()->first < u) {
                fin.erase(fin.begin());
            }

            int v = a[i].second;

            for (auto f : fin) {
                if (f.first >= v) break;

                ok &= ds.join(i, f.second);
                cc--;

                if (!ok) break;
                if (cc < 1) break;
            }

            fin.insert({v, i});
        }

        ok &= (cc == 1);
        out << (ok ? "YES" : "NO") << endl;
    }
};


int main() {
    DSegmentTree solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}