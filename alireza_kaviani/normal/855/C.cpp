/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author alireza_kaviani
 */

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef pair<ld, ld> pld;
typedef pair<string, string> pss;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define Mp                          make_pair
#define sep                         ' '
#define endl                        '\n'
#define debug(x)                    cerr << #x << " = " << x << endl
#define SZ(x)                       ll(x.size())
#define fast_io                     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define file_io                     freopen("in.txt" , "r" , stdin) ; freopen("out.txt" , "w" , stdout);
#define set_random                  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

inline ll input() {
    ll n;
    cin >> n;
    return n;
}

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

set_random;

const ll MAXN = 1e5 + 10;
const ll MAXX = 11;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

template<class T> T inverse(T a, T b) {
    a %= b; if (a == 0) return b == 1 ? 0 : -1;
    T x = inverse(b, a);
    return x == -1 ? -1 : ((1 - (ll)b * x) / a + b) % b;
}

template <ll mod>
struct ModInt {
    ll val;
    ModInt() : val(0) {}
    template <class U> ModInt(const U& x){
        val = (-mod < x && x < mod) ? x : x % mod;
        val = (val < 0) ? val + mod : val;
    }
    friend istream &operator>>(istream &is, ModInt &x)        { return is >> x.val;}
    friend ostream& operator<<(ostream& out, const ModInt& m) { return out << m.val; }
    friend bool operator==(const ModInt& a, const ModInt& b)  { return a.val == b.val; }
    friend bool operator!=(const ModInt& a, const ModInt& b)  { return !(a.val == b.val); }
    friend bool operator< (const ModInt& a, const ModInt& b)  { return a.val < b.val; }

    ModInt& operator-() { return ModInt(-val); }
    ModInt& operator+=(const ModInt& m) { if ((val += m.val) >= mod) val -= mod; return *this; }
    ModInt& operator-=(const ModInt& m) { if ((val -= m.val) < 0) val += mod; return *this; }
    ModInt& operator*=(const ModInt& m) { val = val * m.val % mod ; return *this; }

    friend ModInt pw(const ModInt& m, ll b) { return pw(m.val, b, m.mod); }
    ModInt inv() { return inverse(val, mod); }
    ModInt& operator/=(const ModInt& m) { return (*this) * m.inv(); }

    friend ModInt operator+(ModInt a, const ModInt& b) { return a += b; }
    friend ModInt operator-(ModInt a, const ModInt& b) { return a -= b; }
    friend ModInt operator*(ModInt a, const ModInt& b) { return a *= b; }
    friend ModInt operator/(ModInt a, const ModInt& b) { return a /= b; }

};

template <ll T = MOD> using mll = ModInt<T>;

vector<ll> adj[MAXN];
ll n , m , v , u , k , x;
mll<> dp[MAXN][MAXX][3] , tmp[MAXX][3];

void DFS(ll v , ll p = -1){
    for(ll u : adj[v]){
        if(u != p){
            DFS(u , v);
        }
    }

    dp[v][0][0] = k - 1;
    dp[v][1][1] = 1;
    dp[v][0][2] = m - k;
    for(ll u : adj[v]){
        if(u == p) continue;
        for(ll i = 0 ; i < MAXX ; i++)  tmp[i][0] = tmp[i][1] = tmp[i][2] = 0;
        for(ll j = 0 ; j < MAXX ; j++){
            for(ll k = 0 ; k <= j ; k++){
                tmp[j][0] += dp[v][j - k][0] * (dp[u][k][0] + dp[u][k][1] + dp[u][k][2]);
                tmp[j][1] += dp[v][j - k][1] * (dp[u][k][0]);
                tmp[j][2] += dp[v][j - k][2] * (dp[u][k][0] + dp[u][k][2]);
            }
        }

        for(ll j = 0 ; j < MAXX ; j++){
            for(ll k = 0 ; k < 3 ; k++){
                dp[v][j][k] = tmp[j][k];
            }
        }
    }
}

int main() {
    fast_io;

    cin >> n >> m;
    for(ll i = 1 ; i < n ; i++){
        cin >> v >> u;
        adj[v].push_back(u);
        adj[u].push_back(v);
    }
    cin >> k >> x;
    DFS(1);

    mll<> ans = 0;
    for(ll i = 0 ; i <= x ; i++)    ans += dp[1][i][0] + dp[1][i][1] + dp[1][i][2];
    cout << ans << endl;

    return 0;
}
/*

*/