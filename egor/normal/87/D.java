import java.util.NavigableSet;
import java.util.Map;
import java.util.Collections;
import java.util.HashMap;
import java.util.InputMismatchException;
import java.math.BigInteger;
import java.util.TreeSet;
import java.util.Set;
import java.util.Collection;
import java.util.ArrayList;
import java.util.List;
import java.util.TreeMap;
import java.util.Iterator;
import java.util.Comparator;
import java.io.*;
import java.util.HashSet;
import java.util.Arrays;

/**
 * Generated by Contest helper plug-in
 * Actual solution is at the bottom
 */
public class Main {
	public static void main(String[] args) {
		InputReader in = new StreamInputReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		run(in, out);
	}

	public static void run(InputReader in, PrintWriter out) {
		Solver solver = new TaskD();
		solver.solve(1, in, out);
		Exit.exit(in, out);
	}
}

abstract class InputReader {
	private boolean finished = false;

	public abstract int read();

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuffer res = new StringBuffer();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	private boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public void setFinished(boolean finished) {
		this.finished = finished;
	}

	public abstract void close();
}

class StreamInputReader extends InputReader {
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar, numChars;

	public StreamInputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public void close() {
		try {
			stream.close();
		} catch (IOException ignored) {
		}
	}
}

class Exit {
	private Exit() {
	}

	public static void exit(InputReader in, PrintWriter out) {
		in.setFinished(true);
		in.close();
		out.close();
	}
}

interface Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out);
}

class RecursiveIndependentSetSystem implements IndependentSetSystem {
	private final int[] color;
	private int setCount;
	private Listener listener;

	public RecursiveIndependentSetSystem(int size) {
		color = new int[size];
		for (int i = 0; i < size; i++)
			color[i] = i;
		setCount = size;
	}

	public RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {
		color = other.color.clone();
		setCount = other.setCount;
	}

	public boolean join(int first, int second) {
		first = get(first);
		second = get(second);
		if (first == second)
			return false;
		setCount--;
		color[second] = first;
		if (listener != null)
			listener.joined(second, first);
		return true;
	}

	public int get(int index) {
		if (color[index] == index)
			return index;
		return color[index] = get(color[index]);
	}

	public void setListener(Listener listener) {
		this.listener = listener;
	}
}

interface IndependentSetSystem {
	public boolean join(int first, int second);

	public int get(int index);

	public void setListener(Listener listener);

	public static interface Listener {
		public void joined(int joinedRoot, int root);
	}
}

interface Factory<V> {
	public V create();
}

class CPPMap<K, V> extends HashMap<K, V> {
	private final Factory<V> defaultValueFactory;

	public CPPMap(Factory<V> defaultValueFactory) {
		this.defaultValueFactory = defaultValueFactory;
	}

	public V get(Object key) {
		if (containsKey(key))
			return super.get(key);
		V value = defaultValueFactory.create();
		try {
			//noinspection unchecked
			super.put((K) key, value);
			return value;
		} catch (ClassCastException e) {
			return value;
		}
	}
}

class IOUtils {

	public static<T> void printCollection(Iterable<T> collection, PrintWriter out) {
		printCollection(collection, out, " ");
	}

	public static<T> void printCollection(Iterable<T> collection, PrintWriter out, String delimiter) {
		boolean isFirst = true;
		for (T element : collection) {
			if (isFirst)
				isFirst = false;
			else
				out.print(delimiter);
			out.print(element);
		}
		out.println();
	}

	}

class TaskD implements Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out) {
		int cityCount = in.readInt();
		Road[] roads = new Road[cityCount - 1];
		for (int i = 0; i < cityCount - 1; i++) {
			int from = in.readInt() - 1;
			int to = in.readInt() - 1;
			int length = in.readInt();
			roads[i] = new Road(from, to, length, i + 1);
		}
		Arrays.sort(roads, new Comparator<Road>() {
			public int compare(Road o1, Road o2) {
				return o1.length - o2.length;
			}
		});
		int start = 0;
		long answer = 0;
		final long[] component = new long[cityCount];
		Arrays.fill(component, 1);
		IndependentSetSystem setSystem = new RecursiveIndependentSetSystem(cityCount);
		setSystem.setListener(new IndependentSetSystem.Listener() {
			public void joined(int joinedRoot, int root) {
				component[root] += component[joinedRoot];
			}
		});
		List<Integer> indices = null;
		Factory<Set<Road>> defaultValueFactory = new Factory<Set<Road>>() {
			public Set<Road> create() {
				return new HashSet<Road>();
			}
		};
		for (int i = 1; i < cityCount; i++) {
			if (i == cityCount - 1 || roads[i].length != roads[i - 1].length) {
				final Map<Integer, Set<Road>> map = new CPPMap<Integer, Set<Road>>(defaultValueFactory);
				for (int j = start; j < i; j++) {
					int first = setSystem.get(roads[j].from);
					int second = setSystem.get(roads[j].to);
					roads[j].from = first;
					roads[j].to = second;
					map.get(first).add(roads[j]);
					map.get(second).add(roads[j]);
				}
				Comparator<Integer> comparator = new Comparator<Integer>() {
					public int compare(Integer o1, Integer o2) {
						int value = map.get(o1).size() - map.get(o2).size();
						if (value != 0)
							return value;
						return o1 - o2;
					}
				};
				NavigableSet<Integer> count = new TreeSet<Integer>(comparator);
				count.addAll(map.keySet());
				List<Road> processedRoads = new ArrayList<Road>();
				while (!count.isEmpty()) {
					int first = count.pollFirst();
					if (map.get(first).size() != 1)
						throw new RuntimeException();
					Road road = map.get(first).iterator().next();
					int second = road.from + road.to - first;
					map.remove(first);
					count.remove(second);
					Set<Road> secondRemaining = map.get(second);
					secondRemaining.remove(road);
					if (!secondRemaining.isEmpty()) {
						map.put(second, secondRemaining);
						count.add(second);
					} else
						map.remove(second);
					first = setSystem.get(first);
					second = setSystem.get(second);
					setSystem.join(second, first);
					road.from = first;
					road.to = second;
					processedRoads.add(road);
				}
				for (Road road : processedRoads) {
					long total = component[setSystem.get(road.to)];
					long current = (total - component[road.from]) * component[road.from];
					if (current > answer) {
						answer = current;
						indices = new ArrayList<Integer>();
						indices.add(road.index);
					} else if (current == answer)
						indices.add(road.index);
				}
				start = i;
			}
		}
		Collections.sort(indices);
		out.println(2 * answer + " " + indices.size());
		IOUtils.printCollection(indices, out);
	}

	private static class Road {
		private int from;
		private int to;
		private final int length;
		private final int index;

		private Road(int from, int to, int length, int index) {
			this.from = from;
			this.to = to;
			this.length = length;
			this.index = index;
		}

		public boolean equals(Object o) {
			if (this == o)
				return true;
			if (o == null || getClass() != o.getClass())
				return false;

			Road road = (Road) o;

			if (from != road.from)
				return false;
			if (index != road.index)
				return false;
			if (length != road.length)
				return false;
			if (to != road.to)
				return false;

			return true;
		}

		public int hashCode() {
			int result = from;
			result = 31 * result + to;
			result = 31 * result + length;
			result = 31 * result + index;
			return result;
		}
	}
}