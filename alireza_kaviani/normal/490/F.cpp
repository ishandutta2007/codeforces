/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-03-30 15:30:27
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 6010;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll n , timer , mx , val[MAXN] , par[MAXN] , st[MAXN] , fn[MAXN] , dpUp[MAXN];
pll dpDown[MAXN][2];
pll A[MAXN];
vector<ll> adj[MAXN];

void DFS(ll v , ll p = -1){
    st[v] = ++timer;
    par[v] = p;
    for(ll u : adj[v])  if(u != p)  DFS(u , v);
    fn[v] = timer;
}

ll isPar(ll v , ll u){
    return (st[v] <= st[u] && fn[u] <= fn[v]);
}

void DFS2(ll v , ll root){
    if(val[v] < val[par[root]]){
        mx = max(mx , dpDown[v][0].X + 1);
    }
    for(ll u : adj[v])  if(u != par[v]) DFS2(u , root);
}

int main() {
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

    cin >> n;
    //return cout << n << endl , 0;
    for(ll i = 1 ; i <= n ; i++)    cin >> val[i] , A[i].X = val[i] , A[i].Y = i;
    for(ll i = 1 , v , u; i < n ; i++){
        cin >> v >> u;
        adj[v].push_back(u);
        adj[u].push_back(v);
    }
    DFS(1);
    sort(A + 1 , A + n + 1);
    for(ll i = 1 ; i <= n ; i++){
        ll v = A[i].Y;
        for(ll u = 1 ; u <= n ; u++){
            if(par[u] == v){
                mx = 0;
                DFS2(u , u);
                //cout << u << endl;
                //cout.flush();
                dpDown[v][1] = max(dpDown[v][1] , pll(mx , u));
                if(dpDown[v][1] > dpDown[v][0]) swap(dpDown[v][0] , dpDown[v][1]);
            }
            if(val[u] < val[v] && !isPar(u , v) && !isPar(v , u)){
                dpUp[v] = max(dpUp[v] , dpDown[u][0].X + 1);
            }
        }
        ll u = v;
        while(u != 1){
            ll cost = dpDown[par[u]][1].X;
            if(dpDown[par[u]][0].Y != u)    cost = dpDown[par[u]][0].X;
            cost = max(cost , dpUp[par[u]]);
            if(val[par[u]] < val[v]) dpUp[v] = max(dpUp[v] , cost + 1);
            u = par[u];
        }
        dpUp[v] = max(dpUp[v] , 1LL);
        dpDown[v][0] = max(dpDown[v][0] , pll(1 , -1));
        dpDown[v][1] = max(dpDown[v][1] , pll(1 , -1));
        assert(dpDown[v][0] >= dpDown[v][1]);
        //cout << "V" << sep << "dpUp" << sep << "dpDown0" << sep << "dpDown1" << endl;
        //cout << v << sep << dpUp[v] << sep << dpDown[v][0].X << sep << dpDown[v][0].Y << sep << dpDown[v][1].X << sep << dpDown[v][1].Y << endl;
    }
    ll ans = 0;
    for(ll i = 1 ; i <= n ; i++)    ans = max({ans , dpUp[i] , dpDown[i][0].X});
    cout << ans << endl;

    return 0;
}
/*

*/