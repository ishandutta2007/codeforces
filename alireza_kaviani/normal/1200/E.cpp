/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author alireza_kaviani
 */

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define Mp                          make_pair
#define sep                         ' '
#define endl                        '\n'
#define debug(x)                    cerr << #x << " = " << x << endl
#define SZ(x)                       ll(x.size())
#define fast_io                     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define set_random                  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 1e6 + 10;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll Mod[3] = {ll(1e9 + 7) , ll(1e9 + 9) , ll(1e9 + 21)} , Base[3];

void setBases(){
    set_random;
    vector<ll> vec;
    for(ll i = 100 ; i < 1000 ; i++){
        ll pr = 1;
        for(ll j = 2 ; j * j <= i ; j++){
            if(i % j == 0)  pr = 0;
        }
        if(pr)  vec.push_back(i);
    }
    for(ll i = 0 ; i < 3 ; i++){
        Base[i] = vec[rng() % ll(vec.size())];
    }
}

struct Hash {
    ll n, mod;
    vector<ll> pw, invs, hs;

    Hash(string s = "" , ll base = 1, ll mod = 1) {
        ll inv = poww(base, mod - 2, mod);
        pw.resize(MAXN);
        invs.resize(MAXN);
        hs.resize(MAXN);
        pw[0] = 1;
        invs[0] = 1;

        for (ll i = 1; i < MAXN; i++) {
            pw[i] = pw[i - 1] * base % mod;
            invs[i] = invs[i - 1] * inv % mod;
        }

        this->mod = mod;
        n = 0;
        insert(s);
    }

    void insert(string s){
        for (ll i = n; i < n + s.size(); i++) {
            hs[i + 1] = hs[i] + (s[i - n] - 0) * pw[i] % mod;
        }
        n += s.size();
    }

    ll get(ll l, ll r) {
        r++;
        return (hs[r] - hs[l] + mod) % mod * invs[l] % mod;
    }
};

struct Hashes {
    vector<Hash> vec;

    Hashes(string s = "") {
        for (ll i = 0; i < 3; i++) {
            vec.push_back(Hash(s, Base[i], Mod[i]));
        }
    }

    vector<ll> get(ll l, ll r) {
        vector<ll> ans;
        for (ll i = 0; i < vec.size(); i++) {
            ans.push_back(vec[i].get(l, r));
        }
        return ans;
    }
};

ll n , sz;
string s[MAXN];
Hashes h1 , h2;

int main() {
    fast_io;
    setBases();
    h1 = Hashes();
    h2 = Hashes();

    cin >> n;
    for(ll i = 0 ; i < n ; i++){
        cin >> s[i];
    }

    for(ll i = 0 ; i < n ; i++){
        for(ll j = 0 ; j < 3 ; j++){
            h2.vec[j].n = 0;
            h2.vec[j].insert(s[i]);
        }
        ll ind = -1;
        for(ll j = 0 ; j < s[i].size() ; j++){
            ll l = sz - j - 1 , r = sz + j;
            if(l >= 0){
                if(h1.get(l , sz - 1) == h2.get(0 , j)){
                    ind = j;
                }
            }
        }
        s[i] = s[i].substr(ind + 1 , s[i].size());
        cout << s[i];
        for(ll j = 0 ; j < 3 ; j++){
            h1.vec[j].insert(s[i]);
        }
        sz += s[i].size();
    }

    return 0;
}
/*

*/