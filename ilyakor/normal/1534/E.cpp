/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

constexpr int inf = 1000 * 1000;

class TaskE {
public:
	void solve(std::istream& in, std::ostream& out) {
	    int n, k;
	    in >> n >> k;
	    if (k % 2 == 0 && n % 2 == 1) {
	        out << "-1\n";
            out.flush();
	        return;
	    }
        vi d(n + 1, inf);
        vi from(n + 1, -1);
        d[0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (d[j] == inf) continue;
                int delta = i - j;
                if (delta == k) {
                    if (d[i] > d[j] + 1) {
                        d[i] = d[j] + 1;
                        from[i] = j;
                    }
                }
                if (delta <= 2 * k && delta % 2 == 0) {
                    int k1 = k - delta / 2;
                    if (k1 <= n - delta) {
                        if (d[i] > d[j] + 2) {
                            d[i] = d[j] + 2;
                            from[i] = j;
                        }
                    }
                }
            }
        }
        if (d[n] == inf) {
            cerr << "We shouldn't be here\n";
            out << "-1\n";
            out.flush();
            return;
        }
        vi parts;
        int x = n;
        while (x > 0) {
            int y = from[x];
            if (x - y == k)
                parts.pb(k);
            else {
                int delta = x - y;
                assert(delta % 2 == 0);
                delta /= 2;
                parts.pb(delta);
                parts.pb(delta);
            }
            x = y;
        }
        reverse(all(parts));
        int res = 0;
        int pos = 0;
        int state = 0;
        for (int x : parts) {
            vi cur;
            if (x == k) {
                state = 0;
                for (int i = 0; i < k; ++i)
                    cur.pb(pos + i);
            } else {
                set<int> forbidden;
                if (state == 0) {
                    for (int i = 0; i < 2 * x; ++i) {
                        forbidden.insert(pos + i);
                    }
                } else {
                    for (int i = 0; i < 2 * x; ++i) {
                        forbidden.insert(pos - x + i);
                    }
                }
                state = 1 - state;
                for (int i = 0; i < n && (sz(cur) < k - x); ++i) {
                    if (!forbidden.count(i))
                        cur.pb(i);
                }
                for (int i = 0; i < x; ++i)
                    cur.pb(pos + i);

            }
            sort(all(cur));
            out << "? ";
            for (int t : cur)
                out << (t + 1) << " ";
            out << "\n";
            out.flush();
            int val;
            in >> val;
            res ^= val;
            pos += x;
        }
        out << "! " << res << "\n";
        out.flush();
	}

};


int main() {
	TaskE solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}