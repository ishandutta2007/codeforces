/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
//#include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

class GVotEtoPerevorot {
 public:
  pair<bool, vector<ii>> innerSolve(int k, string a, string b) {
    if (a == b) {
      return {true, vector<ii>()};
    }
    int na = 0;
    int nb = 0;
    for (char c : a) if (c == '1') ++na;
    for (char c : b) if (c == '1') ++nb;
    if (na != nb || na < k || k == 0) {
      return {false, vector<ii>()};
    }
    if (k == 1) {
      auto normalize = [&](string a) {
        vector<ii> seq;
        int dest = 0;
        for (int i = 0; i < a.size(); ++i) if (a[i] == '1') {
            if (i > dest) {
              reverse(a.begin() + dest, a.begin() + i + 1);
              seq.emplace_back(dest, i);
            }
            ++dest;
          }
        return make_pair(a, seq);
      };
      auto sa = normalize(a);
      auto sb = normalize(b);
      if (sa.first == sb.first) {
        assert(sa.second.size() + sb.second.size() <= 4 * a.size());
        reverse(all(sb.second));
        for (auto p : sb.second) sa.second.push_back(p);
        return {true, sa.second};
      } else {
        return {false, vector<ii>()};
      }
    } else if (na == k) {
      auto normalize = [&](string a) {
        int first1 = -1;
        int last1 = -1;
        for (int i = 0; i < a.size(); ++i) if (a[i] == '1') {
            if (first1 < 0) first1 = i;
            last1 = i;
          }
        int len = last1 - first1 + 1;
        vector<ii> seq;
        reverse(a.begin(), a.begin() + last1 + 1);
        seq.emplace_back(0, last1);
        string b = a;
        reverse(b.begin(), b.begin() + len);
        if (b < a) {
          a = b;
          seq.emplace_back(0, len - 1);
        }
        return make_pair(a, seq);
      };
      auto sa = normalize(a);
      auto sb = normalize(b);
      if (sa.first == sb.first) {
        assert(sa.second.size() + sb.second.size() <= 4 * a.size());
        reverse(all(sb.second));
        for (auto p : sb.second) sa.second.push_back(p);
        return {true, sa.second};
      } else {
        return {false, vector<ii>()};
      }
    } else {
      auto normalize = [&](string a) {
        vector<ii> seq;
        while (true) {
          int leading1s = 0;
          while (leading1s < a.size() && a[leading1s] == '1') ++leading1s;
          int skip = min(leading1s, na - k - 1);
          if (leading1s >= na - 1) {
            if (leading1s == na - 1 && k % 2 != 0) {
              int last1 = leading1s;
              while (a[last1] == '0') ++last1;
              for (int i = 0; i < k; ++i) {
                if (i % 2 == 0) {
                  reverse(a.begin() + skip + 1, a.begin() + last1 + 1);
                  seq.emplace_back(skip + 1, last1);
                } else {
                  reverse(a.begin() + skip, a.begin() + last1);
                  seq.emplace_back(skip, last1 - 1);
                }
              }
              leading1s = 0;
              while (leading1s < a.size() && a[leading1s] == '1') ++leading1s;
              assert(leading1s == na);
            }
            break;
          }
          int first1 = -1;
          int last1 = -1;
          int outside1 = -1;
          int ones = 0;
          for (int i = skip; i < a.size(); ++i) if (a[i] == '1') {
              if (first1 < 0) first1 = i;
              ++ones;
              if (ones == k) {
                last1 = i;
              }
              if (ones == k + 1) {
                outside1 = i;
                break;
              }
            }
          assert(outside1 >= 0);
          if (last1 - first1 == k - 1) {
            if (first1 > skip) {
              reverse(a.begin() + skip, a.begin() + last1 + 1);
              seq.emplace_back(skip, last1);
            }
          } else {
            reverse(a.begin() + first1, a.begin() + outside1);
            seq.emplace_back(first1, outside1 - 1);
            int nfirst1 = skip;
            while (a[nfirst1] == '0') ++nfirst1;
            if (outside1 - nfirst1 > k) {
              reverse(a.begin() + nfirst1 + 1, a.begin() + outside1 + 1);
              seq.emplace_back(nfirst1 + 1, outside1);
            }
          }
        }
        return make_pair(a, seq);
      };
      auto sa = normalize(a);
      auto sb = normalize(b);
      if (sa.first == sb.first) {
        assert(sa.second.size() + sb.second.size() <= 4 * a.size());
        reverse(all(sb.second));
        for (auto p : sb.second) sa.second.push_back(p);
        return {true, sa.second};
      } else {
        return {false, vector<ii>()};
      }
    }
  }


  void solveOne() {
    int n, k;
    cin >> n >> k;
    string a, b;
    cin >> a >> b;
    auto res = innerSolve(k, a, b);
    if (res.first) {
      cout << res.second.size() << "\n";
      for (auto p : res.second) {
        cout << p.first + 1 << " " << p.second + 1 << "\n";
      }
    } else {
      cout << -1 << "\n";
    }
  }

  void solve() {
    /*while (true) {
      int n = rand() % 15 + 1;
      int k = rand() % 5 + 1;
      string a;
      for (int i = 0; i < n; ++i) a += (char) ('0' + rand() % 2);
      string b = a;
      int steps = rand() % 10 + 1;
      vector<string> seq;
      for (int s = 0; s < steps; ++s) {
        int left = rand() % a.size();
        int right = rand() % a.size();
        if (left > right) swap(left, right);
        int ones = 0;
        for (int i = left; i <= right; ++i) if (b[i] == '1') ++ones;
        if (ones == k) {
          reverse(b.begin() + left, b.begin() + right + 1);
          seq.push_back(b);
        }
      }
      auto res = innerSolve(k, a, b);
      if (!res.first) {
        cerr << "a = " << a << endl;
        cerr << "b = " << b << endl;
        cerr << "k = " << k << endl;
        for (string x: seq) {
          cerr << x << endl;
        }
        assert(false);
      }
    }*/
    int nt;
    cin >> nt;
    for (int it = 0; it < nt; ++it) {
      solveOne();
    }
  }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    GVotEtoPerevorot solver;


    solver.solve();
    return 0;
}