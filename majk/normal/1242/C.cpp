/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author majk
 */

#ifndef MAJK_LIB
#define MAJK_LIB

#include <vector>
#include <stack>
#include <iostream>
#include <fstream>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <iomanip>
#include <set>
#include <functional>
#include <algorithm>
#include <numeric>
#include <cassert>
#include <cmath>
#include <string>
#include <queue>
#include <array>
#include <bitset>
using namespace std;

#define x first
#define y second
typedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;

template <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}
template<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}
template <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}
template<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<" \n"[i == t.size()-1];}return o;}
template<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;
template<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;
ui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }

namespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }
template<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}
template<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}
template<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}
template<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}
template<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }


template<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};
template<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};
template<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};
template<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};


#endif

class CSumBalance {
public:
    void solve(istream& cin, ostream& cout) {
        int K; cin >> K;
        vector<vector<ll>> A(K);
        vector<set<ll>> B(K);
        map<ll, int> C;
        vector<ll> Tot(K, 0);
        ll tot = 0;
        for (int i = 0; i < K; ++i) {
            int n; cin >> n;
            A[i].resize(n); cin >> A[i];
            for (ll a: A[i]) {
                C[a] = i;
                B[i].insert(a);
                Tot[i] += a;
            }
            tot += Tot[i];
        }

        if (K == 1) {
            cout << "Yes\n" << A[0][0] << ' ' << 1 << endl;
            return;
        }

        if (tot % K != 0) {
            cout << "No\n";
            return;
        }
        ll target = tot / K;

        vector<ll> Diff(K);
        for (int i = 0; i < K; ++i) {
            Diff[i] = target - Tot[i];
        }
        vector<ll> MDiff(1<<K, 0);
        for (int i = 0; i < (1<<K); ++i) {
            for (int j = 0; j < K; ++j) {
                if (i&1<<j) MDiff[i] += Diff[j];
            }
        }

        vector<vector<int>> Sol(1<<K);
        for (int i = 0; i < K; ++i) {
            for (ll v : A[i]) {
                ll cur = v;
                int j = i, m = 0;
                vector<int> S{(int)v};
                while (!(m&1<<j)) {
                    S.push_back(j);
                    m |= 1<<j;
                    cur += Diff[j];
                    auto it = C.find(cur);
                    if (it != C.end()) j = it->y;
                }
                if (cur == v) {
                    reverse(S.begin(),S.end());
                    Sol[m] = S;
                }
            }
        }


//        for (int k = 0; k < K; ++k) {
//            if (Diff[k] == 0) Sol[1<<k] = {k, (int)A[k][0]};
//        }
//        for (int k = K-1; k >= 0; --k) {
//            int m = 1<<k;
//            for (ll v : A[k]) {
//                vector<int> X(m, -1);
//                X[0] = 100;
//                for (int i = 0; i < m - 1; ++i) {
//                    if (X[i] != -1) {
//                        for (int j = 0; j < k; ++j) {
//                            if (i & 1 << j) continue;
//                            ll need = MDiff[i | m] + v;
//                            if (B[j].count(need) > 0) {
//                                X[i | 1 << j] = j;
//
//                                if (MDiff[i|m|1<<j] == 0) {
//                                    if (Sol[i|m|1<<j].empty()) {
//                                        vector<int> Q{j};
//                                        int w = i;
//                                        while (w) {
//                                            int back = X[w];
//                                            Q.push_back(back);
//                                            w ^= 1<<back;
//                                        }
//                                        Q.push_back(k);
//                                        Q.push_back(v);
//
//                                        Sol[i|m|1<<j] = Q;
//                                    }
//                                }
//                            }
//
//                        }
//                    }
//                }
//            }
//        }

        vector<int> FullSol(1<<K, -1);
        FullSol[0] = 100;
        for (int i = 0; i < (1<<K); ++i) {
            if (FullSol[i] != -1) {
                vector<int> Other{0};
                for (int j = 0; j < K; ++j) {
                    if (i&1<<j) continue;
                    int s = Other.size();
                    for (int k = 0; k < s; ++k) {
                        Other.push_back(Other[k] | 1<<j);
                    }
                }
                for (int o: Other) {
                    if (!Sol[o].empty()) {
                        FullSol[o|i] = o;
                    }
                }
            }
        }

        if (FullSol.back() != -1) {
            int full = (1<<K)-1;
            vector<int> Take(K, -1), To(K, -1);
            while (full) {
                int back = FullSol[full];
                auto Q = Sol[back];
                reverse(Q.begin(),Q.end());
                int v = Q[0];
                for (int i = 1; i < Q.size(); ++i) {
                    Take[Q[i]] = v;
                    v += Diff[Q[i]];
                    if (i == 1) {
                        To[Q[i]] = Q[Q.size()-1];
                    } else {
                        To[Q[i]] = Q[i-1];
                    }
                }

                full ^= back;
            }

            cout << "Yes\n";
            for (int i = 0; i < K; ++i) {
                cout << Take[i] << ' ' << To[i]+1 << '\n';
            }
        } else {
            cout << "No\n";
        }

    }
};


int main() {
	ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
	CSumBalance solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
    return 0;
}