/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
//#include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

class GSerezniiSudya {
 public:
  void solveOne() {
    int n, k;
    cin >> n >> k;
    vector<vector<int>> cmp(k);
    vector<int> earliest(n, -1);
    for (int i = 0; i < k; ++i) {
      int cnt;
      cin >> cnt;
      for (int j = 0; j < cnt; ++j) {
        int x;
        cin >> x;
        --x;
        cmp[i].push_back(x);
        if (earliest[x] < 0) earliest[x] = i;
      }
    }
    if (n == 1) {
      cout << "ACCEPTED\n";
      return;
    }
    for (int i = 0; i < n; ++i) if (earliest[i] < 0) {
      cout << "REJECTED\n";
      return;
    }
    vector<int> perm(n);
    for (int i = 0; i < n; ++i) perm[i] = i;
    sort(all(perm), [&](int a, int b) { return earliest[a] < earliest[b]; });
    vector<int> iperm(n);
    for (int i = 0; i < n; ++i) iperm[perm[i]] = i;
    vector<int64> states;
    states.push_back(0);
    int ptr = 0;
    for (int step = 0; step < k; ++step) {
      const auto& carr = cmp[step];
      vector<int64> nstates;
      int extra = 0;
      while (ptr < n && earliest[perm[ptr]] == step) {
        ++ptr;
        ++extra;
      }
      for (int64 old : states) {
        for (int ones = 0; ones <= extra; ++ones) {
          int64 state = old + (((int64(1) << ones) - 1) << (ptr - extra));
          int got1 = 0;
          for (int x : carr) {
            if (state & (int64(1) << iperm[x])) {
              ++got1;
            }
          }
          int got0 = carr.size() - got1;
          for (int x : carr) {
            if (got0 > 0) {
              --got0;
              state &= ~(int64(1) << iperm[x]);
            } else {
              --got1;
              state |= int64(1) << iperm[x];
            }
          }
          assert(got0 == 0 && got1 == 0);
          nstates.push_back(state);
        }
      }
      sort(all(nstates));
      nstates.erase(unique(all(nstates)), nstates.end());
      states.swap(nstates);
    }
    if (states.size() == n + 1) {
      cout << "ACCEPTED\n";
    } else {
      cout << "REJECTED\n";
    }
  }

  void solve() {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne();
    }
  }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    GSerezniiSudya solver;


    solver.solve();
    return 0;
}