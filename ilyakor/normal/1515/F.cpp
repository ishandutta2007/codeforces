/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>
#ifndef ATCODER_DSU_HPP
#define ATCODER_DSU_HPP 1





namespace atcoder {

// Implement (union by size) + (path compression)
// Reference:
// Zvi Galil and Giuseppe F. Italiano,
// Data structures and algorithms for disjoint set union problems
struct dsu {
  public:
    dsu() : _n(0) {}
    explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}

    int merge(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        int x = leader(a), y = leader(b);
        if (x == y) return x;
        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);
        parent_or_size[x] += parent_or_size[y];
        parent_or_size[y] = x;
        return x;
    }

    bool same(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        return leader(a) == leader(b);
    }

    int leader(int a) {
        assert(0 <= a && a < _n);
        if (parent_or_size[a] < 0) return a;
        return parent_or_size[a] = leader(parent_or_size[a]);
    }

    int size(int a) {
        assert(0 <= a && a < _n);
        return -parent_or_size[leader(a)];
    }

    std::vector<std::vector<int>> groups() {
        std::vector<int> leader_buf(_n), group_size(_n);
        for (int i = 0; i < _n; i++) {
            leader_buf[i] = leader(i);
            group_size[leader_buf[i]]++;
        }
        std::vector<std::vector<int>> result(_n);
        for (int i = 0; i < _n; i++) {
            result[i].reserve(group_size[i]);
        }
        for (int i = 0; i < _n; i++) {
            result[leader_buf[i]].push_back(i);
        }
        result.erase(
            std::remove_if(result.begin(), result.end(),
                           [&](const std::vector<int>& v) { return v.empty(); }),
            result.end());
        return result;
    }

  private:
    int _n;
    // root node: -1 * component size
    // otherwise: parent
    std::vector<int> parent_or_size;
};

}  // namespace atcoder

#endif  // ATCODER_DSU_HPP


using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

struct Edge {
    int64 w;
    int to;
    int id;
};

bool operator<(const Edge& e1, const Edge& e2) {
    if (e1.w != e2.w)
        return e1.w > e2.w;
    return e1.id < e2.id;
}

struct Shit {
    set<Edge> s;

    Edge pop() {
        Edge res = *s.begin();
        s.erase(s.begin());
        return res;
    }

    void merge(Shit* other) {
        s.insert(all(other->s));
    }
};

class TaskF {
public:
	void solve(std::istream& in, std::ostream& out) {
	    int n, m, X;
	    in >> n >> m >> X;
	    vector<int64> a(n);
	    for (int i = 0; i < n; ++i)
	        in >> a[i];
        atcoder::dsu dsu(n);
        vector<Shit*> g(n);
        for (int i = 0; i < n; ++i)
            g[i] = new Shit();
        for (int i = 0; i < m; ++i) {
            int x, y;
            in >> x >> y;
            --x;
            --y;
            g[x]->s.insert(Edge{a[y], y, i + 1});
            g[y]->s.insert(Edge{a[x], x, i + 1});
        }
        set<pair<int64, int>> q;
        for (int i = 0; i < n; ++i) {
            q.insert({a[i], i});
        }
        vi res;
        while (!q.empty()) {
            int x = q.rbegin()->second;
            int64 V = q.rbegin()->first;
            q.erase(*q.rbegin());
            if (dsu.leader(x) != x) continue;
            if (a[x] != V) continue;
            int r = x;
            while (!g[r]->s.empty()) {
                Edge e = g[r]->pop();
                int v1 = dsu.leader(r);
                int v2 = dsu.leader(e.to);
                if (v1 == v2) continue;
                int64 val = a[v1] + a[v2] - X;
                if (val >= 0) {
                    res.pb(e.id);
                    r = dsu.merge(v1, v2);
                    a[r] = a[v1] + a[v2] - X;
                    if (g[v1]->s.size() > g[v2]->s.size()) {
                        g[v1]->merge(g[v2]);
                        g[r] = g[v1];
                    } else {
                        g[v2]->merge(g[v1]);
                        g[r] = g[v2];
                    }
                    break;
                }
            }
            if (!g[r]->s.empty())
                q.emplace(a[r], r);
        }
        assert(sz(res) <= n - 1);
        if (sz(res) < n - 1) {
            out << "NO\n";
            return;
        }
        out << "YES\n";
        for (int x : res)
            out << x << "\n";
	}
};


int main() {
	TaskF solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}