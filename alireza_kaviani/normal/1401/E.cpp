/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-08-21 19:05:02
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<int, int> pii;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 1e6 + 10;
const ll MAXA = 1e6;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

ll n , m , ans , fen[MAXN];
vector<ll> U[MAXN] , Q[MAXN];
vector<pll> x[2] , y[2];

void update(int x , int v){
	for( x++ ; x < MAXN ; x += x & -x)	fen[x] += v;
}

ll get(int x){
	ll ans = 0;
	for(x ++ ; x > 0 ; x -= x & -x)	ans += fen[x];
	return ans;
}

ll solve(vector<pll> x , vector<pll> y){
	ll res = 0;
	fill(U , U + MAXN , vector<ll>());
	fill(Q , Q + MAXN , vector<ll>());
	fill(fen , fen + MAXN , 0);
	for(pll i : x)	U[i.X].push_back(i.Y);// , cout << i.X << sep << i.Y << endl;
	//cout << endl;
	for(pll i : y)	Q[i.X].push_back(i.Y);// , cout << i.X << sep << i.Y << endl;
	for(int i = 0 ; i <= MAXA ; i++){
		for(int j : U[i])	update(j , 1);
		for(int j : Q[i])	res += get(j);
	}
	//cout << res << endl << "================\n";
	return res;
}

int main() {
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

	cin >> n >> m;
	for(int i = 0 ; i < n ; i++){
		int y , l , r;
		cin >> y >> l >> r;
		if(l == 0)	x[1].push_back({r , y});
		else if(r == MAXA)	x[0].push_back({l , y});
	}
	x[0].push_back({0 , MAXA});
	x[0].push_back({0 , 0});
	//x[1].push_back({MAXA , 0});
	//x[1].push_back({MAXA , MAXA});
	y[0].push_back({0 , MAXA});
	y[0].push_back({MAXA , MAXA});
	//y[1].push_back({0 , 0});
	//y[1].push_back({MAXA , 0});
	for(int i = 0 ; i < m ; i++){
		int x , l , r;
		cin >> x >> l >> r;
		if(l == 0)	y[0].push_back({x , r});
		else if(r == MAXA)	y[1].push_back({x , l});
	}
	for(int i = 0 ; i < 2 ; i++){
		for(int j = 0 ; j < 2 ; j++){
			if(i == 1){
				for(int k = 0 ; k < SZ(x[i]) ; k++)	x[i][k].X = MAXA - x[i][k].X;
				for(int k = 0 ; k < SZ(y[j]) ; k++)	y[j][k].X = MAXA - y[j][k].X;
			}
			if(j == 1){
				for(int k = 0 ; k < SZ(x[i]) ; k++)	x[i][k].Y = MAXA - x[i][k].Y;
				for(int k = 0 ; k < SZ(y[j]) ; k++)	y[j][k].Y = MAXA - y[j][k].Y;
			}
			ans += solve(x[i] , y[j]);
			if(i == 1){
				for(int k = 0 ; k < SZ(x[i]) ; k++)	x[i][k].X = MAXA - x[i][k].X;
				for(int k = 0 ; k < SZ(y[j]) ; k++)	y[j][k].X = MAXA - y[j][k].X;
			}
			if(j == 1){
				for(int k = 0 ; k < SZ(x[i]) ; k++)	x[i][k].Y = MAXA - x[i][k].Y;
				for(int k = 0 ; k < SZ(y[j]) ; k++)	y[j][k].Y = MAXA - y[j][k].Y;
			}
		}
	}
	cout << ans - n - m - 3 << endl; 

    return 0;
}
/*



























*/