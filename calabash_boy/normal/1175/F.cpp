/* Generated by powerful Codeforces Tool
 * Author: calabash_boy_love_15 
 * Time: 2019-06-06 00:55:13
 * Personal Code Template: https://github.com/4thcalabash/ACM-Code-Library
**/
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;
#ifdef __LOCAL_DEBUG__
# define _debug(fmt, ...) fprintf(stderr, "\033[91m[%s %3d]: " fmt "\n\033[0m", \
  __func__,__LINE__, ##__VA_ARGS__)
#else
# define _debug(...) (void(0))
#endif
#define PB(x) push_back(x)
#define rep(i,l,r) for (int i = l,_ = r;i< _;i++)
#define REP(i,l,r) for (int i=l,_=r;i<=_;i++)
#define leave(x) do {cout<<#x<<endl;fflush(stdout);return 0;}while (0);
#define untie do{ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);}while (0)
#define range(x) x.begin(),x.end()
typedef long long LL;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double db;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
const int inf = 0x3f3f3f3f;
const ll inf_ll = 0x3f3f3f3f3f3f3f3fLL;
/************* header ******************/
const int maxn = 3e5 + 100;
int r[maxn];
int l[maxn];
int L[maxn];
int R[maxn];
int a[maxn];
int nxt[maxn];
int pre[maxn];
int last_pos[maxn];
int first_pos[maxn];
int big_pre[maxn];
int n;
int rlen[maxn];
struct BIT{
    int lowbit(int x){
        return x & (-x);
    }
    int sum[maxn];
    void add(int x){
        while (x < maxn){
            sum[x] ++;
            x += lowbit(x);
        }
    }
    int query(int x){
        int cnt = 0;
        while (x){
            cnt += sum[x];
            x -= lowbit(x);
        }
        return cnt;
    }
    int query(int l,int r){
        return query(r) - query(l-1);
    }
}bit;
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",a+i);
        last_pos[i] = n+1;
        first_pos[i] = 0;
    }
    for (int i=n;i>=1;i--){
        nxt[i] = last_pos[a[i]]-1;
        last_pos[a[i]] = i;
    }
    r[n+1] = n;
    for (int i=n;i>=1;i--){
        r[i] = min(r[i+1],nxt[i]);
        rlen[i] = r[i] - i + 1;
    }
    for (int i=1;i<=n;i++){
        pre[i] = first_pos[a[i]] + 1;
        first_pos[a[i]] = i;
    }
    l[0] = 1;
    for (int i=1;i<=n;i++){
        l[i] = max(l[i-1],pre[i]);
    }
    
    stack<int> stk;
    for (int i=1;i<=n;i++){
        while (!stk.empty() && a[stk.top ()] <a[i])stk.pop();
        if (stk.empty()){
            L[i] = 1;
        }else{
            L[i] = stk.top() + 1;
        }
        L[i] = max(L[i],l[i]);
        stk.push(i);
    }
    while (!stk.empty())stk.pop();
    for (int i=n;i>=1;i--){
        while (!stk.empty() && a[stk.top()] < a[i])stk.pop();
        if (stk.empty()){
            R[i] = n;
        }else{
            R[i] = stk.top() - 1;
        }
        R[i] = min(R[i],r[i]);
        stk.push(i);
    }
    vector<tuple<int,int,int> > Query(0);
    for (int i=1;i<=n;i++){
        int rp = R[i];
        int len = a[i];
        int rr = rp - len + 1;
        assert(rr <=i);
    //    rr = min(rr,i);
        int ll = L[i];
        if (ll <= rr)
        Query.push_back(make_tuple(ll,rr,len));
    }
    sort(Query.begin(),Query.end(),[](tuple<int,int,int> x,tuple<int,int,int> y){
       return get<2>(x) > get<2>(y); 
    });
    vector<int> nums(0);
    for (int i=1;i<=n;i++){
        nums.push_back(i);
    }
    sort(nums.begin(),nums.end(),[](int x,int y){
       return rlen[x] < rlen[y]; 
    });
    long long ans = 0;
    for (auto tp : Query){
        int ll,rr,limit;
        tie(ll,rr,limit) = tp;
        while (!nums.empty() && rlen[nums.back()] >= limit){
            bit.add(nums.back());
            nums.pop_back();
        }
        ans += bit.query(ll,rr);
    }
    cout<<ans<<endl;
    return 0;
}