/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

constexpr int mod = 1000 * 1000 * 1000 + 7;

class TaskE {
public:
    vi f;
    vi rf;

    int pw(int64 x, int64 y) {
        int64 res = 1;
        while (y) {
            if (y % 2) {
                --y;
                res = (res * x) % mod;
            } else {
                y /= 2;
                x = (x * x) % mod;
            }
        }
        return res;
    }

	void solve(std::istream& in, std::ostream& out) {
	    f = vi(110 * 1000);
        rf = vi(110 * 1000);
	    f[0] = 1;
        rf[0] = 1;
	    for (int i = 1; i < sz(f); ++i) {
	        f[i] = (f[i - 1] * (int64) i) % mod;
	        rf[i] = pw(f[i], mod - 2);
	    }
//	    for (int n = 2; n <= 15; ++n) {
//            for (int k = 2; k <= n; ++k) {
//                int64 cur = stupid(n, k);
////                cur *= pw(f[n], mod - 2);
////                cur %= mod;
//                cerr << cur << " ";
//            }
//            cerr << "\n";
//        }
//	    cerr.flush();
        int n, k;
	    in >> n >> k;
	    int64 res = 0;
        for (int i = 1; ; ++i) {
            int num = n - (i - 1) * (k - 1);
            if (num < i) break;
            int64 cur = f[num];
            cur *= rf[num - i];
            cur %= mod;
            int64 den = rf[n];
            den *= f[n - i];
            den %= mod;

//            int64 dden = f[n];
//            dden *= rf[n - i];
//            dden %= mod;
//            cerr << i << " " << cur << " " << dden << "\n";

            cur *= den;
            cur %= mod;
            res = (res + cur) % mod;
        }
        ++res;
        res %= mod;
        out << res << "\n";
	}

	int stupid(int n, int k) {
	    vi d(1 << n, -1);
	    for (int mask = (1 << n) - 1; mask >= 0; --mask) {
	        vi bits;
	        for (int i = 0; i < n; ++i) if ((mask >> i) % 2)
	            bits.pb(i);
	        bool bad = false;
	        for (int i = 0; i + 1 < sz(bits); ++i)
	            if (bits[i + 1] - bits[i] < k) {
	                bad = true;
	                break;
	            }
	        if (bad) {
	            d[mask] = 0;
	            continue;
	        }
	        d[mask] = 0;
	        for (int i = 0; i < n; ++i) if ((mask >> i) % 2 == 0) {
                d[mask] += (f[n - sz(bits) - 1] + d[mask ^ (1 << i)]) % mod;
                d[mask] %= mod;
            }
	    }
	    return d[0];
	}
};


int main() {
	TaskE solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	int n;
in >> n;
for(int i = 0; i < n; ++i) {
	solver.solve(in, out);
}

	return 0;
}