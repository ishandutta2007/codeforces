/*
Date: 2014/12/01 10:08:40 Monday
Author: xllend3
*/
#include<bits/stdc++.h>
using namespace std;
#define x first
#define y second
#define mp make_pair
#define ph push
#define pb push_back
#define REP(i,a,n) for(int _tmp=n,i=a;i<=_tmp;++i)
#define DEP(i,a,n) for(int _tmp=n,i=a;i>=_tmp;--i)
#define rep(i,a,n) for(int i=(a);i<=(n);++i)
#define dep(i,a,n) for(int i=(a);i>=(n);--i)
#define ALL(x,S) for(__typeof((S).end()) x=S.begin();x!=S.end();x++)
#define eps 1e-8
#define pi 3.1415926535897
#define sqr(x) ((x)*(x))
#define MAX(a,b) a=max(a,b)
#define MIN(a,b) a=min(a,b)
#define SZ(x) ((int)(x).size())
#define CPY(a,b) memcpy(a,b,sizeof(a))
#define CLR(a) memset(a,0,sizeof(a))
#define POSIN(x,y) (1<=(x)&&(x)<=n&&1<=(y)&&(y)<=m)
#define all(x) (x).begin(),(x).end()
#define COUT(S,x) cout<<fixed<<setprecision(x)<<S<<endl
typedef long long ll;
typedef double lf;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<lf,lf> pff;
typedef complex<double> CD;
const int inf=0x20202020;
const int mod=777777777;
template<class T> inline void read(T&x){bool fu=0;char c;for(c=getchar();c<=32;c=getchar());if(c=='-')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-'0';if(fu)x=-x;};
template<class T> inline void read(T&x,T&y){read(x);read(y);}
template<class T> inline void read(T&x,T&y,T&z){read(x);read(y);read(z);}
template<class T> inline void read(T&x,T&y,T&z,T&q){read(x);read(y);read(z);read(q);}
const int DX[]={1,0,-1,0},DY[]={0,1,0,-1};
ll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll powmod(ll a,ll b,ll mod) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
//*******************************************

const int N=266,M=111111;
int l,m,n,t;
ll C[N][N],f[N][N][N];
int pre[N]={507720408,412133651,386543325,139952108,289303402,102404925,317067177,396414708,80515854,663739304,317300809,228877044,493725043,715317967,490300965,315527373,743539734,488329191,553627998,533025234,242583957,706116537,614109258,645447222,523195911,492109128,722623041,111085128,766395126,654378921,691964847,496688157,399056049,654363234,102052314,191720088,473910948,259736526,332840025,388047555,665791056,627111387,139696515,441456687,443032569,283264821,771641703,452641455,511306362,117572859,127701891,721298331,176520078,357242229,611296308,696994956,405628839,429224274,465336054,695091546,689828796,574648641,351220905,507964023,675326610,517248963,453528621,220301928,494463186,681789969,339589656,44524053,417125457,339589404,747135963,341780733,734158215,396817281,21997836,5728464,147611205,456248898,714128667,377654949,3862068,128418948,589390074,304947090,11703825,228266073,127304142,429215724,361541124,521572968,468358191,341231688,65323503,613778508,15985323,291661029,410970006,591638112,349541550,89967528,224922159,361094166,584206074,640051812,324264456,652625388,693768537,11740617,309238398,211085469,194905872,639416484,110110707,296645895,748118511,131177718,511142751,775975599,421403409,475528473,434685258,1768977,80301375,708023862,569195676,56238084,632887668,88089750,631539342,396695565,38780154,695798271,469819224,439587099,69045921,682966116,112310856,64943298,534475872,40215357,389728458,286368453,736006257,501181650,54829908,603489402,338032656,512182818,627500097,462674016,3103092,157324491,43978329,596818971,259025598,9088632,91991781,577291428,211245489,429471231,142626330,172560633,510907446,444609585,758102058,375112647,744786693,276174402,19259856,233672418,745389414,225772848,23385663,324290610,519804558,120337812,402578568,360676008,450089262,551043738,337388940,512108856,28879011,690040638,106017282,558262341,99972432,608226003,612152037,42414435,776201013,39580443,518796945,494437752,583194366,723936555,415359657,309569589,751104774,166684527,249229170,353120823,130668327,753823584,580966092,561963717,543672234,393846327,586278000,327398400,278403867,156455586,363920382,190245195,290039148,547014447,466218648,146037150,585462906,666008595,691786683,374707494,622498779,231158277,685740951,115612245,681825249,545555745,551718468,277206615,640171035,757727334,195193908,658656684,457760646,225925875,505761984,18685233,506832921,112511021,396846646,290147622,113924623,669986155,336008070,63611061,238586775,119956662,616557739,772784623,334527774,410403148,51933421};
int pre128[N]={642497124,482164403,768209115,462063756,154906374,36099042,341766705,678182556,621882744,478771358,231881111,175889805,243630450,168908523,671961765,55761813,652682670,773939082,517628076,756201264,124604900,750976272,498253248,676047609,137170026,705610017,495032139,561797418,703097347,500815609,95984586,739707108,265613565,387099846,777331779,594676173,591219559,407997044,208947235,93337440,478908360,685013007,487033953,671903001,39521181,738490312,33785059,465470131,310453920,54648783,346831137,427694175,474743430,705296781,435828036,429824745,663532359,261388683,244690731,533997135,596108961,506813013,371892402,590145264,104733162,143420103,654339672,700348950,685038942,578826927,286484229,501639192,434962491,299270097,27702486,335375775,111746817,565603164,294926121,676063665,735862995,710035809,437011960,668528077,138765186,508213986,615036450,353784942,624827616,343900011,241289776,52410890,72018835,352406796,415705878,4802637,376367145,65589678,333633477,341834527,303717460,282387700,42951006,254706039,423048528,526429710,68131467,669954708,12787348,500636381,317959019,479433192,657133515,416259390,610216692,340129188,44594256,257373347,138718678,530767740,292922628,37220268,605295159,480722613,458170419,30540300,487159055,232966794,149150650};
int main(){
    //ios::sync_with_stdio(false);
#ifdef LOCAL
    freopen("CF256D.in","r",stdin);//freopen("CF256D.out","w",stdout);
#endif
    scanf("%d%d",&n,&m);
    if(n==256){printf("%d\n",pre[m]);return 0;}
    if(n==128){printf("%d\n",pre128[m]);return 0;}
    C[1][0]=C[1][1]=1;
    rep(i,2,n){C[i][0]=1;rep(j,1,i)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;}
    f[0][0][0]=1;
    rep(i,1,n)rep(j,0,n)rep(k,0,j){
        rep(l,1,j){
            if(l!=i){if(l<=k)f[i][j][k]+=f[i-1][j-l][k-l]*C[j][l];}
            else f[i][j][k]+=f[i-1][j-l][k]*C[j][l];
            f[i][j][k]%=mod;
            //printf("%d %d %d %d\n",i,j,k,f[i][j][k]);
        }f[i][j][k]=(f[i][j][k]+f[i-1][j][k])%mod;
    }printf("%d\n",f[n][n][m]);
    return 0;
}