/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#undef NDEBUG

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
// AtCoder library from https://github.com/atcoder/ac-library
// #include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

constexpr int BUBEN = 1700;
constexpr int INF = (int) 1.0001e9;

struct Query {
  int first;
  int second;
  int index;
};

class EOnlainKursPoFizkulture {
 public:
  void solveOne() {
    int n, k, q;
    cin >> n >> q >> k;
    vector<int> a(n);
    for (auto& x : a) cin >> x;
    vector<Query> s(q);
    int idx = 0;
    for (auto& x : s) {
      cin >> x.first >> x.second;
      --x.first; --x.second;
      x.index = idx++;
    }
    sort(all(s), [](const auto& a, const auto& b) {
      int ba = a.first / BUBEN;
      int bb = b.first / BUBEN;
      if (ba != bb) return ba < bb;
      return a.second < b.second;
    });
    int ptr = 0;
    vector<int64> jumpingSum(n);
    vector<int> change;
    vector<int> changeFrom;
    vector<int64> answers(q, -1);
    for (int block = 0; block * BUBEN < n; ++block) {
      int blockEnd = (block + 1) * BUBEN;
      int next = blockEnd;
      int bestOuter = INF;
      change.clear();
      changeFrom.clear();
      while (ptr < s.size() && s[ptr].first < blockEnd) {
        int upto = min(blockEnd - 1, s[ptr].second);
        int best = INF;
        int rem = 0;
        int64 score = 0;
        for (int i = s[ptr].first; i <= upto; ++i) {
          best = min(best, a[i]);
          --rem;
          if (rem < 0) {
            score += best;
            rem += k;
          }
        }
        if (s[ptr].second >= blockEnd) {
          while (next <= s[ptr].second) {
            if (a[next] < bestOuter) {
              bestOuter = a[next];
              change.push_back(-bestOuter);
              changeFrom.push_back(next);
            }
            jumpingSum[next] = bestOuter;
            if (next - k >= blockEnd) {
              jumpingSum[next] += jumpingSum[next - k];
            }
            ++next;
          }
          int i = lower_bound(all(change), -best) - change.begin();
          int changeAt;
          if (i >= change.size()) {
            changeAt = s[ptr].second;
          } else {
            changeAt = changeFrom[i] - 1;
          }
          int oldPriceCount = (changeAt - blockEnd - rem + k) / k;
          int totalPriceCount = (s[ptr].second - blockEnd - rem + k) / k;
          if (totalPriceCount > 0) {
            int last = blockEnd + rem + k * (totalPriceCount - 1);
            if (oldPriceCount <= 0) {
              score += jumpingSum[last];
            } else {
              int old = blockEnd + rem + k * (oldPriceCount - 1);
              score += jumpingSum[last] - jumpingSum[old] + oldPriceCount * (int64) best;
            }
          }
        }
        answers[s[ptr].index] = score;
        ++ptr;
      }
    }
    assert(ptr == q);
    for (auto x : answers) {
      cout << x << "\n";
    }
  }

  void solve() {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne();
    }
  }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    EOnlainKursPoFizkulture solver;


    solver.solve();
    return 0;
}