/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

constexpr int maxn = 5010;

int p;

int C[maxn][maxn];
int f[maxn];

class TaskD {
public:
	void solve(std::istream& in, std::ostream& out) {
	    int n;
	    in >> n >> p;
	    memset(C, 0, sizeof(C));
	    C[0][0] = 1;
	    for (int i = 1; i <= n; ++i) {
	        C[i][0] = 1;
	        for (int j = 1; j <= i; ++j) {
	            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;
	        }
	    }
	    f[0] = 1;
	    for (int i = 1; i <= n; ++i) {
	        f[i] = (f[i - 1] * (int64) i) % p;
	    }

	    vi d(n + 1);
	    d[n] = 1;
	    d[0] = 0;
	    for (int i = n - 1; i >= 1; --i) {
	        int64 x = C[n][i];
	        int m = (n + 1) / 2;
	        int64 bad = C[m - 1][i - 1];
	        bad *= n;
	        bad %= p;
	        x -= bad;
	        x %= p;
	        x += p;
	        x %= p;
	        d[i] = x;
	    }
	    int64 res = 0;
	    for (int i = 1; i <= n; ++i) {
	        int64 x = d[i] * (int64) i;
	        x %= p;
	        x -= d[i - 1] * (int64)  (n - i + 1);
	        x %= p;
	        x += p;
	        x %= p;
	        x *= f[n - i];
	        x %= p;
	        res += x;
	        res %= p;
	    }
	    out << res << "\n";
	}
};


int main() {
	TaskD solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}