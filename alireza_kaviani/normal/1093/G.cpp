/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author alireza_kaviani
 */

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template<class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define Mp                          make_pair
#define sep                         ' '
#define endl                        '\n'
#define debug(x)                    cerr << #x << " = " << x << endl
#define SZ(x)                       ll(x.size())
#define fast_io                     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define set_random                  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 2e5 + 10;
const ll MAXK = 5;
const ll INF = 1e9;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

struct Node {
    int mn, mx;

    Node(int MN = INF, ll MX = -INF) {
        mn = MN, mx = MX;
    }

    friend Node merge(const Node &x, const Node &y) {
        return Node(min(x.mn, y.mn), max(x.mx, y.mx));
    }
};

template<class T, ll N>
struct SegTree {
    T seg[4 * N];

    void Build(int id, int l, int r, int arr[]) {
        if (l == r) {
            seg[id] = T(arr[l], arr[r]);
            return;
        }
        int mid = (l + r) >> 1;
        Build((id << 1), l, mid, arr);
        Build((id << 1) | 1, mid + 1, r, arr);
        seg[id] = merge(seg[(id << 1)], seg[(id << 1) | 1]);
    }

    void Modify(int id, int l, int r, int x, int val) {
        if (x < l || r < x) return;
        if (l == r) {
            seg[id] = T(val, val);
            return;
        }
        int mid = (l + r) >> 1;
        Modify((id << 1), l, mid, x, val);
        Modify((id << 1) | 1, mid + 1, r, x, val);
        seg[id] = merge(seg[(id << 1)], seg[(id << 1) | 1]);
    }

    T Get(int id, int l, int r, int ql, int qr) {
        if (qr < l || r < ql || ql > qr) return T();
        if (ql <= l && r <= qr) return seg[id];

        int mid = (l + r) >> 1;
        return merge(Get((id << 1), l, mid, ql, qr), Get((id << 1) | 1, mid + 1, r, ql, qr));
    }

    void build(int arr[]) {
        Build(1, 0, N - 1, arr);
    }

    void modify(int x, int val) {
        Modify(1, 0, N - 1, x, val);
    }

    T get(int ql, int qr) {
        return Get(1, 0, N - 1, ql, qr);
    }
};

int n, k, q, A[MAXN][MAXK], B[MAXK], val[1 << MAXK][MAXN];
SegTree<Node, MAXN> seg[1 << MAXK];

int main() {
    fast_io;

    cin >> n >> k;
    for (ll i = 1; i <= n; i++) {
        for (ll j = 0; j < k; j++) {
            cin >> A[i][j];
            for (ll l = 0; l < (1 << k); l++) {
                if ((1 << j) & l) {
                    val[l][i] += A[i][j];
                } else {
                    val[l][i] -= A[i][j];
                }
            }
        }
    }

    for (ll i = 0; i < (1 << k); i++) seg[i].build(val[i]);

    cin >> q;
    while (q--) {
        ll type, ans = 0;
        cin >> type;
        if (type == 1) {
            ll ind, v[(1 << MAXK)];
            fill(v, v + (1 << MAXK), 0);
            cin >> ind;
            for (ll i = 0; i < k; i++) {
                cin >> B[i];
                for (ll j = 0; j < (1 << k); j++) {
                    if ((1 << i) & j) v[j] += B[i];
                    else v[j] -= B[i];
                }
            }

            for (ll i = 0; i < (1 << k); i++) seg[i].modify(ind, v[i]);
        }

        if (type == 2) {
            ll l, r;
            cin >> l >> r;
            for (ll i = 0; i < (1 << k); i++) {
                Node t = seg[i].get(l, r);
                ans = max(ans, ll(t.mx - t.mn));
            }
            cout << ans << endl;
        }
    }

    return 0;
}
/*

*/