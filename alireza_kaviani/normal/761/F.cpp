/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool (Windows, macOS, Linux)
 * Author: alireza_kaviani
 * Time: 2020-08-24 12:43:28
**/
#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<int, int> pii;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define sep                         ' '
#define endl                        '\n'
#define SZ(x)                       ll(x.size())

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

const ll MAXN = 1e3 + 10;
const ll MAXK = 3e5 + 10;
const ll LOG = 22;
const ll INF = 8e18;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

int n , m , k , diff[MAXK] , lx[MAXK] , ly[MAXK] , rx[MAXK] , ry[MAXK] , c[MAXK] ;
ll sum , val[MAXN][MAXN] , F[MAXN][MAXN] , cnt[26][MAXN][MAXN] , ps[26][MAXN][MAXN];
string s[MAXN];


int main() {
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

	cin >> n >> m >> k;
	for(int i = 1 ; i <= n ; i++){
		cin >> s[i];
		s[i] = "." + s[i];
		for(int j = 1 ; j <= m ; j++){
			ps[s[i][j] - 97][i][j]++;
		}
	}
	for(int i = 0 ; i < 26 ; i++){
		for(int j = 1 ; j <= n ; j++){
			for(int k = 1 ; k <= m ; k++){
				ps[i][j][k] += ps[i][j - 1][k] + ps[i][j][k - 1] - ps[i][j - 1][k - 1];
			}
			//cout << i << sep << j << sep << k << sep << ps[i][j][k] << endl;
		}
	}
	for(int i = 0 ; i < k ; i++){
		string s;
		cin >> lx[i] >> ly[i] >> rx[i] >> ry[i] >> s;
		c[i] = s[0] - 97;
		//cout << lx[i] << sep << ly[i] << sep << rx[i] << sep << ry[i] << sep << c[i] << endl;
		cnt[c[i]][lx[i]][ly[i]]++;
		cnt[c[i]][lx[i]][ry[i] + 1]--;
		cnt[c[i]][rx[i] + 1][ly[i]]--;
		cnt[c[i]][rx[i] + 1][ry[i] + 1]++;
		F[lx[i]][ly[i]]++;
		F[lx[i]][ry[i] + 1]--;
		F[rx[i] + 1][ly[i]]--;
		F[rx[i] + 1][ry[i] + 1]++;
		for(int j = 0 ; j < 26 ; j++){
			diff[i] += abs(c[i] - j) * (ps[j][rx[i]][ry[i]] - ps[j][rx[i]][ly[i] - 1] - ps[j][lx[i] - 1][ry[i]] + ps[j][lx[i] - 1][ly[i] - 1]);
		}
		sum += diff[i];
		//cout << i << sep << diff[i] << endl;
	}
	for(int i = 0 ; i < 26 ; i++){
		for(int j = 1 ; j <= n ; j++){
			for(int k = 1 ; k <= m ; k++){
				cnt[i][j][k] += cnt[i][j - 1][k] + cnt[i][j][k - 1] - cnt[i][j - 1][k - 1];
				//cout << i << sep << j << sep << k << sep << cnt[i][j][k] << endl;
			}
		}
	}
	memset(ps , 0 , sizeof(ps));
	for(int i = 1 ; i <= n ; i++){
		for(int j = 1 ; j <= m ; j++){
			ll c = s[i][j] - 97;
			for(int k = 0 ; k < 26 ; k++){
				val[i][j] += abs(c - k) * cnt[k][i][j];
			}
			//cout << i << sep << j << sep << val[i][j] << endl;
			val[i][j] += val[i - 1][j] + val[i][j - 1] - val[i - 1][j - 1];
			F[i][j] += F[i - 1][j] + F[i][j - 1] - F[i - 1][j - 1];
			//cout << i << sep << j << sep << F[i][j] << endl;
			ps[s[i][j] - 97][i][j] = F[i][j];
		}
	}
	for(int i = 0 ; i < 26 ; i++){
		for(int j = 1 ; j <= n ; j++){
			for(int k = 1 ; k <= m ; k++){
				ps[i][j][k] += ps[i][j - 1][k] + ps[i][j][k - 1] - ps[i][j - 1][k - 1];
				cnt[i][j][k] += cnt[i][j - 1][k] + cnt[i][j][k - 1] - cnt[i][j - 1][k - 1];
				//cout << i << sep << j << sep << k << sep << ps[i][j][k] << endl;
				//cout << i << sep << j << sep << k << sep << cnt[i][j][k] << endl;
			}
		}
	}
	ll ans = 1e18;
	//cout << sum << endl;
	for(int i = 0 ; i < k ; i++){
		ll cur = sum + 1ll * k * diff[i] - val[rx[i]][ry[i]] + val[rx[i]][ly[i] - 1] + val[lx[i] - 1][ry[i]] - val[lx[i] - 1][ly[i] - 1];
		for(int j = 0 ; j < 26 ; j++){
			cur -= abs(c[i] - j) * (ps[j][rx[i]][ry[i]] - ps[j][rx[i]][ly[i] - 1] - ps[j][lx[i] - 1][ry[i]] + ps[j][lx[i] - 1][ly[i] - 1]);
			cur += abs(c[i] - j) * (cnt[j][rx[i]][ry[i]] - cnt[j][rx[i]][ly[i] - 1] - cnt[j][lx[i] - 1][ry[i]] + cnt[j][lx[i] - 1][ly[i] - 1]);
		}
		//cout << i << sep << cur << endl;
		ans = min(ans , cur);
	}
	cout << ans << endl;
	

    return 0;
}
/*

*/