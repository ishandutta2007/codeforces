/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#undef NDEBUG

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
// AtCoder library from https://github.com/atcoder/ac-library
// #include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

class FStrannieInstruktsii {
 public:
  void solveOne() {
    int n;
    int64 a, b, c;
    cin >> n >> a >> b >> c;
    string s;
    cin >> s;
    int n00 = 0;
    int n11 = 0;
    int n10 = 0;
    int nwaste = 0;
    int last1 = -1;
    for (int i = 0; i < n; ++i) if (s[i] == '1') {
      last1 = i;
    }
    vector<int> blocks;
    int sz = 0;
    for (int i = 0; i <= n; ++i) {
      if (i < n && s[i] == '0') {
        ++sz;
      } else {
        if (sz) blocks.push_back(sz);
        sz = 0;
      }
    }
    vector<int> wastes;
    for (int i = 0; i + 1 < n; ++i) {
      if (s[i] == '1' && s[i + 1] == '1') ++n11;
      if (s[i] == '0' && s[i + 1] == '0') ++n00;
      if (s[i] == '1' && s[i + 1] == '0') {
        if (i + 1 < last1) ++n10; else {
          ++nwaste;
          wastes.push_back(blocks.back());
          blocks.pop_back();
        }
      }
    }
    if (s[0] == '0') {
      ++nwaste;
      wastes.push_back(blocks.front());
      blocks.erase(blocks.begin());
    }
    assert(blocks.size() == n10);
    assert(wastes.size() == nwaste);
    sort(all(blocks));
    vector<int> psum(blocks.size() + 1);
    for (int i = 0; i < blocks.size(); ++i) {
      psum[i + 1] = psum[i] + blocks[i];
    }
    sort(all(wastes));
    vector<int> wsum(wastes.size() + 1);
    for (int i = 0; i < wastes.size(); ++i) {
      wsum[i + 1] = wsum[i] + wastes[i];
    }
    int64 res = 0;
    for (int s1 = 0; s1 < 2; ++s1) {
      for (int t10 = 0; t10 <= n10; ++t10) {
        for (int w = 0; w <= nwaste; ++w) {
          int avail0 = n00 + t10 + w;
          int avail1 = n11 + t10;
          int real1 = min(avail1, avail0 + s1);
          int real0 = real1 - s1;
          if (real0 >= psum[t10] + wsum[w] && real1 >= 0) {
            int64 got = a * (real0 - t10 - w) + b * real1 - c * (t10 + w);
            if (real0 - t10 - w < n00) {
              got += a;
            }
            res = max(res, got);
          }
        }
      }
    }
    cout << res << "\n";
  }

  void solve() {
    int nt;
    cin >> nt;
    for (int it = 0; it < nt; ++it) {
      // cout << "Case #" << (it + 1) << ": ";
      solveOne();
    }
  }
};

// #define st_mtimespec st_mtim

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    FStrannieInstruktsii solver;


    solver.solve();
    return 0;
}