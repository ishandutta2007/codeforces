/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>

#define pb push_back
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define mp make_pair

using namespace std;

typedef long long int64;
typedef vector<int> vi;
typedef pair<int, int> ii;

constexpr int64 MODULO = (int64) 1e9 + 7;

class TaskE {
 public:
  vector<int> add;
  vector<bool> subtreeClear;
  int treeTotal;

  void treeAdd(int root, int rl, int rr, int left, int right, int by) {
    if (left > right) return;
    subtreeClear[root] = false;
    if (left == rl && right == rr) {
      add[root] = (add[root] + by) % MODULO;
      treeTotal = (treeTotal + (right - left + 1) * (int64) by) % MODULO;
      return;
    }
    int rm = (rl + rr) >> 1;
    treeAdd(root * 2 + 1, rl, rm, left, min(rm, right), by);
    treeAdd(root * 2 + 2, rm + 1, rr, max(rm + 1, left), right, by);
  }

  void treeClear(int root, int rl, int rr, int left, int right) {
    if (left > right) return;
    if (subtreeClear[root]) return;
    if (left == rl && right == rr) {
      treeTotal = (treeTotal - add[root] * (int64) (right - left + 1)) % MODULO;
      if (treeTotal < 0) treeTotal += MODULO;
      add[root] = 0;
    }
    if (add[root] != 0) {
      add[root * 2 + 1] = (add[root * 2 + 1] + add[root]) % MODULO;
      add[root * 2 + 2] = (add[root * 2 + 2] + add[root]) % MODULO;
      subtreeClear[root * 2 + 1] = false;
      subtreeClear[root * 2 + 2] = false;
      add[root] = 0;
    }
    if (rl != rr) {
      int rm = (rl + rr) >> 1;
      treeClear(root * 2 + 1, rl, rm, left, min(rm, right));
      treeClear(root * 2 + 2, rm + 1, rr, max(rm + 1, left), right);
      subtreeClear[root] = subtreeClear[root * 2 + 1] && subtreeClear[root * 2 + 2] && add[root] == 0;
    } else {
      subtreeClear[root] = add[root] == 0;
    }
  }

  int64 innerSolve(vector<int> zeros) {
    assert(zeros.size() > 0);
    if (zeros.size() == 1) {
      return zeros[0] % MODULO;
    }
    int64 mult = (zeros[0] + 1) * (int64) (zeros.back() + 1) % MODULO;
    zeros.pop_back();
    zeros.erase(zeros.begin());
    int mx = 1;
    for (int x : zeros) mx = max(mx, x + 1);
    add = vector<int>(4 * mx + 10);
    subtreeClear = vector<bool>(4 * mx + 10, true);
    treeTotal = 0;
    treeAdd(0, 0, mx - 1, 0, 0, 1);
    for (int cur : zeros) {
      int total = treeTotal;
      treeClear(0, 0, mx - 1, 0, cur);
      treeAdd(0, 0, mx - 1, 0, cur, total);
      treeAdd(0, 0, mx - 1, 0, 0, 1);
    }
    return treeTotal * mult % MODULO;
  }

  void solveOne(istream &in, ostream &out) {
    string s;
    in >> s;
    s += "1";
    vector<int> zeros;
    int size = 0;
    for (int i = 0; i < s.size(); ++i) {
      if (s[i] == '0') {
        ++size;
      } else {
        zeros.push_back(size);
        size = 0;
      }
    }
    out << innerSolve(zeros) << "\n";
  }

  void solve(std::istream &in, std::ostream &out) {
    int nt = 1;
    for (int it = 0; it < nt; ++it) {
      solveOne(in, out);
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  TaskE solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}