#include "bits/stdc++.h"
using namespace std;
// add your library with double quotation #include"" here.
// #include "atcoder/all"
// using namespace atcoder;

// define your macros here.
// #define REP(a,b) for(long long a = 0;a < b;++a)

using namespace std;
typedef string::const_iterator State;
#define eps 1e-8L
#define MAX_MOD 1000000007LL
#define GYAKU 500000004LL
#define MOD 998244353LL
#define pb push_back
#define mp make_pair
typedef long long ll;
typedef long double ld;
#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))
#define ALL(x) (x).begin(),(x).end()

#define int ll
map<int,int> vertexs[300000];
vector<int> Sums[300000];
int ut[300000];
int uf(int now) {
    if (ut[now] == now) return now;
    return ut[now] = uf(ut[now]);
}
int um(int a, int b) {
    a = uf(a);
    b = uf(b);
    if (Sums[a].size() < Sums[b].size()) swap(a, b);
    ut[b] = a;
    for (auto x : Sums[b]) {
        Sums[a].push_back(x);
    }
    return 0;
}
void solve() {
    int n, m;
    cin >> n >> m;
    int Input_xor = 0;
    vector<tuple<int, int, int>> edges;
    REP(i, m) {
        int a, b, c;
        cin >> a >> b >> c;
        a--; b--;
        edges.push_back(make_tuple(c, a, b));
        Input_xor ^= c;
        vertexs[a][b] = c;
        vertexs[b][a] = c;
    }
    if (m == n * (n - 1) / 2 - 1) {
        // add final vertex.
        vector<int> hints;
        REP(i, n) {
            if (vertexs[i].size() != n - 1) {
                hints.push_back(i);
            }
        }
        vertexs[hints[0]][hints[1]] = Input_xor;
        vertexs[hints[1]][hints[0]] = Input_xor;
        edges.push_back(make_tuple(Input_xor, hints[0], hints[1]));
    }
    REP(i, n) {
        ut[i] = i;
        Sums[i] = { i };
    }
    vector<int> next_go;
    next_go.push_back(0);
    int now_xor = Input_xor;
    int now_ans = 0;
    int cnt = m;
    vector<tuple<int, int, int>> used_edge;
    for (int i = 1; i < n; ++i) {
        vector<int> Targets;
        for(int q = 0;q < next_go.size();++q){
            int itring = uf(next_go[q]);
            for (int j = 0; j < Sums[itring].size(); ++j) {
                int x = Sums[itring][j];
                if (vertexs[i].find(x) == vertexs[i].end()) {
                    //use free edge.
                    um(x, i);
                    next_go.erase(next_go.begin() + q);
                    cnt++;
                    q--;
                    break;
                }
            }
        }
        next_go.push_back(i);
    }
    sort(ALL(edges));
    REP(i, edges.size()) {
        if (uf(get<1>(edges[i])) != uf(get<2>(edges[i]))) {
            now_ans += get<0>(edges[i]);
            um(get<1>(edges[i]), get<2>(edges[i]));
            used_edge.push_back(edges[i]);
        }
        else {
            now_xor = min(now_xor, get<0>(edges[i]));
        }
    }
    int final_ans = now_ans;
    if (cnt == n * (n - 1) / 2) {
        final_ans += now_xor;

    }
    cout << final_ans << endl;
}
#undef int

// generated by oj-template v4.7.2 (https://github.com/online-judge-tools/template-generator)
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    cout << fixed << setprecision(100);
    int t = 1;
    //cin >> t;
    REP(test, t) {
        solve();
    }
    return 0;
}