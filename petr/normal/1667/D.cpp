/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

// Actual solution is at the bottom

#undef NDEBUG

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cstdint>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <vector>
// AtCoder library from https://github.com/atcoder/ac-library
// #include "../atcoder/all"

#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()

using namespace std;

typedef int64_t int64;
typedef pair<int, int> ii;

class DUdalenieRyober {
 public:
  void solveOne() {
    int n;
    cin >> n;
    vector<vector<int>> adj(n);
    for (int i = 0; i < n - 1; ++i) {
      int u, v;
      cin >> u >> v;
      --u; --v;
      adj[u].push_back(v);
      adj[v].push_back(u);
    }
    vector<int> dp(n);

    auto dfs1 = [&](auto self, int root, int skip) -> int {
      int& res = dp[root];
      vector<int> cnt(4);
      int num_children = 0;
      for (auto x : adj[root]) {
        if (x == skip) continue;
        ++cnt[self(self, x, root)];
        ++num_children;
      }
      int start = adj[root].size() % 2;
      for (int up = 0; up < 2; ++up) {
        vector<int> need(2);
        if (skip == -1) {
          if (up != 0) continue;
          need[start] = (num_children + 1) / 2;
          need[1 - start] = num_children / 2;
        } else {
          if (up == start) {
            need[1 - start] = (num_children + 1) / 2;
            need[start] = num_children / 2;
          } else {
            if (num_children == 0) continue;
            need[start] = num_children / 2 + 1;
            need[1 - start] = (num_children - 1) / 2;
          }
        }
        if (cnt[1] + cnt[3] >= need[0] && cnt[2] + cnt[3] >= need[1] && cnt[1] + cnt[2] + cnt[3] >= need[0] + need[1]) {
          res |= 1 << up;
        }
      }
      return res;
    };

    dfs1(dfs1, 0, -1);

    if (dp[0] == 0) {
      cout << "NO\n";
      return;
    }
    cout << "YES\n";

    auto dfs2 = [&](auto self, int root, int skip, int up) -> void {
      vector<vector<int>> children(4);
      int num_children = 0;
      for (auto x : adj[root]) {
        if (x == skip) continue;
        children[dp[x]].push_back(x);
        ++num_children;
      }
      int start = adj[root].size() % 2;
      if (skip == -1) {
        for (int i = 0; i < num_children; ++i) {
          int tag = 1 << start;
          if (children[tag].empty()) tag = 3;
          int cur = children[tag].back();
          children[tag].pop_back();
          self(self, cur, root, start);
          start ^= 1;
        }
      } else {
        if (up == start) {
          cout << (root + 1) << " " << (skip + 1) << "\n";
          start ^= 1;
          for (int i = 0; i < num_children; ++i) {
            int tag = 1 << start;
            if (children[tag].empty()) tag = 3;
            int cur = children[tag].back();
            children[tag].pop_back();
            self(self, cur, root, start);
            start ^= 1;
          }
        } else {
          for (int i = 0; i < 1; ++i) {
            int tag = 1 << start;
            if (children[tag].empty()) tag = 3;
            int cur = children[tag].back();
            children[tag].pop_back();
            self(self, cur, root, start);
            start ^= 1;
          }
          cout << (root + 1) << " " << (skip + 1) << "\n";
          start ^= 1;
          for (int i = 0; i < num_children - 1; ++i) {
            int tag = 1 << start;
            if (children[tag].empty()) tag = 3;
            int cur = children[tag].back();
            children[tag].pop_back();
            self(self, cur, root, start);
            start ^= 1;
          }
        }
      }
    };

    dfs2(dfs2, 0, -1, 0);
  }

  void solve() {
    int nt;
    cin >> nt;
    for (int it = 0; it < nt; ++it) {
      // cout << "Case #" << (it + 1) << ": ";
      solveOne();
    }
  }
};

// #define st_mtimespec st_mtim

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    DUdalenieRyober solver;


    solver.solve();
    return 0;
}