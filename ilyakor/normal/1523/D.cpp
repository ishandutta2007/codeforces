/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <set>
#include <map>
#include <cassert>
#include <functional>
#include <sstream>
#include <cmath>

#include <cstring>
#include <cstdio>
#include <random>
#include <bits/stdc++.h>

using namespace std;

typedef pair<int, int> ii;
typedef long long int64;
typedef vector<int> vi;

#define pb push_back
#define mp make_pair
#define all(v) (v).begin(),(v).end()
#define sz(v) ((int)(v).size())

template<class T> T abs(T x) { return x >= 0 ? x : -x; }
template<class T> T sqr(T x) { return x * x; }

class TaskD {
public:
	void solve(std::istream& in, std::ostream& out) {
	    int n, m, p;
	    in >> n >> m >> p;
//	    n = 200 * 1000;
//	    m = 60;
//	    p = 15;
	    int64 seed = 0;
	    seed = n + 1;
	    seed *= 983741;
	    seed += m;
        seed *= 3983741;
        seed += p;
	    vector<int64> a(n);
	    for (int i =0 ;i < n; ++i) {
	        string s;
	        in >> s;
//	        for (int j = 0; j < m; ++j)
//	            s += (j < 15 ? '1' : '0');
	        int64 mask = 0;
	        for (int j = 0; j < m; ++j) if (s[j] == '1') {
	            mask |= (1LL << (int64) j);
	        }
	        a[i] = mask;
            seed *= 893274221;
            seed += mask;
	    }
        mt19937 g(static_cast<uint32_t>(time(0) + seed));
	    shuffle(all(a), g);
	    int64 res_mask = 0;
	    int res = 0;
	    for (int it = 0; it < min(50, sz(a)); ++it) {
	        int64 cur = a[it];
	        vi bits;
	        for (int i = 0; i < m; ++i) {
                if ((cur >> (int64) i) % 2LL == 1LL) {
                    bits.pb(i);
                }
            }
	        assert(sz(bits) <= p);
	        int l = sz(bits);
	        vi d(1 << l, 0);
	        int M = (1 << l) - 1;
	        for (int i = 0; i < n; ++i) {
	            int ms = 0;
	            for (int j = 0; j < sz(bits); ++j)
	                if ((a[i] >> (int64) bits[j]) % 2LL == 1LL)
	                    ms |= (1 << j);
                d[M ^ ms]++;
	        }
	        for (int i = 0; i < l; ++i) {
                for (int j = 0; j < (1 << l); ++j) {
                    if ((j >> i) % 2 == 0) {
                        d[j | (1 << i)] += d[j];
                    }
                }
            }
	        for (int i = 0; i < (1 << l); ++i)
	            if (d[i] >= (n + 1) / 2) {
	                int mask = M ^ i;
	                if (__builtin_popcount(mask) > res) {
	                    res = __builtin_popcount(mask);
	                    res_mask = 0;
                        for (int j = 0; j < sz(bits); ++j) {
                            if ((mask >> j) % 2) {
                                res_mask |= (1LL << (int64) bits[j]);
                            }
                        }
	                }
	            }
	    }
	    for (int i = 0; i < m; ++i)
	        out << ((res_mask >> (int64) i) % 2);
	    out << "\n";
	}
};


int main() {
	TaskD solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}